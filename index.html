<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ID Pages by The Refresh</title>
  <link rel="icon" type="image/png" href="../fre5hfence/RF5.png?v=2">
  <link rel="shortcut icon" type="image/png" href="../fre5hfence/RF5.png?v=2">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
    :root { --primary: #2196F3; --accent: #ffd869; --text: #e4e8ff; --bg: #050810; --card-bg: rgba(5, 10, 24, 0.9); --border: rgba(120, 141, 255, 0.25); --input-bg: rgba(0, 0, 0, 0.4); }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: radial-gradient(circle at top left, #202738 0, #050810 55%, #020308 100%) fixed; color: var(--text); line-height: 1.6; overflow-x: hidden; }
    .hidden { display: none !important; }

    /* --- HEADER --- */
    .main-header { display: flex; align-items: center; justify-content: space-between; padding: 15px 30px; background: rgba(5, 8, 16, 0.95); border-bottom: 1px solid rgba(255,255,255,0.1); position: sticky; top: 0; z-index: 3000; height: 80px; backdrop-filter: blur(10px); }
    .header-left { display: flex; align-items: center; gap: 15px; }
    .header-logo { height: 45px; filter: drop-shadow(0 0 5px var(--primary)); }
    .header-title { font-weight: 800; font-size: 1.4rem; color: #fff; letter-spacing: 1px; text-transform: uppercase; }

/* Center nav + small search */
.header-center{
  flex: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 16px;
  padding: 0 20px;
}

.center-nav{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 18px;
  flex-wrap: nowrap;
}

/* Make nav-item a solid hover anchor */
.nav-item{
  position: relative;
  padding: 10px 6px; /* creates a reliable hover hitbox */
}

/* Dropdown: attach to the nav-item edge, not an arbitrary px value */
.nav-dropdown{
  position:absolute;
  top: calc(100% + 10px);
  left: 0;
  min-width: 230px;
  background: #1a202c;
  border: 1px solid rgba(120,141,255,0.25);
  border-radius: 12px;
  padding: 10px;
  display:none;
  flex-direction:column;
  gap: 4px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  z-index: 2600;
}

/* Hover bridge: invisible strip so the dropdown stays “reachable” */
.nav-dropdown::before{
  content:"";
  position:absolute;
  left:0;
  right:0;
  top:-10px;
  height:10px;
}

/* Show dropdown on hover */
.nav-item:hover .nav-dropdown{ display:flex; }

.drop-link{
  padding: 10px;
  color:#e4e8ff;
  text-decoration:none;
  border-radius: 8px;
  font-size: 0.9rem;
}
.drop-link:hover{ background: rgba(255,255,255,0.05); color:#fff; }

.mini-search{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: 999px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.10);
  max-width: 240px;
}
.mini-search-input{
  background: transparent;
  border: none;
  color: #fff;
  outline: none;
  width: 160px;
}

/* Wallet icon (Studio style) */
.icon-wrap{
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  transition: 0.2s;
}
.icon-wrap:hover{ background: rgba(255,255,255,0.06); }
.wallet-ico{ font-size: 1.2rem; color: var(--primary); }

/* Mobile */
.mobile-menu-btn{ display:none; background: transparent; border: 1px solid rgba(255,255,255,0.12); color:#fff; padding: 8px 12px; border-radius: 10px; cursor:pointer; }
@media (max-width: 900px){
  /* 1. Reduce outer padding so the header fits on small screens */
  .main-header { padding: 15px 10px; } 
  
  /* 2. Reduce the gap between icons on the right */
  .header-right { gap: 8px; } 
  
  .header-center{ justify-content:flex-start; }
  .center-nav{ display:none; }
  
  /* 3. Shrink the search bar slightly to prevent pushing items off screen */
  .mini-search{ max-width: 140px; } 
  .mini-search-input{ width: 100%; } 
  
  .mobile-menu-btn{ display:block; }
}

    .header-right { display: flex; align-items: center; gap: 20px; }
    .nav-link { color: #b7c3ff; text-decoration: none; font-weight: 600; font-size: 0.95rem; transition: color 0.2s; white-space: nowrap;}
    .nav-link:hover { color: #fff; }

    .wallet-balance { font-family: monospace; color: var(--accent); border: 1px solid var(--accent); padding: 4px 10px; border-radius: 8px; font-size: 0.9rem; display: none; }
    
    /* PROFILE DROPDOWN */
    .profile-menu-container { position: relative; }
    .header-pfp { width: 40px; height: 40px; border-radius: 50%; border: 2px solid var(--border); object-fit: cover; cursor: pointer; transition: border-color 0.2s; }
    .header-pfp:hover { border-color: var(--primary); }
    .profile-dropdown { position: absolute; top: 50px; right: 0; width: 220px; background: #1a202c; border: 1px solid var(--border); border-radius: 12px; padding: 10px; display: none; flex-direction: column; gap: 5px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);z-index: 9999; }
    .wallet-menu-container{ position: relative; }

.wallet-dropdown{
  position: absolute;
  top: 50px;
  right: 0;
  width: 260px;
  background: #1a202c;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 10px;
  display: none;
  flex-direction: column;
  gap: 5px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  z-index: 9999;
}

.wallet-dropdown.show{ display:flex; }

.wallet-dropdown .menu-item img{
  width: 20px;
  height: 20px;
  border-radius: 4px;
}
    .menu-item { padding: 10px; color: #e4e8ff; cursor: pointer; border-radius: 6px; font-size: 0.9rem; display: flex; align-items: center; gap: 10px; text-decoration: none; }
    .menu-item:hover { background: rgba(255,255,255,0.05); color: #fff; }
    .menu-item i { width: 20px; text-align: center; color: var(--primary); }
    
/* --- ENHANCED NOTIFICATIONS --- */
    .notif-wrapper { position: relative; cursor: pointer; margin-right: 5px; }
    .notif-bell { font-size: 1.2rem; color: #fff; transition: color 0.2s; }
    .notif-bell:hover { color: var(--accent); }
    
    .notif-dot { 
        position: absolute; top: -2px; right: -2px; width: 8px; height: 8px; 
        background: #ff6b6b; border-radius: 50%; display: none; pointer-events: none;
    }

    /* Container */
    .notif-dropdown { 
        position: absolute; 
        top: 40px; 
        right: -10px; 
        width: 320px; 
        background: #1a202c; 
        border: 1px solid var(--border); 
        border-radius: 12px; 
        display: none; 
        flex-direction: column; 
        box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
        z-index: 2500; 
        overflow: hidden; /* Key for header corners */
    }

    /* Tabs Header */
    .notif-header {
        display: flex;
        background: rgba(255,255,255,0.05);
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .notif-tab {
        flex: 1;
        text-align: center;
        padding: 12px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        color: #8899ac;
        transition: all 0.2s;
    }
    
    .notif-tab:hover { color: #fff; background: rgba(255,255,255,0.05); }
    
    .notif-tab.active {
        color: var(--primary);
        background: rgba(33, 150, 243, 0.1);
        border-bottom: 2px solid var(--primary);
    }

    /* Scrollable List Area */
    .notif-list-container {
        max-height: 350px; /* Limits height */
        overflow-y: auto;  /* Enables scroll */
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    /* Individual Item */
    .notif-item { 
        font-size: 0.85rem; 
        padding: 10px; 
        border-radius: 6px; 
        background: rgba(255,255,255,0.05); 
        border-left: 3px solid #4CAF50; 
        
        /* Text Wrapping Fixes */
        white-space: normal;
        word-break: break-word;
        line-height: 1.4;
        color: #e4e8ff;
    }
    .notif-item.read { border-left-color: #8899ac; opacity: 0.7; }
    .notif-item.error { border-left-color: #ff6b6b; }

    /* See More Button */
    .notif-load-more {
        width: 100%;
        padding: 8px;
        background: transparent;
        border: 1px dashed rgba(255,255,255,0.2);
        color: var(--accent);
        font-size: 0.8rem;
        cursor: pointer;
        margin-top: 5px;
        border-radius: 6px;
        transition: 0.2s;
    }
    .notif-load-more:hover { background: rgba(255,255,255,0.05); border-color: var(--accent); }

    /* Mobile Adjustment */
    @media (max-width: 500px) {
        .notif-dropdown {
            width: 280px;
            right: -60px; /* Shifts left to stay on screen */
        }
    }

    /* LANDING PAGE SECTIONS */
    #landingPage { width: 100%; overflow-x: hidden; }
    
    /* Hero Section */
    .hero-section { height: 75vh; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    .hero-bg { position: absolute; inset: 0; z-index: 1; opacity: 0.3; background-size: cover; background-position: center; transition: opacity 1s ease; }
    .hero-content { position: relative; z-index: 2; text-align: center; max-width: 800px; padding: 20px; }
    .hero-title { font-size: 3rem; font-weight: 800; text-transform: uppercase; margin-bottom: 5px; text-shadow: 0 5px 15px rgba(0,0,0,0.8); }
    .hero-subtitle{
      font-size: 1.05rem;
      color: #b7c3ff;
      margin-top: -20px;
      margin-bottom: 14px;
      text-shadow: 0 2px 5px rgba(0,0,0,0.8);
    }

    /* --- HERO: Dynamic Media Layer + Strip --- */
    .hero-media-layer{
      position:absolute;
      inset:0;
      z-index:0; /* behind fallback + overlay + content */
      overflow:hidden;
    }
    
    .hero-bg.hero-bg-fallback{
      z-index:1; /* fallback sits above media until media is ready */
    }
    
    .hero-overlay{
      position:absolute;
      inset:0;
      z-index:2;
      background:
        radial-gradient(circle at 20% 20%, rgba(33,150,243,0.25), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(255,216,105,0.18), transparent 60%),
        linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0.75));
      pointer-events:none;
    }
    
    /* each media swap lives in a single absolute wrapper */
    .hero-media-item{
      position:absolute;
      inset:0;
      opacity:1;
      transform:scale(1);
      transition: opacity 700ms ease, transform 700ms ease;
    }
    
    .hero-media-item.out{
      opacity:0;
      transform:scale(1.03);
    }
    
    /* Make hero media behave like a background */
    .hero-media-layer .thumb-media-img,
    .hero-media-layer .thumb-media-video{
      width:100%;
      height:100%;
      object-fit:cover;         /* key difference vs grid thumbs */
      background:#000;
    }
    
    .hero-media-layer .thumb-media-html{
      width:100%;
      height:100%;
      background:#000;
    }
    
    /* Hero media should not steal clicks */
    .hero-media-layer,
    .hero-media-layer *{
      pointer-events:none !important;
    }
    
    .hero-byline{
  margin-top: 10px;
  font-size: 0.95rem;
  color:#b7c3ff;
  font-family: monospace;
  text-shadow: 0 2px 5px rgba(0,0,0,0.8);
    }
    
    .hero-byline a{
      color: var(--accent);
      text-decoration: none;
      font-weight: 800;
    }
    
    .hero-byline a:hover{
      text-decoration: underline;
    }

    
    /* Asset strip */
    .hero-asset-strip{
      margin-top: 22px;
      display:flex;
      gap: 14px;
      justify-content:center;
      flex-wrap:wrap;
    }
    
    .hero-card{
      width: 190px;
      border-radius: 16px;
      overflow:hidden;
      text-decoration:none;
      color: var(--text);
      background: rgba(5,10,24,0.75);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      transform: translateY(0);
      transition: 200ms ease;
      cursor: pointer;
    }
    
    .hero-card:hover{
      transform: translateY(-3px);
      border-color: rgba(33,150,243,0.55);
    }
    
    .hero-card.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255,216,105,0.35), 0 12px 40px rgba(0,0,0,0.45);
    }
    
    .hero-card-media{
      height: 110px;
      background:#000;
      overflow:hidden;
    }
    
    /* Ensure thumb wrappers fill the hero card media area */
    .hero-card-media .html-thumb-wrapper{
      width:100%;
      height:100%;
    }
    .hero-card-media .html-thumb-wrapper iframe{
      height:400% !important;
    }
    
    /* Card media sizing */
    .hero-card-media .thumb-media-img,
    .hero-card-media .thumb-media-video{
      width:100%;
      height:100%;
      object-fit:contain;
    }
    
    .hero-card-info{
      padding: 10px 12px 12px;
    }
    
    .hero-card-title{
      font-weight: 800;
      font-size: 0.95rem;
      line-height: 1.15;
      color:#fff;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    
    .hero-card-creator{
      font-size: 0.8rem;
      color:#b7c3ff;
      font-family: monospace;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    
    /* Mobile: horizontal scroll strip */
    @media (max-width: 700px){
      .hero-section{ height: 70vh; }
      .hero-asset-strip{
        flex-wrap:nowrap;
        overflow-x:auto;
        justify-content:flex-start;
        padding: 0 10px;
        -webkit-overflow-scrolling: touch;
      }
      .hero-card{ flex: 0 0 auto; }
    }

    
    /* Sections */
    .section-container { padding: 60px 20px; max-width: 1200px; margin: 0 auto; }
    .section-title { font-size: 2rem; margin-bottom: 30px; border-left: 4px solid var(--primary); padding-left: 15px; text-transform: uppercase; letter-spacing: 1px; }
    
    .drops-grid, .new-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 25px; }
    .preview-card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; overflow: hidden; transition: transform 0.2s; }
    .preview-card:hover { transform: translateY(-5px); border-color: var(--primary); }
    .preview-img { width: 100%; height: 200px; object-fit: cover; }
    .preview-info { padding: 15px; }
    .preview-title { font-weight: bold; margin-bottom: 5px; color: #fff; }
    .preview-creator { color: var(--primary); font-size: 0.9rem; text-decoration: none; }

    /* DASHBOARD */
    .app-container { max-width: 1000px; width: 100%; margin: 40px auto; padding: 0 20px; }
    .glass-panel { background: var(--card-bg); border-radius: 18px; border: 1px solid var(--border); padding: 2.5rem; margin-bottom: 2rem; position: relative; }
    
    .pfp-wrapper { width: 150px; height: 150px; margin: 0 auto 20px; border-radius: 50%; border: 4px solid #050810; background: #1a202c; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    .pfp-img { width: 100%; height: 100%; object-fit: cover; }
    .profile-name { font-size: 2.5rem; font-weight: 800; color: #fff; text-align: center; }
    .profile-bio { text-align: center; color: #b7c3ff; margin-bottom: 20px; }
    .profile-location { text-align: center; color: #b7c3ff; margin-bottom: 20px; }
    
/* --- DASHBOARD HEADER LAYOUT (2-Row) --- */
.dash-header-container {
    display: flex;
    flex-direction: column;
    /* FIX: Reduced gap to close the space */
    gap: 8px; 
    border-bottom: 1px solid rgba(255,255,255,0.1);
    /* FIX: Reduced padding */
    padding-bottom: 10px; 
    margin-bottom: 20px;
    width: 100%;
}

.dash-row-top, 
.dash-row-bottom {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    flex-wrap: wrap; /* Wraps gracefully on mobile */
    gap: 10px;
    /* FIX: Enforce min-height to prevent layout shift during tab swap */
    min-height: 44px; 
}

/* Main Tabs Styling */
.dashboard-tabs { display: flex; align-items: center; gap: 20px; }


/* Wallet Categories (Row 2 Left) */
.wallet-cat-tabs { 
    display: flex; 
    gap: 8px; 
    width: auto; 
    overflow-x: auto; 
    padding-bottom: 5px;
    /* FIX: Force horizontal scroll on all screens, wrap disabled */
    flex-wrap: nowrap !important; 
    white-space: nowrap;
    /* Hide scrollbar for cleaner look */
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none; 
}
.wallet-cat-tabs::-webkit-scrollbar { display: none; }
.cat-tab { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); color: #8899ac; padding: 6px 14px; border-radius: 99px; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s; } 
.cat-tab:hover { color: #fff; border-color: rgba(255,255,255,0.3); } 
.cat-tab.active { background: rgba(33, 150, 243, 0.15); color: var(--primary); border-color: var(--primary); }

/* Action Buttons (Row 2 Right) */
.delete-header-group { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    margin-left: auto; 
    position: relative; /* For dropdown positioning */
}

/* Mobile Hamburger & Menu */
.mobile-menu-btn { display: none; background: transparent; border: 1px solid var(--border); color: #fff; padding: 8px 12px; border-radius: 8px; cursor: pointer; }
.mobile-actions-dropdown { display: flex; align-items: center; gap: 10px; }

/* --- MOBILE ADJUSTMENTS --- */
@media (max-width: 768px) {
    /* 1. Tighten the main container gaps on mobile */
    .dash-header-container {
        gap: 5px !important;
        padding-bottom: 5px !important;
    }

    .dash-row-top, 
    .dash-row-bottom {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px; /* Reduce gap between elements */
    }
    
    .header-right-group {
        margin-left: 0;
        width: 100%;
        flex-direction: column; 
        align-items: flex-start;
        /* FIX: Remove top margin (Parent gap handles it) */
        margin-top: 0; 
        gap: 5px;
    }
    
/* Ensure the dropdown container fills the width */
    .wallet-dropdowns-group {
        width: 100%;
        display: flex;
        gap: 10px;
        margin: 0; /* Ensure no external spacing */
    }

    /* Allow tabs to scroll horizontally taking up available space */
/* Allow tabs to scroll horizontally taking up available space */
.wallet-cat-tabs { 
        flex: 1; 
        width: auto; 
        min-width: 0; 
        /* FIX: Force single line */
        flex-wrap: nowrap; 
        overflow-x: auto; 
        padding-bottom: 0; 
        margin-right: 10px;
    }

    /* Show Hamburger, Hide Buttons initially */
    .mobile-menu-btn { display: block; }
    .mobile-actions-dropdown {
        display: none;
        position: absolute;
        top: 100%; right: 0;
        background: #1a202c;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        flex-direction: column;
        z-index: 2000;
        width: 180px;
        margin-top: 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    /* Toggle class to show menu */
    .mobile-actions-dropdown.show { display: flex; }
    
    /* Adjust buttons inside dropdown */
    .mobile-actions-dropdown button, 
    .mobile-actions-dropdown .state-btn { width: 100%; justify-content: center; }
}


/* --- FIX: THUMBNAIL ANIMATION (With Safety) --- */
/* 1. Base State: Hidden, waiting for load */
/* 1. Define the Fade In Animation */
@keyframes fadeInImage {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* 2. Apply it to the image. Force opacity 1 by default so it's never black. */
.col-thumb img.thumb-media-img {
    opacity: 1; 
    animation: fadeInImage 0.5s ease-in-out; /* The ease you wanted */
}

/* 2. Loaded State: Triggered by JS adding .loaded class */
.col-thumb img.thumb-media-img.loaded {
    opacity: 1;
}

/* 3. SAFETY NET: If user hovers, force visible just in case JS failed to add class */
.collection-card:hover .col-thumb img.thumb-media-img {
    opacity: 1 !important;
}

/* --- FIX: WALLET CATEGORY TABS --- */
/* Ensure they don't get squashed */
.wallet-cat-tabs {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

/* --- WALLET & DROPDOWN STYLES --- */
.wallet-controls { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    margin-left: 15px; 
    border-left: 1px solid rgba(255,255,255,0.1); 
    padding-left: 15px;
    flex-wrap: wrap;
    min-width: 0;
}

/* FIX: Mobile adjustment for Wallet Controls */
@media (max-width: 768px) {
    .wallet-controls {
        width: 100%;
        margin-left: 0;
        padding-left: 0;
        border-left: none;
        margin-top: 15px;
        
        /* NEW: Wrap items so we can stack them */
        flex-wrap: wrap; 
        justify-content: flex-start; /* Align left */
    }

    /* 2. Make the 'Jump' dropdown flexible so it fits remaining space */
#walletCollectionSelect {
        flex: 1;       
        min-width: 0;  
        /* FIX: Changed from 0 to auto so text is visible on the new row */
        width: auto;      
    }

    /* Ensure the page size dropdown stays small */
    #walletPageSizeSelect {
        flex: 0 0 auto;
    }
}

/* Match the All Assets Gridview Dropdown Theme */
.wallet-select { background: rgba(5,10,24,0.9); border: 1px solid rgba(255,255,255,0.2); color: #e4e8ff; border-radius: 999px; padding: 4px 10px; font-size: 0.8rem; outline: none; cursor: pointer; }
.wallet-select:hover { border-color: var(--primary); }
.wallet-select option { background: #050810; color: #ffd869; }
.wallet-stats-text { font-size: 0.8rem; color: var(--accent); font-family: monospace; white-space: nowrap; margin-right: 10px; }

/* Wallet Card Interaction Logic */
.collection-card.wallet-card { 
    cursor: default; 
}

/* 2. Top Section (Media) - Click to Preview */
.wallet-card .col-thumb {
    cursor: default; /* Arrow cursor for interaction */
    pointer-events: auto;
}

/* Ensure the bottom info part is the click target */
.collection-card.wallet-card .col-info {
    cursor: pointer; /* Hand cursor for navigation */
}

.collection-card.wallet-card .col-info:hover { 
    background: rgba(255,255,255,0.1); 
}

/* Fade In Animation */
/* Hover Interaction */ 
.collection-card.has-preview .col-thumb { cursor: pointer; } 
.collection-card.has-preview:hover { border-color: var(--primary); }

/* Grayed out state for tools */
.tool-disabled { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }

/* Syncing Animation (Dots) */
.syncing-dots::after {
  content: ' .';
  animation: dots 1.5s steps(5, end) infinite;
}
@keyframes dots {
  0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
  40% { color: #fff; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
  60% { text-shadow: .25em 0 0 #fff, .5em 0 0 rgba(0,0,0,0);}
  80%, 100% { text-shadow: .25em 0 0 #fff, .5em 0 0 #fff;}
}
.sync-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; border-radius: 12px; }

/* Progress Bar */
.sync-progress-track {
    width: 300px;
    height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 99px;
    margin: 15px auto;
    overflow: hidden;
}
.sync-progress-bar {
    height: 100%;
    width: 0%;
    background: var(--primary);
    transition: width 0.5s ease;
    box-shadow: 0 0 10px var(--primary);
}
    
/* Add to your <style> block */
.dashboard-tabs {
    display: flex;
    align-items: center;
    gap: 20px;
}
.dash-tab {
    background: transparent;
    border: none;
    color: #8899ac;
    font-size: 1.2rem; /* Matches your h3 size */
    font-weight: bold;
    cursor: pointer;
    padding: 0;
    transition: color 0.2s;
}
.dash-tab.active {
    color: var(--primary);
    border-bottom: 2px solid var(--primary);
}
.dash-tab:hover {
    color: #fff;
}
    .creator-tools { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); }
    .tool-btn { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); color: #e4e8ff; padding: 10px 20px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
    .tool-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    .tool-btn.primary { background: linear-gradient(135deg, var(--primary), #21CBF3); color: #000; border: none; font-weight: bold; }
/* --- CORRECTED THUMBNAIL CSS --- */
/* Ensure base container is relative */
.col-thumb {
    position: relative;
    height: 200px;
    background: #000;
    overflow: hidden;
    display: block;
    width: 100%;
}

/* 1. Underlayers (HTML/Video) */
.col-thumb .thumb-media-html,
.col-thumb .thumb-media-video {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 1;
    pointer-events: auto;
}

/* 2. The Cover Image sits on top at z-index 10 */
.col-thumb .thumb-media-img {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    object-fit: contain;
    background: #000;
    z-index: 10;
    opacity: 0; /* Start hidden */
    transition: opacity 0.5s ease; /* The Ease you wanted */
}

/* JS adds .loaded, or hover triggers it if configured */
.col-thumb img.thumb-media-img.loaded {
    opacity: 1;
}

/* Cover Overlay */
.col-thumb .thumb-cover {
    opacity: 0 !important;
    transition: opacity 0.5s ease;
}

/* Reveal under-preview by fading the cover layer */
.collection-card.has-preview:hover .thumb-cover,
.collection-card.has-preview:hover .thumb-media-img {
opacity: 0 !important;
transition: opacity 0.5s ease;
pointer-events: none;
}

/* FIX: Added .col-thumb img to selector to ensure it overrides the base animation */
.collection-card.has-preview:hover .col-thumb .thumb-cover,
.collection-card.has-preview:hover .col-thumb img.thumb-media-img {
    opacity: 0 !important;
    transition: opacity 0.5s ease;
    pointer-events: none; /* Allows mouse to click the iframe/video behind */
}

/* Ensure interactive media underneath is clickable */
.collection-card.has-preview:hover .col-thumb .thumb-media-html iframe,
.collection-card.has-preview:hover .col-thumb .thumb-media-video {
    pointer-events: auto;
}

.collection-card:hover { transform: translateY(-5px); border-color: var(--primary); }
.col-info { padding: 15px;cursor: pointer;transition: background 0.2s;} 
.col-info:hover { background: rgba(255,255,255,0.05); }
.col-title { 
    font-weight: bold; 
    font-size: 1.1rem; 
    margin-bottom: 5px;
    /* Ensure text doesn't break layout */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.col-meta { font-size: 0.8rem; color: #8899ac; } 
.grid-item { background: rgba(255,255,255,0.05); border-radius: 12px; height: 250px; display: flex; align-items: center; justify-content: center; border: 1px dashed rgba(255,255,255,0.2); color: rgba(255,255,255,0.4); text-align: center; padding: 20px; } 
    
/* --- FIXED GRID & CARD LAYOUT --- */
.collection-grid {
    display: grid;
    /* Mobile: Request for 2 columns */
    grid-template-columns: repeat(2, 1fr); 
    gap: 15px; 
    margin-top: 20px;
}

/* Desktop: Use Reference Code logic (Auto-fill) to prevent thin cards */
/* This allows cards to be wider (min 240px) and fill the available space */
@media (min-width: 900px) {
    .collection-grid {
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 25px;
    }
}
.collection-card {
    background: rgba(255,255,255,0.05);
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.1);
    transition: transform 0.2s;
    position: relative;
    display: flex;       /* Ensures flex layout for contents */
    flex-direction: column; 
}

    
    /* MODALS */
/* --- FIXED MODAL LOGIC --- */

/* 1. Base Overlay - Force interaction ON when visible */
.modal-overlay { 
    position: fixed; 
    inset: 0; 
    background: rgba(0,0,0,0.85); 
    z-index: 6000; /* Ensure it is above the sticky header and studio */
    display: none; 
    align-items: center; 
    justify-content: center; 
    backdrop-filter: blur(5px); 
    pointer-events: auto !important; /* CRITICAL: Enables clicks */
}

/* 2. Show state for appDB modals */
.modal-overlay.open { 
    display: flex !important; 
}

/* 3. Modal Box Fixes */
.modal-box { 
    background: #111625; 
    border: 1px solid var(--border); 
    border-radius: 16px; 
    padding: 30px; 
    width: 95%; 
    max-width: 600px; 
    max-height: 90vh; 
    overflow-y: auto; 
    position: relative; 
    pointer-events: auto !important; /* CRITICAL: Enables internal clicks */
    z-index: 6001;
}

/* 4. Close Button Fix - Ensure it sits on top of all modal content */
.modal-close { 
    position: absolute; 
    top: 15px; 
    right: 15px; 
    background: rgba(255,255,255,0.05); 
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff; 
    width: 35px;
    height: 35px;
    border-radius: 50%;
    font-size: 1.2rem; 
    cursor: pointer; 
    z-index: 6010;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: 0.2s;
}
.modal-close:hover { background: rgba(255,255,255,0.2); color: var(--primary); }

/* 5. Override for DashboardRoot background interference */
#dashboardRoot:not(.hidden) ~ .modal-overlay {
    pointer-events: auto;
}
/* Import Tabs */ .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
.tab { background: transparent; color: #888; padding: 8px 16px; border-radius: 8px; border:none; cursor: pointer; transition: 0.2s; }
.tab:hover { color: #fff; }
.tab.active { background: rgba(255,255,255,0.1); color: #fff; font-weight: bold; }
.glass-input { width: 100%; background: rgba(0,0,0,0.4); color: #fff; border: 1px solid rgba(255,255,255,0.1); padding: 12px; border-radius: 12px; margin-bottom: 10px; outline: none; }
.btn-action { width: 100%; padding: 16px; border-radius: 99px; border: none; background: linear-gradient(135deg, #2196F3, #21CBF3); color: #050814; font-weight: bold; cursor: pointer; }
.custom-select { width: 100%; padding: 12px; background: #050810; color: #ffd869; border: 1px solid rgba(120, 141, 255, 0.4); border-radius: 8px; margin-bottom: 15px; }
    
    /* --- Base definitions (Applies to both Dashboard AND Asset Browser) --- */
    .thumb-media-img,
.thumb-media-html {
  width: 100%;
  height: 100%;
  border: 0;
  display: block; /* Default to normal block flow */
}

.thumb-media-img {
  object-fit: contain;
}

.thumb-media-video{
  width:100%;
  height:100%;
  object-fit:contain; /* or contain, whichever matches your card style */
  display:block;
}
    .thumb-media-video { pointer-events: auto; }


/* Thumbnails should not be interactive media players */
.col-thumb .thumb-media-video,
.asset-thumb-wrap .thumb-media-video {
  pointer-events: auto;
}

.col-thumb .thumb-media-img,
.col-thumb .thumb-media-html,
.asset-thumb-wrap .thumb-media-img,
.asset-thumb-wrap .thumb-media-html {
  pointer-events: auto;
}


    /* Thumbnails */
.col-thumb {
  position: relative;
  height: 200px;
  background: #000;
  overflow: hidden;
  display: block;
}
.col-thumb .thumb-media-html {
  position: absolute; 
  top: 0;
  left: 0;
  z-index: 10;
  background: #000;
}

    
    /* Helper classes for JS */
/* --- ASSET BROWSER (My Collections -> All Assets View) --- */
/* --- STUDIO PREVIEW HEADER FIX --- */
/* --- NFT STUDIO ASSET STYLES --- */
.asset-card.selected {
    border: 1px solid var(--primary);
    background: rgba(33, 150, 243, 0.1);
    box-shadow: 0 0 15px rgba(33, 150, 243, 0.2);
}

/* Split Media Container */
.asset-media-split {
    display: flex;
    flex-direction: column;
    height: 240px; /* Taller to accommodate two zones */
    width: 100%;
}

.media-zone {
    flex: 1;
    position: relative;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.2);
    transition: background 0.2s;
}

.media-zone:last-child {
    border-bottom: none;
}

.media-zone:hover {
    background: rgba(255,255,255,0.05);
}

.media-zone.drag-active {
    background: rgba(76, 175, 80, 0.15) !important;
    border: 1px dashed var(--success);
}

.zone-label {
    position: absolute;
    top: 5px;
    left: 5px;
    font-size: 0.65rem;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 4px;
    color: rgba(255,255,255,0.7);
    pointer-events: none;
    z-index: 10;
}

.zone-empty-text {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.3);
    text-align: center;
    pointer-events: none;
}

/* Force single row layout: Title | Filter | Show */
#assetPreviewCard .browser-header {
    display: flex;
    flex-wrap: nowrap; /* Prevent wrapping */
    align-items: center;
    gap: 20px; 
    padding-right: 10px;
}

#assetPreviewCard .browser-header-left {
    flex: 0 0 auto; /* Don't shrink/grow */
    margin-right: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

#assetPreviewCard .browser-header-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1; /* Take up remaining space */
    justify-content: flex-start; /* Align left next to title */
}

/* Make dropdowns slightly more compact in studio */
#assetPreviewCard .browser-select {
    max-width: 200px;
    padding: 6px 12px;
}

#assetBrowserModal .modal-box { 
    max-width: 1000px; 
    height: 85vh; 
    display: flex; 
    flex-direction: column;
    
    /* MATCH CREATOR PAGE DIMENSIONS EXACTLY */
    width: 95%; 
    padding: 20px; 
    position: relative; /* Crucial for absolute close button */
}
    
.detail-meta-row { 
    display: flex; 
    justify-content: space-between; 
    border-bottom: 1px solid rgba(255,255,255,0.1); 
    padding: 8px 0; 
    font-size: 0.9rem; 
    text-align: left;
}
    
.browser-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    
    /* MATCH CREATOR PAGE HEADER LAYOUT */
    flex-wrap: wrap; 
    gap: 10px; 
    padding-right: 40px; /* Reserves space for the X button */
}

.browser-header-left h2 { 
        margin: 0; 
        font-size: 1.5rem; 
        display: flex; 
        align-items: center; /* FIXED: Centers badge vertically with text */
    }

.asset-count-label {
  font-size: 0.8rem;
  color: #8899ac;
}

.browser-header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.browser-label {
  font-size: 0.8rem;
  color: #8899ac;
}

.browser-select {
  background: rgba(5,10,24,0.9);
  border: 1px solid rgba(255,255,255,0.2);
  color: #e4e8ff;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.8rem;
  outline: none;
  max-width: 150px;
  text-overflow: ellipsis;
}

/* Grid becomes the scroll container for lazy loading */
    .asset-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; overflow-y: auto; flex: 1; padding-right: 5px; align-content: flex-start;}
.asset-card {
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
  border: 1px solid transparent;

  /* NEW let the card grow to fit its content */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  overflow: visible; /* no clipping of traits at the bottom */
}

    .asset-card:hover { border-color: var(--accent); background: rgba(255,255,255,0.08); }
    .asset-thumb { height: 150px; width: 100%; object-fit: contain; }
.asset-thumb-wrap {
  position: relative; /* Safety: ensures contents stay inside */
  height: 150px;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.asset-thumb-wrap .thumb-media-html {
  position: static; 
}


.asset-name {
  padding: 10px;
  font-size: 1rem;
  font-weight: 600;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.asset-traits{
  padding: 8px 10px 10px;
  margin: 0 10px 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  text-align: left;
}

.asset-traits .detail-meta-row{
  padding: 4px 0;
  font-size: 0.78rem;
  border-bottom: 1px solid rgba(255,255,255,0.07);
}
.asset-traits .detail-meta-row:last-child{ border-bottom: 0; }

.asset-traits .trait-k{ color:#8899ac; }
.asset-traits .trait-v{
  font-family: monospace;
  color:#fff;
  text-align: right;
  margin-left: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}



    #assetDetailModal .modal-box { text-align: center; max-width: 800px; }
    .detail-view { display: flex; flex-direction: column; align-items: center; gap: 20px; }
    .detail-media { max-width: 100%; max-height: 50vh; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    .detail-meta { width: 100%; text-align: left; background: rgba(255,255,255,0.03); padding: 20px; border-radius: 12px; }
    .meta-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.05); padding: 8px 0; }
    .meta-key { color: #8899ac; } .meta-val { color: #fff; font-family: monospace; }
     
    /* --- SINGLE ASSET: Title row + Fullscreen --- */
    .detail-title-row{
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center; /* title stays centered */
      gap: 10px;
      margin-bottom: 15px;
    }
    
    #btnMediaFs{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      line-height: 1;
    }
    #btnMediaFs:hover{ border-color: var(--accent); }
    
    /* Fullscreen media overlay */
    #mediaFsOverlay{
      position: fixed;
      inset: 0;
      display: none;
      z-index: 9500;
      background: rgba(0,0,0,0.95);
    }
    #mediaFsOverlay.show{ display: block; }
    
    #mediaFsClose{
      position: absolute;
      top: 14px;
      right: 16px;
      width: 44px;
      height: 44px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.22);
      color: #fff;
      font-size: 30px;
      cursor: pointer;
      z-index: 9510;
    }
    #mediaFsClose:hover{ border-color: var(--accent); }
    
    #mediaFsHost{
      position: absolute;
      inset: 0;
      padding: 60px 20px 20px; /* space for the close X */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Ensure contain behavior in fullscreen */
    #mediaFsHost .thumb-media-img,
    #mediaFsHost .thumb-media-video{
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }
    
    #mediaFsHost .thumb-media-html{
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* --- SAVE & PUSH BUTTON STYLES --- */
.state-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: #555; /* Start gray/disabled */
    padding: 6px 12px;
    border-radius: 8px;
    cursor: default;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    pointer-events: none; /* Not clickable by default */
}

/* Active State (When changes exist) */
.state-btn.active {
    color: #fff;
    border-color: var(--accent);
    background: rgba(255, 216, 105, 0.1);
    cursor: pointer;
    pointer-events: auto;
    box-shadow: 0 0 5px rgba(255, 216, 105, 0.2);
    /* 2 Minute Flash Animation (120s total, flash happens at end) */
    animation: reminderFlash 120s infinite;
}

.state-btn.active:hover {
    background: var(--accent);
    color: #000;
    transform: translateY(-2px);
}

@keyframes reminderFlash {
    0%, 98% { box-shadow: 0 0 5px rgba(255, 216, 105, 0.2); transform: scale(1); }
    99% { box-shadow: 0 0 20px var(--accent); transform: scale(1.1); background: var(--accent); color: #000; }
    100% { box-shadow: 0 0 5px rgba(255, 216, 105, 0.2); transform: scale(1); }
}

/* Modal Option Buttons */
.push-opt-btn {
    width: 100%; padding: 15px; margin-bottom: 10px;
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
    color: #8899ac; border-radius: 12px; cursor: pointer; text-align: left;
    display: flex; justify-content: space-between; align-items: center;
}
.push-opt-btn.highlight { border-color: var(--primary); color: #fff; background: rgba(33, 150, 243, 0.1); }
.push-opt-btn:hover { background: rgba(255,255,255,0.1); }


    /* DELETE UI STYLES */
    /* NEW: Disable buttons when My Wallet tab is active */
    body:has(#tabWallet.active) #btnToggleCombine, 
    body:has(#tabWallet.active) #btnToggleDelete {
        pointer-events: none;
        opacity: 0.3;
        filter: grayscale(100%);
    }

    .delete-header-group { display: flex; align-items: center; gap: 10px; }
    
.delete-header-group { display: flex; align-items: center; gap: 10px; }

/* The Red Trash Icon */
#btnToggleDelete { cursor: pointer; color: #8899ac; font-size: 1.1rem; transition: color 0.2s; padding: 5px; }
#btnToggleDelete:hover { color: #ff6b6b; }
#btnToggleDelete.active { color: #ff6b6b; text-shadow: 0 0 10px rgba(255, 107, 107, 0.5); }

/* The "Delete Selected" Button */
#btnDeleteConfirm {
    background: #ff6b6b; color: white; border: none; padding: 6px 16px;
    border-radius: 99px; font-weight: bold; font-size: 0.8rem; cursor: pointer;
    display: none; /* Hidden by default */
    animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.fade-out {
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.5s ease;
    pointer-events: none;
}

#btnCombineConfirm {
    background: var(--primary); color: #000; border: none; padding: 6px 16px;
    border-radius: 99px; font-weight: bold; font-size: 0.8rem; cursor: pointer;
    display: none; animation: popIn 0.2s; margin-right:5px;
}

/* The Selection Counter Text */
#deleteCountText { color: #ff6b6b; font-weight: bold; font-size: 0.9rem; display: none; margin-right: 5px; }

/* The Checkbox on the cards */
.del-check-input {
    position: absolute; top: 10px; right: 10px; z-index: 100;
    width: 22px; height: 22px; cursor: pointer;
    accent-color: #ff6b6b; /* Makes the checkbox red */
    display: none; /* Hidden normally */
    transform: scale(1.2);
}

/* When parent has class .delete-mode, show checkboxes */
.collection-grid.delete-mode .del-check-input { display: block; }
.collection-grid.delete-mode .collection-card { border-color: rgba(255, 107, 107, 0.3); }

/* Animation for button */
@keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

/* DELETE MODAL SPECIFIC */
.warn-icon { font-size: 3rem; color: #ff6b6b; margin-bottom: 15px; }
.modal-actions { display: flex; gap: 15px; justify-content: center; margin-top: 25px; }

    /* Builder & Tabs */
    .builder-tabs { display: flex; gap: 5px; overflow-x: auto; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .builder-tab { padding: 8px 15px; background: rgba(255,255,255,0.05); border-radius: 8px 8px 0 0; cursor: pointer; white-space: nowrap; color: #888; }
    .builder-tab.active { background: #111625; color: #fff; border-top: 2px solid var(--primary); }
    

/* Verified Badges */
    .verified-badge {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        background-image: url('../fre5hfence/RF5.png?v=2');
        background-size: cover;
        background-position: center;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: 900;
        color: #fff;
        text-shadow: 0 1px 2px #000;
        z-index: 20; /* Ensure it sits on top */
        cursor: default;
        opacity: 1 !important; /* Force visible by default */
    }
    .verified-badge::before { content: 'IDP'; }
    
    /* Colors */
    .verified-badge.green { box-shadow: 0 0 5px 1px #4CAF50; border: 1px solid #4CAF50; }
    .verified-badge.yellow { box-shadow: 0 0 5px 1px #FFC107; border: 1px solid #FFC107; }

    /* Tooltip logic - Hidden by default */
    .verified-badge::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 110%;
        right: 0;
        background: rgba(0,0,0,0.9);
        color: #fff;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 10px;
        white-space: pre; 
        display: none; /* STRICTLY HIDDEN */
        text-align: center;
        border: 1px solid rgba(255,255,255,0.2);
        line-height: 1.2;
        pointer-events: none;
    }
    .verified-badge:hover::after { display: block; }
    

    .browser-header-left .verified-badge {
        position: relative; /* CRITICAL: Anchors the tooltip to the badge */
        display: inline-flex; /* Keeps flex behavior */
        margin-left: 12px; 
        width: 24px; height: 24px; font-size: 8px;
        flex-shrink: 0; /* Prevents badge from squishing */
        bottom: auto; right: auto; /* Reset absolute positioning */
    }
    .browser-header-left .verified-badge::after {
        left: 100%; 
        top: 50%;
        right: auto;
        bottom: auto;
        transform: translateY(-50%); /* vertically center */
        margin-left: 10px;
    }
    .browser-header-left { overflow: visible; }
    
    #toastBox { position: fixed; bottom: 20px; right: 20px; z-index: 5000; }
    .toast { background: #1a202c; color: #fff; padding: 12px 20px; border-radius: 8px; border-left: 4px solid var(--primary); margin-top: 10px; }
    .toast.error { border-left-color: #ff6b6b; }
    
    /* Mobile */
    @media (max-width: 900px) { .header-title, .nav-link { display: none; } .global-search { max-width: 200px; } }
    
    /* --- HTML THUMBNAIL SCALER --- */
.html-thumb-wrapper {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
}

.html-thumb-wrapper iframe {
    /* 1. Force the iframe to render internally at 400% size (high "virtual" resolution) */
    width: 400% !important;
    height: 400% !important;
    
    /* 2. Shrink it back down to 1/4th the size to fit the container */
    transform: scale(0.25);
    transform-origin: top left;
    
    border: 0;
    display: block;
    pointer-events: auto; /* Keeps it interactive */
    background: transparent;
}
/* FIX: Ensure both swapped containers occupy identical vertical space */
#collectionsDropdowns, #walletCategoryBar {
    height: 36px; 
    display: flex;
    align-items: center;
}
/* Ensure the hidden state doesn't collapse the parent height if used incorrectly, 
   though JS toggles display:flex/none, min-height on parent handles the stability. */
   
  
/* --- STUDIO CONTAINER FIX --- */
/* --- Studio Root Fix --- */
#studioRoot {
    position: fixed;
    top: 80px; 
    left: 0;
    width: 100%;
    height: calc(100vh - 80px);
    z-index: 2500; /* Increased to ensure it's above dashboard/nav */
    overflow-y: auto;
    background: radial-gradient(circle at 15% 15%, rgba(90,230,255,.08) 0%, transparent 40%),
                radial-gradient(circle at 85% 85%, rgba(139,92,246,.08) 0%, transparent 40%), var(--bg);
    display: none; 
}

#studioRoot:not(.hidden) {
    display: flex !important;
    flex-direction: column;
    align-items: center;
}

/* Ensure the Builder Header looks like the Body (Visual Adjustment) */
/* Ensure the Builder Header looks like the Body (Visual Adjustment) */
#creatorStudio .cardHeader.builder-header {
    /* REMOVED border-bottom: none; and background: transparent; */
    border-bottom: 1px solid var(--border); /* Restores line separation */
    background: rgba(255, 255, 255, 0.05); /* Applies color separation */
    flex-direction: column;
    padding-bottom: 15px; /* Added some breathing room */
    gap: 10px;
}

/* NEW: Top Left alignment for all cards inside the builder */
#creatorStudio .card .cardHeader h3 {
    text-align: left;
    width: auto;
    padding-left: 0;
}

/* Header Summary Stats Styling */
/* Container for the header row */
.header-info-row {
    position: relative; /* Allows children to be absolutely positioned relative to this bar */
    display: flex;
    align-items: center;
    width: 100%;
    height: 100%; /* Ensures it fills height for alignment */
}

/* Wrapper to force the stats to the DEAD CENTER of the card */
.centered-stats-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%); /* Shifts it back by half its width to perfectly center it */
    display: flex;
    gap: 15px;
    align-items: center;
}

/* Base pill styling (Keep this) */
.stat-pill {
    font-size: 0.75rem;
    padding: 4px 10px;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    color: var(--text-light);
    white-space: nowrap;
    display: flex;
    gap: 5px;
}



.stat-pill b {
    color: var(--primary);
}


/* Ensure inner wrapper behaves and has space for footer */
#studioRoot .content-wrapper {
    width: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding-bottom: 100px; /* Extra space so footer doesn't cover content */
}

/* Studio Footer Bar */
.studio-footer-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(5, 8, 16, 0.95);
    border-top: 1px solid var(--border);
    padding: 15px 30px;
    display: flex;
    justify-content: flex-end;
    gap: 15px;
    z-index: 1000;
    backdrop-filter: blur(10px);
}


/* --- IDP Studio Header Styles --- */
#appRoot h1.app-title {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.15em;
  width: max-content;
  margin: 0 auto 5px auto; /* Reduced bottom margin */
  line-height: 1.1;
}

/* Subtitle styling */
#studioRoot .content-wrapper p {
    color: var(--text-light); 
    font-size: 1rem; 
    margin-top: -35px; 
    margin-bottom: 25px; 
    opacity: 0.9; 
    text-align: center;
}

.app-title-main {
  font-size: 2.5rem;
  background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  font-weight: 800;
  text-transform: uppercase;
}

.app-title-beta {
  font-size: 0.35em;
  letter-spacing: 0.3em;
  color: var(--primary);
  font-weight: 600;
  margin-right: 2px;
}

/* Larger/Wider Builder Header */
.builder-header h3 {
    font-size: 1.5rem !important; /* Larger */
    letter-spacing: 3px !important; /* Wider */
    font-weight: 900;
}

/* Reuse Studio Classes (Ensuring no conflict) */
   /* LAYOUT */
    .content-wrapper { width: 100%; display: flex; flex-direction: column; align-items: center; padding: 30px 20px; gap: 25px; max-width: 900px; }
    .banner-area { width: 100%; height: 180px; background: rgba(255,255,255,0.02); border: 1px dashed var(--border); border-radius: 16px; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
    .banner-img { width: 100%; height: 100%; object-fit: cover; position: absolute; top:0; left:0; z-index: 1; }
    .banner-btn { z-index: 2; background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); padding: 8px 16px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); color: #fff; cursor: pointer; opacity: 0; transition:0.2s; }
    .banner-area:hover .banner-btn { opacity: 1; }
    
    .thumb-area{
  width: 140px;
  height: 140px;
  border-radius: 12px;
  position: relative;
  overflow: hidden;
  border: 1px dashed var(--border);
  background: rgba(255,255,255,0.02);
  display: flex;
  align-items: center;
  justify-content: center;
}
.thumb-area.drag-active{ border-color: var(--success) !important; background: rgba(76,175,80,0.10) !important; }
.thumb-btn{
  position: absolute;
  inset: auto 8px 8px auto;
  z-index: 3;
  opacity: 0;
  transition: 0.2s;
  background: rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.2);
  color: #fff;
  padding: 6px 10px;
  border-radius: 12px;
  font-size: 0.8rem;
}
.thumb-area:hover .thumb-btn{ opacity: 1; }

.mint-wait-overlay{
  position:absolute; inset:0;
  background: rgba(0,0,0,0.55);
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  gap:10px;
  z-index: 4;
}
.mint-spinner{
  width: 26px; height: 26px;
  border-radius: 50%;
  border: 3px solid rgba(255,255,255,0.25);
  border-top-color: rgba(90,230,255,0.95);
  animation: spin 0.9s linear infinite;
}
@keyframes spin{ to{ transform: rotate(360deg); } }
.mint-wait-text{ font-size:0.85rem; color: rgba(233,236,255,0.9); text-align:center; padding: 0 10px; }

    /* CARDS */
    .card { width: 100%; background: var(--card-bg); border: 1px solid var(--border); border-radius: 20px; overflow: hidden; box-shadow: var(--shadow); margin-bottom: 20px; }
    .cardHeader { padding: 18px 24px; border-bottom: 1px solid rgba(120,140,255,0.1); display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.02); }
.cardHeader h3 { 
    color: var(--primary); 
    font-size: 1.1rem; 
    letter-spacing: 0.5px; 
    text-transform: uppercase; 
    width: 100%;           
    text-align: center;   
}
    .cardBody { padding: 24px; display: flex; flex-direction: column; gap: 20px; }

.sectionBody {
  display: none;
}

.section.open .sectionBody {
  display: block;
}

/* --- ASSET GRID ITEM UPDATES --- */

/* 1. Increase Touch Targets / Height for Drag Zones */
.thumb-area {
    width: 100%;       /* Fill column width */
    height: 160px;     /* Increased height for easier dragging */
    min-height: 160px; /* Force minimum */
    cursor: pointer;   /* Clearly indicates interaction */
}

/* Ensure image covers the taller area */
.thumb-area img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 2. Metadata Legibility (Stacked View) */
.asset-meta-row {
    display: flex;
    flex-direction: column; /* Stack Label on top of Value */
    gap: 2px;
    margin-bottom: 8px;     /* Space between properties */
    align-items: flex-start;
}

.asset-meta-label {
    font-size: 0.75rem;
    color: var(--text-light);
    text-transform: uppercase;
    font-weight: 700;
    opacity: 0.8;
}

.asset-meta-val {
    font-size: 0.9rem;
    color: #fff;
    font-weight: 400;
    word-break: break-word; /* Prevent long text overflow */
}

/* 3. Mobile Click/Touch Interaction Fix */
/* This ensures the button inside the thumbnail is easier to hit on touch */
.thumb-btn {
    padding: 10px 14px; /* Larger hit area */
    opacity: 1;         /* Always visible on mobile if needed, or rely on hover for desktop */
}

/* On mobile, ensure hover states are active on touch/focus */
@media (hover: none) {
    .banner-btn, .thumb-btn {
        opacity: 1 !important;
        background: rgba(0,0,0,0.8);
    }
}

    /* FORM */
    .row { display: flex; gap: 15px; width: 100%; align-items: flex-start; }
    .col { flex: 1; display: flex; flex-direction: column; gap: 8px; }
    .col-small { flex: 0 0 140px; }
    label { font-size: 0.85rem; color: var(--text-light); font-weight: 600; margin-left: 4px; display:flex; justify-content:space-between; }
input, textarea, select { 
    width: 100%; 
    background: rgba(0,0,0,0.3); 
    border: 1px solid rgba(120,140,255,0.15); 
    border-radius: 10px; 
    padding: 14px;         /* Increased from 12px for fingers */
    min-height: 48px;      /* Standard mobile touch target height */
    color: #fff; 
    outline: none; 
    transition: 0.2s; 
    font-size: 1rem;       /* Increased from 0.95rem */
}
    input:focus, textarea:focus { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(90,230,255,0.1); }
    input[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* TABS & BUTTONS */
.tabs-nav { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    margin-bottom: 15px; 
    border-bottom: 1px solid var(--border); 
    padding-bottom: 10px;
    overflow-x: auto;      /* Allows scrolling on mobile */
    white-space: nowrap;   /* Keeps tabs in a line */
    scrollbar-width: none; /* Firefox hide scrollbar */
}
.tabs-nav::-webkit-scrollbar { display: none; } /* Chrome hide scrollbar */
/* Added flex-shrink: 0 to force horizontal scrolling instead of squishing */
/* Added flex-shrink: 0 to force horizontal scrolling */
.tab-btn { background: transparent; border: none; color: var(--text-light); padding: 8px 16px; cursor: pointer; border-radius: 8px; flex-shrink: 0; }
    .tab-btn.active { color: var(--primary); background: rgba(90,230,255,0.1); font-weight: bold; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    button { cursor: pointer; padding: 10px 20px; border-radius: 10px; border: 1px solid rgba(90,230,255,0.3); background: linear-gradient(135deg, rgba(90,230,255,0.1), rgba(26,169,192,0.1)); color: var(--primary); font-weight: 600; transition: 0.2s; }
    button:hover { background: rgba(90,230,255,0.2); }
    button.secondary { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.1); color: var(--text-light); }
    button.icon-btn { padding: 6px 10px; font-size: 0.9rem; }
    
    /* Metadata & Code Action Buttons */
    #tab-meta .row .secondary, 
    #tab-code .row .secondary {
        min-width: 120px;      /* Force wider buttons */
        height: 44px;          /* Taller buttons */
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
    }

     /* Fix for the Import Label button to match actual buttons */
    label.secondary.icon-btn {
        box-sizing: border-box; 
        display: inline-flex !important;
        
        /* Add base button visuals */
        cursor: pointer;
        border-radius: 10px;
        font-weight: 600;
        transition: 0.2s;
        
        /* Match 'Secondary' skin */
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        color: var(--text-light);
        
        /* Match 'Icon-Btn' sizing */
        padding: 6px 10px;
        font-size: 0.9rem;
    }
    
    /* Ensure it highlights on hover like real buttons */
    label.secondary.icon-btn:hover {
        background: rgba(90,230,255,0.2);
        color: var(--primary);
    }
    /* Content Tools Dropdown Styling */
.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    background: #111;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.5);
    z-index: 10;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 5px;
    left: 0; /* Left aligned */
}


.dropdown-content.show {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.dropdown-content .secondary.icon-btn {
    width: 100%;
    justify-content: flex-start !important; /* Left aligned text */
    min-width: unset !important;
}
    
    .prop-row { background: rgba(255,255,255,0.03); padding: 10px; border-radius: 10px; display: grid; grid-template-columns: 24px 1fr 1fr 24px; gap: 10px; align-items: center; margin-bottom: 8px; }
    .check-wrap { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9rem; color: var(--text-light); }
    .check-wrap input { width: 16px; height: 16px; accent-color: var(--primary); }

    /* UTILS */
    .log-box { height: 120px; overflow-y: auto; background: #000; border: 1px solid rgba(255,255,255,0.1); padding: 10px; font-family: monospace; font-size: 0.8rem; color: var(--success); border-radius: 8px; }
    .hidden { display: none !important; }
    
    /* --- DASHROOT WIDTH/OVERFLOW FIX (after adding #studioRoot) --- */
#dashboardRoot{
  width: 100%;
  overflow-x: hidden;
}
    
    .hint{
  margin-top: 10px;
  font-size: 0.85rem;
  color: var(--text-light);
  opacity: 0.9;
}
.spinner{
  width:22px;height:22px;
  border:3px solid rgba(255,255,255,0.25);
  border-top-color: rgba(90,230,255,0.9);
  border-radius:50%;
  animation: spin 0.9s linear infinite;
}
@keyframes spin{ to{ transform: rotate(360deg); } }
    .drag-active { border-color: var(--success) !important; background: rgba(76, 175, 80, 0.1) !important; }

    /* MODAL */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 2000; display: none; justify-content: center; align-items: center; }
    .modal-overlay.open { display: flex; }
    .modal-box { width: min(600px, 90%); background: #151a28; border: 1px solid var(--border); border-radius: 16px; padding: 25px; box-shadow: 0 20px 60px #000; display:flex; flex-direction:column; gap:15px; }
    .json-editor { width:100%; height:300px; background:#000; color:#0f0; font-family:monospace; padding:10px; border:none; resize:vertical; }
    
        footer { margin-top: 80px; padding: 30px; text-align: center; border-top: 1px solid var(--border); color: #8899ac; font-size: 0.9rem; background: rgba(0,0,0,0.5); }
        
        #collectionTabs .tab-btn[data-coll]{
  display:flex;
  align-items:center;
  gap:10px;
}
#collectionTabs .tab-btn .coll-del{
  margin-left:auto;
  opacity:0.6;
  font-weight:900;
  padding:0 6px;
  border-radius:8px;
}
#collectionTabs .tab-btn .coll-del:hover{
  opacity:1;
  color: var(--warn);
  background: rgba(255,255,255,0.06);
}
/* POLICY DATE PICKER */
.datepick{ position:relative; display:flex; gap:8px; align-items:center; }
.datepick input{ flex:1; }
.datepop{
  position:absolute; top:calc(100% + 8px); left:0;
  width: 290px;
  background:#0f1424;
  border:1px solid var(--border);
  border-radius:14px;
  padding:12px;
  box-shadow:0 18px 60px rgba(0,0,0,.65);
  z-index:3000;
}
.datepop.hidden{ display:none; }
.dp-head{ display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
.dp-title{ font-weight:800; color:var(--text); font-size:0.95rem; }
.dp-nav{ display:flex; gap:6px; }
.dp-btn{
  width:34px; height:34px; padding:0;
  border-radius:10px;
  display:flex; align-items:center; justify-content:center;
}
.dp-grid{ display:grid; grid-template-columns:repeat(7,1fr); gap:6px; }
.dp-dow{ font-size:0.7rem; color:var(--text-light); text-align:center; padding:4px 0; }
.dp-day{
  padding:8px 0;
  border-radius:10px;
  text-align:center;
  font-size:0.85rem;
  cursor:pointer;
  border:1px solid rgba(120,140,255,0.12);
  background:rgba(255,255,255,0.03);
}
.dp-day:hover{ border-color: rgba(90,230,255,0.35); background: rgba(90,230,255,0.08); }
.dp-day.disabled{ opacity:0.35; cursor:not-allowed; }
.dp-day.selected{ border-color: rgba(90,230,255,0.65); background: rgba(90,230,255,0.16); color:#fff; }

/* Loading Pulse Animation for PFP */
.loading-pulse {
    animation: pfpPulse 1.2s infinite ease-in-out;
    border-color: var(--primary) !important;
    box-shadow: 0 0 15px var(--primary);
}
@keyframes pfpPulse {
    0% { opacity: 1; box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.7); }
    70% { opacity: 0.7; box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
    100% { opacity: 1; box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
}

/* Ensure Wallet Names Capitalize */
.wallet-dropdown .menu-item span {
    text-transform: capitalize;
}

/* --- MOBILE ASSET PREVIEW FIX --- */
@media (max-width: 768px) {
    /* 1. Stack the Title row above the Controls row */
    #assetPreviewCard .browser-header {
        flex-direction: column !important;
        align-items: flex-start !important;
        gap: 10px !important;
        padding-bottom: 10px;
    }

    /* 2. Ensure the Title takes full width (optional, good for alignment) */
    #assetPreviewCard .browser-header-left {
        width: 100%;
        margin-bottom: 5px;
    }

    /* 3. Force the Controls container to fill the row */
    #assetPreviewCard .browser-header-controls {
        width: 100%;
        display: flex;
        justify-content: space-between; /* Spreads them out nicely */
        gap: 10px;
    }

    /* 4. Make the dropdowns share the available space equally */
    #assetPreviewCard .browser-select {
        flex: 1;       /* Grow to fill width */
        min-width: 0;  /* Prevent breaking on very small screens */
        max-width: none !important; /* Remove desktop width restriction */
        width: auto;
    }

    /* Optional: Hide the "Filter:" and "Show:" text labels on mobile to save space */
    #assetPreviewCard .browser-label {
        display: none; 
    }
    
    /* FORCE GRID LAYOUT: Adjusted min-width to 125px to fit 2 columns with extra padding */
    #studioAssetGrid {
        display: grid !important;
        grid-template-columns: repeat(auto-fill, minmax(125px, 1fr)) !important;
        gap: 15px;
        width: 100%;
    }
    
    /* Ensure grid items don't force width */
    #studioAssetGrid > div {
        width: auto !important;
        max-width: 100% !important;
    }
    /* 1. Increase header height & adjust padding */
    .cardHeader.sectionHeader {
        min-height: 85px;       /* More height */
        padding: 15px 20px;     /* Push text in from edges */
        align-items: flex-start;
    }

    /* 2. Switch the row to a vertical column */
    .header-info-row {
        flex-direction: column;
        align-items: flex-start; /* Pushes Title to Left */
        gap: 10px;               /* Space between row 1 and 2 */
    }

    /* 3. Adjust Title (Up and Left) */
    .header-info-row h3 {
        margin-right: 0 !important;
        width: 100%;
        text-align: left;
    }

    /* 4. Reset the Pills Wrapper (Remove absolute, force center) */
    .centered-stats-wrap {
        position: static;       /* Stop floating */
        transform: none;        /* Remove the centering offset */
        width: 100%;            /* Fill width */
        justify-content: center;/* Center the pills in the 2nd row */
        margin-top: 4px;
    }
}
</style>
</head>
<body>
  <div id="toastBox"></div>

  <header class="main-header">
      <div class="header-left">
          <img src="../fre5hfence/RF5.png?v=2" alt="RF5" class="header-logo">
          <span class="header-title">ID Pages</span>
      </div>

<div class="header-center">
  <nav class="center-nav" id="centerNavLinks">
    <div class="nav-item"><a href="/">Home</a></div>
    
        <div class="nav-item">
      ID Pages <i class="fas fa-caret-down"></i>
      <div class="nav-dropdown">
        <a class="drop-link" href="/idp/">ID Pages Home</a>
        <a class="drop-link" href="/idp/#drops">Drops</a>
        <a class="drop-link" href="/idp/#explore">Explore</a>
        <a class="drop-link" href="/idp/#create">Create</a>
        <a class="drop-link" href="/idp/#cTools">Creator Tools</a>
      </div>
    </div>

    <div class="nav-item">
      Fre5h Mint <i class="fas fa-caret-down"></i>
      <div class="nav-dropdown">
        <a class="drop-link" href="/fre5hmint/">Live Mints</a>
        <a class="drop-link" href="/fre5hmint/previous/">Previous Mints</a>
        <a class="drop-link" href="/fre5hmint/index.html#contact">Schedule Mint</a>
      </div>
    </div>

    <div class="nav-item">
      Products <i class="fas fa-caret-down"></i>
      <div class="nav-dropdown">
        <a class="drop-link" href="/products">All Products</a>
        <a class="drop-link" href="/products#product1">BackUps</a>
        <a class="drop-link" href="/products#product2">VanID Miner</a>
        <a class="drop-link" href="/products#product3">Q₳rt Codes</a>
        <a class="drop-link" href="/products#product4">Fre5h Fence</a>
        <a class="drop-link" href="/products#product5">Linkz</a>
        <a class="drop-link" style="display: none;" href="/products#product6">Product 6</a>
      </div>
    </div>

    <div class="nav-item">
      F5 Fun <i class="fas fa-caret-down"></i>
      <div class="nav-dropdown">
        <a class="drop-link" href="/bingo/">Refresh Bingo</a>
        <a class="drop-link" href="/collector/">Collector Card</a>
      </div>
    </div>

    <div class="nav-item">
      Galleries <i class="fas fa-caret-down"></i>
      <div class="nav-dropdown">
        <a class="drop-link" href="/galleries/therefresh/">The Refresh</a>
        <a class="drop-link" href="/galleries/creepfresh/">The Creepfresh</a>
        <a class="drop-link" href="/galleries/jinglefresh/">Jingle Fresh</a>
        <a class="drop-link" href="/galleries/therefresher/">The ReFre5her</a>
        <a class="drop-link" style="display:none;" href="/galleries/4fresh/">4Fre5h</a>
        <a class="drop-link" href="https://www.muse.place/f5" target="_blank">Virtual Gallery</a>
      </div>
    </div>
  </nav>

  <div class="mini-search" id="miniSearchWrap">
    <i class="fas fa-search" style="color:#8899ac;"></i>
    <input type="text" class="mini-search-input" placeholder="Search...">
  </div>
</div>

<div class="header-right">

  <!-- Bell (no wiring needed) -->
  <div class="notif-wrapper" id="headerNotifIcon" onclick="toggleNotifDropdown()">
    <i class="fas fa-bell notif-bell"></i>
    <div class="notif-dot" id="headerNotifDot"></div>
    <div class="notif-dropdown" id="notifList"></div>
  </div>

<!-- Wallet icon connect (Studio style trigger) -->
<div class="wallet-menu-container" id="walletMenu">
  <div class="icon-wrap" id="walletTrigger" onclick="handleWalletClick(event)">
    <i class="fas fa-wallet wallet-ico"></i>
  </div>
  <div class="wallet-dropdown" id="walletDropdown"></div>
</div>

  <!-- Optional: keep if you already use it -->
  <div id="headerBalance" class="wallet-balance">₳ 0.00</div>

  <!-- PFP menu (NO wallet connect here anymore) -->
  <div class="profile-menu-container">
    <img src="../fre5hfence/RF5.png?v=2" id="headerProfileBtn" class="header-pfp" onclick="handleProfileClick(event)">
    <div class="profile-dropdown" id="profileDropdown"></div>
  </div>

  <!-- Hamburger -->
  <div class="mobile-menu-btn" onclick="toggleMobileMenu()">
    <i class="fas fa-bars"></i>
  </div>
</div>
  </header>

  <div id="landingPage">
    <div class="hero-section" id="heroSection">
        <!-- Dynamic media goes here -->
        <div class="hero-media-layer" id="heroMediaLayer"></div>
    
        <!-- Fallback background (shows until hero loads or if feed is empty) -->
        <div class="hero-bg hero-bg-fallback" id="heroBgFallback"
             style="background-image: url('../fre5hfence/RF5.png?v=2');"></div>
    
        <!-- Readability overlay -->
        <div class="hero-overlay"></div>
    
        <div class="hero-content">
            <div class="hero-title" id="heroTitle">ID Pages</div>
            <div class="hero-subtitle" id="heroSubtitle">Your Policy Your Page</div>
    
            <!-- Clickable hero assets -->
            <div class="hero-asset-strip" id="heroAssetStrip"></div>
            <div class="hero-byline" id="heroByline"></div>

        </div>
    </div>

      
      <div class="section-container">
          <h2 class="section-title">Live Drops</h2>
          <div class="drops-grid">
              <div class="preview-card">
                  <div style="height:200px; display:flex; align-items:center; justify-content:center; color:#666;">No Live Drops</div>
              </div>
          </div>
      </div>

      <div class="section-container">
          <h2 class="section-title">New on ID Pages</h2>
          <div class="new-grid" id="newProfilesGrid">
              <div class="preview-card">
                  <div style="height:200px; display:flex; align-items:center; justify-content:center; color:#666;">Loading New Arrivals...</div>
              </div>
          </div>
      </div>
  </div>


<div id="studioRoot" class="hidden">
    <div class="content-wrapper">

<h1 class="app-title">
            <span class="app-title-main">IDP Studio</span>
            <span class="app-title-beta">BETA</span>
        </h1>
        <p>Build Your Way</p>

        <div style="display:none;">
            <div id="bannerHint"></div>
            <div id="thumbHint"></div>
            <div id="mintThumbHint"></div>
        </div>

        <div class="card" id="creatorStudio">
            <div class="cardHeader builder-header">
                <h3>BUILDER</h3>
                <div style="width:100%; display:flex; align-items:center; justify-content:space-between; margin-top:5px;">
                     <button class="tab-btn active" id="btnAddCollection" style="background:rgba(90,230,255,0.1); color:var(--primary);">+ New Collection</button>
                     <span style="font-size:0.8rem; color:var(--text-light); font-style:italic;">Click input field titles for guidance</span>
                </div>
            </div>

            <div class="cardBody">
                <div class="tabs-nav" id="collectionTabs"></div>

                <div id="noCollectionsNote" class="hint hidden">
                    No collections yet. Click <b>+ New Collection</b>.
                </div>

                    <div id="collectionPanel">
                    
                    <div class="card section" id="policySection">
    <div class="cardHeader sectionHeader" onclick="this.parentElement.classList.toggle('open')">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Policy</h3>

            <div class="centered-stats-wrap">
                <span class="stat-pill">
                    ID: <span id="policyIdShort" style="font-family:monospace; color:var(--text-light);">Waiting...</span>
                </span>
                <span class="stat-pill">
                    Type: <b id="policyTypeHeader" style="color:var(--primary);"></b>
                </span>
            </div>
        </div>
    </div>

    <div class="cardBody sectionBody">
        <div class="row" style="margin-bottom:15px;">
            <div class="col">
                <label>Policy ID (Full)</label>
                <div style="display:flex; gap:10px;">
                    <input type="text" id="policyIdFull" readonly value="Loading..." style="font-family:monospace; font-size:0.85rem; cursor:pointer;" onclick="this.select();">
                    <button class="icon-btn secondary" title="Copy" onclick="navigator.clipboard.writeText(document.getElementById('policyIdFull').value)">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col">
                <label>Policy Type</label>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span id="policyTypeDisplay" style="color:var(--primary); font-weight:bold; font-size:1.1rem;">Waiting...</span>
                </div>
            </div>
            <div class="col" id="lockDetailsCol" style="display:none;">
                <label>Lock Date: <span id="lockDateDisplay" style="color:#fff;">--/--/--</span></label>
                <div style="font-size:0.85rem; color:var(--text-light);">
                    Time Left: <span id="daysLeft" style="color:var(--warn); font-weight:bold;">0</span> days
                </div>
            </div>
        </div>
    </div>
</div>

                    <div class="card section" id="collectionDetailsSection">
                   <div class="cardHeader sectionHeader" onclick="this.parentElement.classList.toggle('open')">
                <div class="header-info-row">
                            <h3 style="width: auto; margin-right: 10px;">Details</h3>
                            
                            <div class="centered-stats-wrap">
                                <span class="stat-pill">
                                    <span id="headerCollNameDisplay">My Collection</span>
                                </span>
                                <span class="stat-pill">
                                    Max: <b id="headerMaxDisplay">1</b>
                                </span>
                                <span class="stat-pill">
                                    Type: <b id="headerTypeDisplay">NFT</b>
                                </span>
                            </div>
                        </div>
                </div>
                    <div class="cardBody sectionBody">
                            <div class="row" style="flex-wrap:wrap;">
                                <div class="col" style="flex:2; min-width: 200px;">
                                    <label>Collection Name</label>
                                        <input type="text" id="collectionName" placeholder="e.g. My Collection" 
                                       oninput="document.getElementById('headerCollNameDisplay').innerText = this.value || 'Not Set'">
                                </div>
<div class="col" style="flex:1; min-width: 120px;">
    <label>Max Supply</label>
    <input type="number" id="totalAssets" value="1" min="1"
       oninput="syncMaxSupply(this.value)">
</div>
                            </div>

                            <div class="row">
                                <div class="col">
                                    <label>Sale Description (Visible to Buyers)</label>
                                    <textarea id="saleDescription" style="height:80px;" placeholder="Describe your drop..."></textarea>
                                </div>
                            </div>

                            <div class="row">
<div class="col">
    <label>Type & Distribution</label>
    <div style="display:flex; flex-direction:column; gap:15px; background:rgba(0,0,0,0.2); padding:10px; border-radius:10px;">
        
        <div style="display:flex; gap:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
            <label class="check-wrap">
                <input type="radio" name="astype" value="nft" checked onchange="document.getElementById('headerTypeDisplay').innerText = 'NFT'"> NFT
            </label>
            <label class="check-wrap">
                <input type="radio" name="astype" value="edition" onchange="document.getElementById('headerTypeDisplay').innerText = 'Edition'"> Edition
            </label>
            <label class="check-wrap">
                <input type="radio" name="astype" value="ft" onchange="document.getElementById('headerTypeDisplay').innerText = 'FT'"> FT
            </label>
        </div>

        <div style="display:flex; gap:15px;">
            <label class="check-wrap">
                <input type="radio" name="dist" value="random" checked> Random
            </label>
            <label class="check-wrap">
                <input type="radio" name="dist" value="order"> In Order
            </label>
        </div>

    </div>
</div>
                            </div>

                            <div class="row" style="margin-top:10px;">
                                <div class="col">
                                    <label>
                                        Asset Name (ID) 
                                        <label class="check-wrap" style="font-size:0.85rem;"><input type="checkbox" id="useCollName" checked> Use Collection Title</label>
                                    </label>
                                    <input type="text" id="assetNameInput" placeholder="Auto-generated" disabled>
                                    <div id="assetNamePreview" style="font-size:0.75rem; color:var(--warn); margin-top:4px;">Preview: Collection1</div>
                                    
                                    <div id="editionConfig" class="hidden" style="margin-top:5px;">
                                        <input type="text" id="editionInput" placeholder="Editions: 5 of 15">
                                    </div>
                                    <div id="ftConfig" class="hidden" style="margin-top:5px;">
                                        <input type="text" id="ftTicker" placeholder="Ticker (e.g. BTC)">
                                    </div>
                                </div>
                            </div>
                        </div> 
                    </div> 
       
                
                
<div class="card section" id="buildCard">
    <div class="cardHeader sectionHeader" onclick="const b=document.getElementById('buildBody'); b.style.display = b.style.display==='none'?'block':'none';">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Build</h3>
            
            <div class="centered-stats-wrap">
                <label class="check-wrap" style="color:var(--text-light); font-size:0.9rem;">
                    <input type="checkbox" id="validMetaCheck" disabled> Metadata
                </label>
                <label class="check-wrap" style="color:var(--text-light); font-size:0.9rem;">
                    <input type="checkbox" id="validContentCheck" disabled> Content
                </label>
            </div>
        </div>
    </div>
    <div class="cardBody" id="buildBody" style="display:none;">
        
        <div class="tabs-nav" id="studioTabsNav" style="justify-content: center; width: 100%;">
            <button class="tab-btn active" style="font-size:1.1rem; padding: 12px 24px;" onclick="switchStudioTab('meta')">Metadata</button>
            <button class="tab-btn" style="font-size:1.1rem; padding: 12px 24px;" onclick="switchStudioTab('code')">Content</button>
        </div>

        <div id="tab-meta" class="tab-content active">
            <div class="col">
            <div class="row" style="justify-content:flex-start; margin-bottom:10px;">
                <div class="dropdown">
                    <button class="secondary icon-btn" onclick="toggleContentTools(event)">
                        <i class="fas fa-tools"></i> Content Tools
                    </button>
                    <div class="dropdown-content">
                        <button class="secondary icon-btn" id="btnOpenMetaEditor"><i class="fas fa-edit"></i> Edit JSON</button>
                        <label class="secondary icon-btn" style="cursor:pointer; margin:0;">
                            <i class="fas fa-file-download"></i> Import
                            <input type="file" id="importFile" accept=".json" style="display:none;">
                        </label>
                        <button class="secondary icon-btn" id="btnExportConfig"><i class="fas fa-file-upload"></i> Export</button>
                    </div>
                </div>
            </div>
                <div id="defaultProps"></div>
                <div id="metaPropsContainer"></div>
                <button class="secondary icon-btn" id="addMetaPropBtn" onclick="addProp('meta')">+ New Property</button>
            </div>
        </div>

        <div id="tab-code" class="tab-content">
            <div class="col">
                <label>Content (ALL MEDIA TYPES)</label>
                <div class="row" style="justify-content:flex-start; gap:20px; margin-bottom:10px;">
                    <label class="check-wrap"><input type="radio" name="encoding" value="base64" checked> Base64</label>
                    <label class="check-wrap"><input type="radio" name="encoding" value="utf8"> UTF-8</label>
                </div>
                <div class="row">
                    <button class="secondary icon-btn" id="btnUpload"><i class="fas fa-folder-open"></i> Upload</button>
                    <button class="secondary icon-btn" id="btnPaste"><i class="fas fa-clipboard"></i> Paste</button>
                    <button class="secondary icon-btn" id="btnImportCollection"><i class="fas fa-file-import"></i> Import Collection</button>
                    <button class="secondary icon-btn" id="btnClear"><i class="fas fa-trash"></i></button>
                </div>
                <textarea id="codeContent" style="height:150px; font-family:monospace; font-size:0.8rem;" placeholder="<html>...</html>"></textarea>
                <input type="file" id="fileInput" style="display:none">
                
                <div style="margin-top:15px; margin-bottom: 5px; font-weight:bold; color:var(--primary)">Keywords & Injection</div>
                <div id="codePropsContainer"></div>
                <button class="secondary icon-btn" id="addCodePropBtn">+ Add Keyword</button>
            </div>

            <label style="margin-top:15px;">Thumbnail / Asset Preview</label>
            <div class="row" id="previewDropZone" style="border:2px dashed var(--border); padding:10px; border-radius:10px;">
                <input type="text" id="previewImgInput" placeholder="ipfs://... or data:image/png;base64..." style="flex:1;">
                <button class="secondary icon-btn" id="btnUploadPreview" style="white-space:nowrap;"><i class="fas fa-image"></i> Upload</button>
                <input type="file" id="previewFileInput" accept="image/*" style="display:none">
            </div>
            <div id="assetPreviewHint" class="hidden" style="margin-top:8px; font-size:0.8rem; color:var(--text-light);">
                Drag and drop to update (this one affects minted asset metadata)
            </div>
            <img id="visualPreview" style="object-fit: contain; max-height:100px; margin-top:10px; border-radius:8px; display:none;" onerror="this.style.display='none'">
        </div>
    </div>
</div>

<div class="card section" id="assetPreviewCard">
    <div class="cardHeader sectionHeader" onclick="const b=document.getElementById('assetPreviewBody'); b.style.display = b.style.display==='none'?'block':'none';">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Asset Preview</h3>
            
            <div class="centered-stats-wrap">
                <span class="stat-pill">
                    Assets Ready: <b id="headerAssetCount">0</b>
                </span>
            </div>
        </div>
    </div>
    
    <div class="cardBody" id="assetPreviewBody" style="display:none;">
        <div class="browser-header">
            <div class="browser-header-left">
                <h2 style="font-size: 1.2rem; margin:0;">Collection Assets</h2>
                <div id="studioAssetCountLabel" class="asset-count-label">0 assets</div>
            </div>
            <div class="browser-header-controls">
                <label class="browser-label">Filter:</label>
                <select id="studioPropertyFilterSelect" class="browser-select">
                    <option value="ALL">All properties</option>
                </select>
                <label class="browser-label">Show:</label>
                <select id="studioAssetPageSizeSelect" class="browser-select">
                    <option value="10">10</option>
                    <option value="25" selected>25</option>
                    <option value="50">50</option>
                </select>
            </div>
        </div>

        <div class="asset-grid" id="studioAssetGrid" style="max-height: 600px; overflow-y: auto; padding-right: 5px;">
            <div id="studioNoAssetsMsg" style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #8899ac; border: 1px dashed rgba(255,255,255,0.1); border-radius: 8px;">
                No Assets Created
            </div>
        </div>

        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <button class="tool-btn" id="btnNewAsset" onclick="createNewAsset()">
                <i class="fas fa-plus"></i> New Asset
            </button>
        </div>
    </div>
</div>
    

<div class="card section" id="paymentInfoCard">
    <div class="cardHeader sectionHeader" onclick="const b=document.getElementById('paymentInfoBody'); b.style.display = b.style.display==='none'?'block':'none';">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Payment Info</h3>
            
            <div class="centered-stats-wrap">
                <span class="stat-pill">
                    Address: <b id="headerAddrDisplay">Not Set</b>
                </span>
                <span class="stat-pill">
                    Cost: <b id="headerCostDisplay">Free</b>
                </span>
            </div>
        </div>
    </div>
    <div class="cardBody" id="paymentInfoBody" style="display:none;">
        <div class="row">
            <div class="col">
                <label>
                    Receive Address (Funds go here) 
                    <label class="check-wrap">
                        <input type="checkbox" id="useWalletAddr" onchange="document.getElementById('headerAddrDisplay').innerText = this.checked ? 'Wallet' : 'Not Set'"> 
                        Use Connected
                    </label>
                </label>
                <input type="text" id="receiveAddr" placeholder="addr1..." 
                       oninput="document.getElementById('headerAddrDisplay').innerText = this.value.length > 5 ? this.value.substring(0,5)+'...' : (this.value || 'Not Set')">
            </div>
        </div>
        <div class="row">
            <div class="col">
                <label>Price (₳)</label>
                <div style="display:flex; gap:15px; margin-bottom:8px;">
                    <label class="check-wrap">
                        <input type="radio" name="costType" value="free" checked 
                               onchange="document.getElementById('headerCostDisplay').innerText = 'Free'"> 
                        Free
                    </label>
                    <label class="check-wrap">
                        <input type="radio" name="costType" value="paid" 
                               onchange="document.getElementById('headerCostDisplay').innerText = (document.getElementById('mintCost').value || '0') + ' ₳'"> 
                        Paid
                    </label>
                </div>
                <input type="number" id="mintCost" placeholder="0" disabled 
                       oninput="document.getElementById('headerCostDisplay').innerText = this.value + ' ₳'">
            </div>
        </div>
    </div>
</div>
        
<div class="card section" id="stationSetupCard">
    <div class="cardHeader sectionHeader" onclick="const b=document.getElementById('stationSetupBody'); b.style.display = b.style.display==='none'?'block':'none';">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Station Setup</h3>
            
            <div class="centered-stats-wrap" style="flex-wrap:wrap; justify-content:center; gap:15px;">
                <label class="check-wrap" style="color:var(--text-light); font-size:0.8rem;">
                    <input type="checkbox" id="checkThumb" disabled> Thumb
                </label>
                <label class="check-wrap" style="color:var(--text-light); font-size:0.8rem;">
                    <input type="checkbox" id="checkBanner" disabled> Banner
                </label>
                <label class="check-wrap" style="color:var(--text-light); font-size:0.8rem;">
                    <input type="checkbox" id="checkBg" disabled> BG
                </label>
                <label class="check-wrap" style="color:var(--text-light); font-size:0.8rem;">
                    <input type="checkbox" id="checkText" disabled> Text
                </label>
            </div>
        </div>
    </div>
    
    <div class="cardBody" id="stationSetupBody" style="display:none;">
        
        <label>Collection Thumbnail (Sale Page Only)</label>
        <div class="row" id="collectionThumbDropZone" style="border:2px dashed var(--border); padding:10px; border-radius:10px;">
            <input type="text" id="collectionThumbInput" placeholder="fbThumb.png or ipfs://..." style="flex:1;">
            <button class="secondary icon-btn" id="btnUploadCollectionThumb" style="white-space:nowrap;">
                <i class="fas fa-camera"></i> Upload
            </button>
            <input type="file" id="collectionThumbFileInput" accept="image/*" style="display:none">
        </div>
        <img id="collectionThumbPreview" style="object-fit:cover; width:100px; height:100px; margin-top:10px; border-radius:12px; display:none;">
        <div id="collectionThumbHint" class="hint hidden">Drag & drop to update collection thumbnail</div>

        <div style="width:100%; height:1px; background:rgba(255,255,255,0.1); margin:20px 0;"></div>

        <label>Mint Station Banner</label>
        <div class="row" style="border:2px dashed var(--border); padding:10px; border-radius:10px; align-items: center;">
            <div style="flex:1; font-size:0.85rem; color:var(--text-light);">
                Upload a custom banner image for the Mint Station display.
            </div>
            <label class="secondary icon-btn" id="bannerUploadBtn" style="white-space:nowrap;">
                <i class="fas fa-image"></i> Upload
                <input type="file" id="bannerInput" accept="image/*" style="display:none"> 
            </label>
        </div>
        <img id="bannerPreview" style="object-fit:cover; width:100%; height:80px; margin-top:10px; border-radius:10px; display:none; border:1px solid var(--border);">

        <div style="width:100%; height:1px; background:rgba(255,255,255,0.1); margin:20px 0;"></div>

        <label style="margin-bottom:10px;">Station Appearance</label>
        
        <div class="row" style="margin-bottom:15px;">
            <div class="col">
                <label>Background Color</label>
                <div style="display:flex; align-items:center; gap:10px;">
                    <input type="color" id="stationBgColor" value="#000000" style="width:50px; padding:2px; height:40px; min-height:40px;">
                    <span style="font-size:0.8rem; color:var(--text-light); opacity:0.7;">Click to set</span>
                </div>
            </div>
            <div class="col">
                <label>Text Color</label>
                <div style="display:flex; align-items:center; gap:10px;">
                    <input type="color" id="stationTextColor" value="#ffffff" style="width:50px; padding:2px; height:40px; min-height:40px;">
                    <span style="font-size:0.8rem; color:var(--text-light); opacity:0.7;">Click to set</span>
                </div>
            </div>
        </div>

        <label>Background Image</label>
        <div class="row" id="bgImgDropZone" style="border:2px dashed var(--border); padding:10px; border-radius:10px;">
            <input type="text" id="bgImgInput" placeholder="Image URL or IPFS..." style="flex:1;">
            <button class="secondary icon-btn" id="btnUploadBgImg" style="white-space:nowrap;">
                <i class="fas fa-image"></i> Upload
            </button>
            <input type="file" id="bgImgFileInput" accept="image/*" style="display:none">
        </div>
        <img id="bgImgPreview" style="object-fit:cover; width:100px; height:100px; margin-top:10px; border-radius:12px; display:none;">

    </div>
</div>


<div class="card section" id="buyerUI">
    <div class="cardHeader sectionHeader" onclick="const b=document.getElementById('buyerUIBody'); b.style.display = b.style.display==='none'?'block':'none';">
        <div class="header-info-row">
            <h3 style="width: auto; margin-right: 10px;">Mint Station</h3>
            
            <div class="centered-stats-wrap">
                <span class="stat-pill">
                    Sold: <b id="soldCount" style="color:var(--primary);">0</b>
                    <span style="color:var(--text-light); margin:0 4px;">/</span>
                    <b id="maxSupplyDisplay">∞</b>
                </span>
                
                <span class="stat-pill">
                    Income: <b id="totalIncomeDisplay" style="color:var(--success);">0 ₳</b>
                </span>
            </div>
        </div>
    </div>
    
    <div class="cardBody" id="buyerUIBody" style="display:none;">
        <h2 id="displayTitle" style="text-align:center;">Collection Title</h2>
        <p id="displayDesc" style="color:var(--text-light); white-space: pre-wrap; text-align:center; font-size:0.9rem;">Collection description will appear here.</p>
        
        <div style="display:flex; justify-content:center; margin: 15px 0;">
            <div id="mintPreviewWrap" style="width:100%; max-width:300px; aspect-ratio: 16/9; position:relative;"> 
                <div class="thumb-area" id="mintThumbArea" style="width:100%; height:100%; border-radius:16px;">
                    <img id="mintCollectionPreview" style="width:100%;height:100%;object-fit:cover;" src="fbThumb.png"
                         onerror="this.src='https://placehold.co/300x180/1a1a1a/FFF?text=Waiting+For+Upload'">
                    
                    <div id="mintWaitOverlay" class="mint-wait-overlay hidden">
                        <div class="mint-spinner"></div>
                        <div class="mint-wait-text">Packaging your purchase...️✨</div>
                    </div>

                    <iframe id="mintMediaFrame" class="hidden" style="width:100%;height:100%;border:0;"></iframe>
                </div>
            </div>
        </div>
        
        <div class="row" id="qtyRow" style="align-items:center;">
            <div class="col">
                <label>Quantity (Max 10)</label>
                <select id="mintQty" style="max-width:100px;">
                    <option value="1">1</option><option value="2">2</option><option value="3">3</option>
                    <option value="4">4</option><option value="5">5</option><option value="6">6</option>
                    <option value="7">7</option><option value="8">8</option><option value="9">9</option>
                    <option value="10">10</option>
                </select>
            </div>
            <div class="col" style="flex:2; text-align:right;">
                <div style="font-size:1.2rem; font-weight:bold; color:var(--primary);" id="totalPriceDisplay">0 ₳</div>
            </div>
        </div>

        <button id="btnMint" style="width:100%; padding:15px; font-size:1.1rem; margin-top:15px;">Mint Now</button>
        <div class="log-box" id="txLog" style="margin-top:15px;"></div>
        
        <div id="successPreview" class="hidden" style="text-align:center; margin-top:10px;">
            <div style="color:var(--success); margin-bottom:5px;">Mint Successful!</div>
            <img id="mintedThumb" style="width:100px; height:100px; border-radius:10px; object-fit:cover;">
        </div>
    </div>
</div>
</div>

      </div> 
     </div> 
<div class="modal-overlay" id="policyModal" style="z-index: 4000;">
    <div class="modal-box" style="width: 450px;">
        <div class="modal-title" style="margin-bottom:15px; font-size:1.2rem; font-weight:bold;">Create New Collection</div>

        <div style="margin-bottom: 15px;">
            <label>Policy Selection</label>
            <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; display:flex; gap:15px;">
                <label class="check-wrap">
                    <input type="radio" name="policyChoice" value="new" checked onclick="togglePolicyDropdown(false)"> 
                    <span style="font-weight:bold;">New Policy</span>
                </label>
                <label class="check-wrap">
                    <input type="radio" name="policyChoice" value="existing" onclick="togglePolicyDropdown(true)"> 
                    <span style="font-weight:bold;">Existing Policy</span>
                </label>
            </div>
        </div>

        <div id="existingPolicyRow" class="hidden" style="margin-bottom: 15px;">
            <label>Select Existing Policy</label>
            <select id="existingPolicySelect" style="width:100%; font-family:monospace;"></select>
        </div>

        <label>Collection Name</label>
        <input type="text" id="policyCollectionName" placeholder="e.g. Summer Drop 2026">

        <div id="newPolicyConfig"> 
            <div style="margin: 15px 0;">
                <label style="margin-bottom:5px;">Policy Type</label>
                <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px;">
                    <label class="check-wrap" style="margin-bottom:8px;">
                        <input type="radio" name="policyType" value="open" checked> 
                        <span style="font-weight:bold; color:var(--primary);">Open Policy</span> 
                        <span style="font-size:0.8rem; opacity:0.7;">(Mint anytime, locking optional later)</span>
                    </label>
                    <label class="check-wrap">
                        <input type="radio" name="policyType" value="timelock"> 
                        <span style="font-weight:bold; color:#ff6b6b;">Time-Locked</span> 
                        <span style="font-size:0.8rem; opacity:0.7;">(Auto-locks at specific date)</span>
                    </label>
                </div>
            </div>

            <div id="policyLockRow" class="row hidden" style="align-items:flex-end;">
                <div class="col">
                    <label>Lock Date (Midnight UTC)</label>
                    <div class="datepick">
                        <input type="text" id="policyLockDate" placeholder="YYYY-MM-DD" readonly>
                        <button class="icon-btn secondary" id="policyDateBtn"><i class="fas fa-calendar"></i></button>
                        <div class="datepop hidden" id="policyDatePop"></div>
                    </div>
                </div>
            </div>
        </div> 
        <div class="row" style="margin-top:25px; justify-content:flex-end;">
            <button class="secondary" onclick="closeModal('policyModal')">Cancel</button>
            <button onclick="savePolicyAndCreateCollection()">Set & Create</button>
        </div>
    </div>
</div>

<div id="singlePropModal" class="modal-overlay">
    <div class="modal-box" style="max-width:400px;">
        <h3>Set Property Value</h3>
        <p style="color:var(--text-light); font-size:0.9rem; margin-bottom:15px;">
            Adding specific property for Asset <span id="singlePropAssetID">#</span>
        </p>
        
        <div class="input-group">
            <label>Property Name</label>
            <input type="text" id="singlePropKey" placeholder="e.g. Rarity">
        </div>
        
        <div class="input-group">
            <label>Value</label>
            <input type="text" id="singlePropVal" placeholder="e.g. Legendary">
        </div>

        <div class="row" style="margin-top:20px; gap:10px;">
            <button class="secondary" onclick="document.getElementById('singlePropModal').classList.remove('open')">Go Back</button>
            <button class="primary" onclick="saveSingleAssetProp()">Save Property</button>
        </div>
    </div>
</div>


        <div class="studio-footer-bar">
            <button class="tool-btn" onclick="exitIDPStudio(false)">Go Back</button>
            <button class="tool-btn primary" onclick="exitIDPStudio(true)"><i class="fas fa-save"></i> Save</button>
        </div>
    </div> 
</div>



  <div id="dashboardRoot" class="hidden">
      <div id="appDB" class="app-container">
          <div class="glass-panel hidden" id="setupPanel">
              <input type="hidden" id="hiddenWalletAddress"><input type="hidden" id="hiddenStakeKey"><input type="hidden" id="hiddenExistingPfp">
              <h2 style="margin-bottom:20px;">Create Profile</h2>
              <div class="glass-input-group"><label>Display Name</label><input type="text" id="inputName" class="glass-input"></div>
              <div class="glass-input-group"><label>Bio</label><textarea id="inputBio" class="glass-input"></textarea></div>
              <div class="glass-input-group"><label>Location</label><textarea id="inputLocation" class="glass-input"></textarea></div>
              <div class="glass-input-group"><label>Profile Image</label><input type="file" id="inputPfpFile" class="glass-input"></div>
              <button id="saveProfileBtn" class="btn-action">Save Profile</button>
              <button id="cancelEditBtn" class="btn-cancel hidden">Cancel</button>
          </div>

<div class="glass-panel hidden" id="profilePanel" style="padding-top:0;">
    <div class="pfp-wrapper"><img src="" id="displayPfp" class="pfp-img"></div>
    <div style="text-align:center;">
        <h1 id="displayName" class="profile-name"></h1>
        <p id="displayBio" class="profile-bio"></p>
        <p id="displayLocation" class="profile-location"></p>
        <div class="url-bar" style="margin-bottom:20px;">
            <span id="displayUrlText" class="url-text"></span>
            <button class="icon-btn" onclick="copyProfileUrl()"><i class="fas fa-copy"></i></button>
            <a id="displayUrlLink" href="#" target="_blank" class="icon-btn"><i class="fas fa-external-link-alt"></i></a>
        </div>
    </div>

<div class="creator-tools" id="creatorToolsArea">
        <button class="tool-btn primary" id="openImportModal"><i class="fas fa-file-import"></i> Import</button>
        
        <button class="tool-btn" id="btnEnterStudio" onclick="enterIDPStudio()" style="display:none;">
            <i class="fas fa-palette"></i> Enter IDP Studio
        </button>

        <button class="tool-btn" id="triggerEditBtn"><i class="fas fa-user-edit"></i> Edit Profile</button>
    </div>

<div class="dash-header-container">
        <div class="dash-row-top">
            <div class="dashboard-tabs">
                <button class="dash-tab active" id="tabCollections" onclick="switchDashTab('collections')">My Collections</button>
                <button class="dash-tab" id="tabWallet" onclick="switchDashTab('wallet')">My Wallet</button>
            </div>

            <div class="header-right-group">
                <div id="walletDropdowns" class="wallet-dropdowns-group hidden">
                    <select id="walletPageSizeSelect" class="wallet-select" style="width:auto;" onchange="updateWalletPageSize(this.value)">
                        <option value="4" selected>4</option>
                        <option value="8">8</option>
                        <option value="12">12</option>
                        <option value="20">20</option>
                    </select>
                    <select id="walletCollectionSelect" class="wallet-select" onchange="scrollToCollection(this.value)">
                        <option value="">Jump...</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="dash-row-bottom">
            <div id="collectionsDropdowns" class="wallet-dropdowns-group hidden-mobile" style="margin-right:auto; display:none;">
                <select id="colPageSizeSelect" class="wallet-select" style="width:auto;" onchange="updateColPageSize(this.value)">
                    <option value="4" selected>4</option>
                    <option value="8">8</option>
                    <option value="12">12</option>
                    <option value="20">20</option>
                </select>
                <select id="colCollectionSelect" class="wallet-select" onchange="scrollToCollection(this.value)">
                    <option value="">Jump...</option>
                </select>
            </div>
            <div id="walletCategoryBar" class="wallet-cat-tabs hidden">
                <button class="cat-tab active" onclick="filterWalletCat('NFT', this)">NFTs</button>
                <button class="cat-tab" onclick="filterWalletCat('EDITION', this)">Editions</button>
                <button class="cat-tab" onclick="filterWalletCat('RICH_FT', this)">Rich FTs</button>
                <button class="cat-tab" onclick="filterWalletCat('FT', this)">FTs</button>
            </div>

            <div style="display:flex; align-items:center; margin-left:auto; gap:10px;">
                <span id="walletStatsDisplay" class="wallet-stats-text" style="font-size:0.75rem;">0 Assets</span>
                
                <div class="delete-header-group" id="deleteGroup" style="margin-left:0;">
                    <button class="mobile-menu-btn" onclick="event.stopPropagation(); document.getElementById('actionMenuDropdown').classList.toggle('show')">
                        <i class="fas fa-bars"></i> Actions
                    </button>

                    <div class="mobile-actions-dropdown" id="actionMenuDropdown">
                        <button id="btnMainSave" class="state-btn" onclick="openPushModal()" title="Save & Push"><i class="fas fa-save"></i></button>
                        <button id="btnDeleteConfirm" onclick="openDeleteWarning()">Delete Selected</button>
                        <span id="deleteCountText">0</span>
                        <button id="btnCombineConfirm" onclick="openCombineNameModal()">Combine</button>
                        <button id="btnSeparateConfirm" onclick="executeSeparate()" style="display:none; background:#ffd869; color:#000; border:none; padding:6px 16px; border-radius:99px; font-weight:bold; font-size:0.8rem; cursor:pointer;">Separate</button>
                        
                        <div style="display:flex; gap:10px;">
                            <i class="fas fa-pen" id="btnToggleCombine" onclick="toggleCombineMode()" title="Edit/Combine" style="cursor:pointer; color:#8899ac; font-size:1.1rem; padding:5px;"></i>
                            <i class="fas fa-trash-alt" id="btnToggleDelete" onclick="toggleDeleteMode()" title="Delete Collections" style="cursor:pointer; color:#8899ac; font-size:1.1rem; padding:5px;"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="collection-grid" id="collectionsGrid">
        <div class="grid-item" style="color:#666;">No collections yet.</div>
    </div>
</div>
    </div>
          
          <div class="glass-panel hidden" id="policyTypePanel">
               <h2>Create Policy</h2>
               <input type="text" id="newCollectionName" class="glass-input" placeholder="Collection Name">
               <input type="date" id="timelockDate" class="glass-input">
               <div style="display:flex; gap:10px; margin-top:20px;">
                   <button class="btn-action" onclick="initPolicyBuilder('open')">Open</button>
                   <button class="btn-action" onclick="initPolicyBuilder('timelock')">Time-Lock</button>
               </div>
               <button class="btn-cancel" onclick="cancelCreatePolicy()">Cancel</button>
          </div>

        </div>

  <div id="walletModal" class="modal-overlay">
      <div class="modal-box" style="max-width:400px; text-align:center;">
          <button class="modal-close" onclick="closeModal('walletModal')">&times;</button>
          <h3>Connect Wallet</h3>
          <select id="modalWalletSelect" class="custom-select"><option>Scanning...</option></select>
          <button id="modalConnectBtn" class="btn-action">Connect</button>
      </div>
  </div>
  
  <div id="roleModal" class="modal-overlay">
      <div class="modal-box" style="max-width:500px; text-align:center;">
          <button class="modal-close" onclick="closeModal('roleModal')">&times;</button>
          <h2>Create Profile</h2>
          <p style="color:#888; margin-bottom:20px;">Choose your primary role (you can add the other later).</p>
          <div style="display:flex; gap:20px; justify-content:center;">
              <button class="btn-action" onclick="startProfileSetup('artist')">Artist</button>
              <button class="btn-action" style="background:transparent; border:1px solid var(--primary); color:var(--primary);" onclick="startProfileSetup('collector')">Collector</button>
          </div>
      </div>
  </div>
  
  <div id="welcomeModal" class="modal-overlay">
  <div class="modal-box" style="max-width:520px;">
    <div style="font-size:1.35rem; font-weight:900; color:#fff; margin-bottom:10px;">
      Profile created, welcome!
    </div>
    <div style="color:#b7c3ff; font-size:1rem; margin-bottom:22px;">
      Get comfortable and enjoy the experience.
    </div>

    <div style="display:flex; justify-content:flex-end;">
      <button class="tool-btn primary" onclick="closeModal('welcomeModal')">Close</button>
    </div>
  </div>
</div>


<div id="assetBrowserModal" class="modal-overlay">
    <div class="modal-box">
      <button class="modal-close" onclick="closeModal('assetBrowserModal')">&times;</button>
      
      <div class="browser-header">
        <div class="browser-header-left">
          <h2 id="browserTitle">Collection</h2>
          <div id="assetCountLabel" class="asset-count-label">0 assets</div>
        </div>
        <div class="browser-header-controls">
          <label for="propertyFilterSelect" class="browser-label">Filter:</label>
          <select id="propertyFilterSelect" class="browser-select">
            <option value="ALL">All properties</option>
          </select>
          <label for="assetPageSizeSelect" class="browser-label">Show:</label>
          <select id="assetPageSizeSelect" class="browser-select">
            <option value="10" selected>10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </div>
      </div>
      <div class="asset-grid" id="assetGrid"></div>
    </div>
  </div>

<div id="combineNameModal" class="modal-overlay" style="z-index: 6000;">
    <div class="modal-box" style="max-width: 400px; text-align: center;">
        <h2 style="color: #fff; margin-bottom: 20px;">Name Combination</h2>
        <input type="text" id="combineNameInput" class="glass-input" placeholder="e.g. My Series 1" style="text-align:center;">
        <div class="modal-actions">
            <button class="tool-btn" onclick="closeModal('combineNameModal')">Cancel</button>
            <button class="tool-btn primary" onclick="executeCombine()">Save Combination</button>
        </div>
    </div>
</div>

<div id="addOrNewModal" class="modal-overlay" style="z-index: 6000;">
    <div class="modal-box" style="max-width: 450px; text-align: center;">
        <h2 style="color: #fff; margin-bottom: 15px;">Combine Groups</h2>
        <p style="color: #a3b1c6; margin-bottom: 25px;">You have selected multiple existing groups.</p>
        
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button class="tool-btn" onclick="executeAddTo()" style="flex:1; justify-content:center;">
                <i class="fas fa-folder-plus"></i> + Add To First
            </button>
            <button class="tool-btn primary" onclick="startNewCombineFlow()" style="flex:1; justify-content:center;">
                <i class="fas fa-plus-circle"></i> + New Group
            </button>
        </div>
        <div style="margin-top: 15px;">
            <button class="tool-btn" onclick="closeModal('addOrNewModal')" style="width: 100%; justify-content: center; border:none;">Cancel</button>
        </div>
    </div>
</div>

<div id="deleteWarningModal" class="modal-overlay" style="z-index: 6000;">
    <div class="modal-box" style="max-width: 400px; text-align: center;">
        <i class="fas fa-exclamation-triangle warn-icon"></i>
        <h2 style="color: #fff; margin-bottom: 10px;">Delete Collection?</h2>
        <p style="color: #a3b1c6; line-height: 1.5;">
            This action is <b>irreversible</b>.<br>
            The selected policies will be permanently removed from your profile and server storage.
        </p>
        <div class="modal-actions">
            <button class="tool-btn" onclick="closeModal('deleteWarningModal')">Go Back</button>
            <button class="tool-btn danger" style="background: rgba(255, 107, 107, 0.2); color: #ff6b6b; border: 1px solid #ff6b6b;" onclick="executeDelete()">Permanently Delete</button>
        </div>
    </div>
</div>
<div id="pushOptionsModal" class="modal-overlay" style="z-index: 6100;">
    <div class="modal-box" style="max-width: 600px; text-align: center; padding: 40px;">
        <button class="modal-close" onclick="closeModal('pushOptionsModal')">&times;</button>
        <h2 style="color: #fff; margin-bottom: 10px;">Sign to Push Public</h2>
        <p style="color: #8899ac; margin-bottom: 25px; font-size: 1rem;">
            Your changes are saved locally (Draft).<br>
            Select what you want to push to your live public page.
        </p>
        
        <div id="pushButtonsContainer">
            <button class="push-opt-btn" onclick="triggerSignAndPush('profile')">
                <span>Push Profile Data Only</span> <i class="fas fa-user-circle"></i>
            </button>
            <button class="push-opt-btn" onclick="triggerSignAndPush('dashboard')">
                <span>Push Dashboard/Assets Only</span> <i class="fas fa-th"></i>
            </button>
            <button class="push-opt-btn highlight" onclick="triggerSignAndPush('both')">
                <span>Push Everything</span> <i class="fas fa-check-double"></i>
            </button>
        </div>

        <div id="pushStatusMsg" style="margin-top: 30px; display: none;">
            <i class="fas fa-circle-notch fa-spin" style="font-size: 2rem; color: var(--accent); margin-bottom: 15px;"></i>
            <div style="font-size: 1.1rem; color: #fff; font-weight: bold;">Waiting for approval...</div>
            <p style="color: #8899ac; font-size: 0.9rem; margin-top: 5px;">Please sign the request in your wallet.</p>
        </div>
    </div>
</div>

<div id="assetDetailModal" class="modal-overlay" style="z-index:3100;">
    <div class="modal-box" style="max-width: 600px; height: auto; max-height: 90vh; text-align: center;">
        <button class="modal-close" onclick="closeModal('assetDetailModal')">&times;</button>
        <div id="detailContent"></div>
    </div>
</div>

<div id="mediaFsOverlay">
  <button id="mediaFsClose" aria-label="Close fullscreen" onclick="closeMediaFullscreen()">&times;</button>
  <div id="mediaFsHost"></div>
</div>


  
<div id="importModal" class="modal-overlay">
    <div class="modal-box">
        <button class="modal-close" onclick="closeModal('importModal')">&times;</button>
        <h2>Import Policy</h2>
        <div class="tabs">
            <button class="tab active" onclick="switchImportTab('tabKeys')">Import Keys</button>
            <button class="tab" onclick="switchImportTab('tabClaim')">Claim ID</button>
        </div>
        
        <div id="tabKeys">
            <p style="color:#8899ac; font-size:0.9rem; margin-bottom:15px;">Paste policy JSON. Assets will be scanned.</p>
            <label class="input-label">Name</label>
            <input type="text" id="importName" class="glass-input">
            <label class="input-label">Policy JSON</label>
            <textarea id="importJson" class="glass-input" style="height:120px; font-family:monospace;"></textarea>
            <button class="btn-action" id="confirmImportBtn">Import & Scan</button>
        </div>

        <div id="tabClaim" class="hidden">
            <p style="color:#8899ac; font-size:0.9rem; margin-bottom:15px;">Submit a Policy ID for verification.</p>
            <label class="input-label">Policy ID</label>
            <input type="text" id="claimPolicyId" class="glass-input" placeholder="e.g. 1d1b34...">
            <button class="btn-action" id="confirmClaimBtn" style="background: linear-gradient(135deg, #FF9800, #F44336);">Submit Claim</button>
        </div>
    </div>
  </div>

<div id="studioOverlay" style="display:none; position:fixed; inset:0; z-index:99999; background:#050810;">
  <div style="height:56px; display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,0.12);">
    <div style="color:#e4e8ff; font-weight:700;">Creator Studio</div>
    <button class="tool-btn" onclick="closeMintStudio()"><i class="fas fa-times"></i> Close</button>
  </div>
  <footer style=z-index:4000;>
    <div style="margin-bottom:10px;z-index:4000;">
    <span id="siteseal"><script async type="text/javascript" src="https://seal.godaddy.com/getSealPremium?sealID=QF1s1BQAHMBe4jzn7hJCsrfWSznQEcTzWLmHMCP6maSrmRCo9TAkEERgWszd"></script></span>
    </div>
    &copy; The ReFre5h cNFT 2026
</footer>
  <iframe id="studioFrame" src="about:blank" style="width:100%; height:calc(100% - 56px); border:0;"></iframe>
</div>

<div class="modal-overlay" id="metaEditorModal" style="z-index:5000;">
    <div class="modal-box" style="width:90%; max-width:800px;">
        <div class="modal-title" style="margin-bottom:10px; color:#fff; font-weight:bold;">Metadata Editor</div>
        <textarea class="json-editor" id="jsonEditorArea" style="width:100%; height:300px; background:#000; color:#0f0; font-family:monospace; border:1px solid #333; padding:10px;" spellcheck="false"></textarea>
        <div id="jsonError" style="color:#ff6b6b; display:none; margin-top:5px;"></div>
        <div class="row" style="justify-content:flex-end; margin-top:15px; display:flex; gap:10px;">
            <button class="secondary" id="metaEditorBackBtn" onclick="closeModal('metaEditorModal')">Go Back</button>
            <button id="metaEditorSaveBtn" onclick="saveJsonEdit()">Save</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="colorModal" style="z-index:5100;">
    <div class="modal-box" style="width:400px;">
        <h3 style="color:#fff;">Color Presets</h3>
        <div class="col" style="gap:10px; margin:15px 0; display:flex; flex-direction:column;">
            <label class="check-wrap"><input type="radio" name="hexType" value="single" checked> Single Color</label>
            <label class="check-wrap"><input type="radio" name="hexType" value="random"> Random Generator</label>
            <label class="check-wrap"><input type="radio" name="hexType" value="gradient"> Gradient</label>
            <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); width:100%;">
            <label class="check-wrap"><input type="checkbox" id="useMyVar"> Use Variable</label>
            <div id="varInputArea" style="display:none; padding-left:20px;">
                 <input type="text" id="varName" class="glass-input" placeholder="Variable Name">
                 <select id="varType" class="browser-select"><option value="const">const</option><option value="let">let</option></select>
            </div>
        </div>
        <div class="row" style="justify-content:flex-end; display:flex; gap:10px;">
            <button class="secondary" onclick="closeModal('colorModal')">Cancel</button>
            <button onclick="applyColorPreset()">Apply</button>
        </div>
    </div>
</div>

<script type="module">
import {
  BrowserWallet,
  Transaction,
  ForgeScript,
  resolveScriptHash,
  resolveNativeScriptHash,
  resolvePaymentKeyHash,
  resolveSlotNo
} from '/meshsdk-core-1.9.0-b62.js';

   

    // ==========================================
    // 1. GLOBALS & CONFIG
    // ==========================================
    let meshWallet = null;
    let currentUser = { address: null, identity: null, username: null, role: 'artist' }; // Default to artist
    let _collectorFirstSaveNeedsAutoPush = false;
    let connectedWalletName = "Wallet";
    let currentTab = 'collections';
    let walletPolicies = [];         // Stores the raw data
    let walletFilteredPolicies = [];
    let walletCatFilter = 'ALL';
    let walletPageSize = 4;
    let walletPageIndex = 0;
    let cachedWalletCollections = []; // Stores the full list for lazy loading
    let displayedWalletCollections = [];
    let currentWalletCategory = 'NFT';
    let isWalletLoading = false;
    let hasUnsavedChanges = false;
    let isWalletSyncRunning = false; // Prevents overlapping sync runs
    let hasSyncedThisSession = false;
    let previousWalletHash = '';
    let dirtyFlags = { profile: false, dashboard: false };
    function syncMainSaveHighlight(){
      const btn = getEl('btnMainSave');
      if (!btn) return;
      btn.classList.toggle('active', !!(dirtyFlags.profile || dirtyFlags.dashboard));
    }

    
    /* ===========================
   WALLET + SIGNING (CIP-30)
   - No tx build
   - No ADA fee
   =========================== */

window.fre5hGateState = window.fre5hGateState || null;

// --- small utils ---
function utf8ToHex(str) {
  const bytes = new TextEncoder().encode(str);
  return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
}

function randomNonceHex(byteLen = 16) {
  const a = new Uint8Array(byteLen);
  crypto.getRandomValues(a);
  return Array.from(a, b => b.toString(16).padStart(2, '0')).join('');
}

function listCip30Wallets() {
  const c = window.cardano;
  if (!c || typeof c !== 'object') return [];
  return Object.keys(c)
    .filter(k => c[k] && typeof c[k].enable === 'function')
    .sort((a, b) => a.localeCompare(b));
}

async function enableWallet(walletKey) {
  const w = window.cardano?.[walletKey];
  if (!w || typeof w.enable !== 'function') {
    throw new Error(`Wallet not found or not CIP-30: ${walletKey}`);
  }
  // Keep it minimal: no extensions required for signData.
  return await w.enable();
}

// Prefer reward address as “identity”; fall back to a used/change address.
// NOTE: These are returned as HEX strings by CIP-30.
async function getWalletIdentityHex(api) {
  // Some wallets support reward addresses (stake key identity)
  if (typeof api.getRewardAddresses === 'function') {
    const rewards = await api.getRewardAddresses();
    if (Array.isArray(rewards) && rewards.length) return rewards[0];
  }

  // Fall back to a used address
  if (typeof api.getUsedAddresses === 'function') {
    const used = await api.getUsedAddresses();
    if (Array.isArray(used) && used.length) return used[0];
  }

  // Final fallback: change address
  if (typeof api.getChangeAddress === 'function') {
    const ch = await api.getChangeAddress();
    if (typeof ch === 'string' && ch) return ch;
  }

  throw new Error('Unable to derive an identity address from this wallet.');
}

const LS_LAST_WALLET = 'idp_last_wallet_key';

function getWalletMeta(walletKey){
  const w = window.cardano?.[walletKey];
  return {
    key: walletKey,
    name: (w && (w.name || w.apiName)) ? (w.name || w.apiName) : walletKey,
    icon: (w && typeof w.icon === 'string') ? w.icon : ''
  };
}

async function connectWalletByKey(walletKey){
  const api = await enableWallet(walletKey);
  const identityHex = await getWalletIdentityHex(api);

  // keep your existing variable usage consistent
  meshWallet = api;

  // NEW: also derive BECH32 identity/address using Mesh BrowserWallet
  let stakeBech32 = '';
  let addrBech32 = '';
  try {
    const bw = await BrowserWallet.enable(walletKey);

    const rewards = await bw.getRewardAddresses();
    if (Array.isArray(rewards) && rewards.length) stakeBech32 = rewards[0] || '';

    const used = await bw.getUsedAddresses();
    if (Array.isArray(used) && used.length) addrBech32 = used[0] || '';

    if (!addrBech32 && typeof bw.getChangeAddress === 'function') {
      addrBech32 = await bw.getChangeAddress();
    }
  } catch (e) {
    console.warn('BrowserWallet bech32 derivation failed, falling back to hex identity only', e);
  }

  // NEW: set the app’s user identity/address using BECH32 when available
  currentUser.identity = stakeBech32 || identityHex;
  currentUser.address  = addrBech32  || stakeBech32 || identityHex;

  // NEW: keep hidden fields in sync (your profile flow reads these)
  const stakeEl = getEl('hiddenStakeKey');
  const addrEl  = getEl('hiddenWalletAddress');
  if (stakeEl) stakeEl.value = currentUser.identity;
  if (addrEl)  addrEl.value  = currentUser.address;

  // keep using your app’s “truth” object
  window.fre5hGateState = {
    walletKey,
    api,
    identityHex,               // for signData
    identity: currentUser.identity, // for profile lookup (bech32 preferred)
    address: currentUser.address     // for profile lookup (bech32 preferred)
  };

  // remember for new tabs
  localStorage.setItem(LS_LAST_WALLET, walletKey);

 // OPTIONAL: if you already have a post-connect pipeline, call it
  if (typeof window.checkUser === 'function') {
    try { await window.checkUser(); } catch (e) { console.warn('checkUser failed', e); }
  }
  
  // FIX: Explicitly start the Studio Logic
  if (typeof window.initStudio === 'function') {
      console.log("Starting Studio..."); 
      await window.initStudio();
  }
}


function disconnectWallet(){
  meshWallet = null;
  window.fre5hGateState = null;
  localStorage.removeItem(LS_LAST_WALLET);

  // close dropdown if open
  const wDrop = getEl('walletDropdown');
  if (wDrop) wDrop.classList.remove('show');
}

document.addEventListener('click', (e) => {
  const wWrap = getEl('walletMenu');
  const wDrop = getEl('walletDropdown');
  if (!wDrop || !wDrop.classList.contains('show')) return;
  if (!wWrap || !wWrap.contains(e.target)) wDrop.classList.remove('show');
});


function renderWalletDropdown(){
  const dd = getEl('walletDropdown');
  if (!dd) return;

  const keys = listCip30Wallets();
  dd.innerHTML = '';

  if (!keys.length){
    dd.innerHTML = `<div class="menu-item"><i class="fas fa-wallet"></i><span>No wallets found</span></div>`;
    return;
  }

  for (const k of keys){
    // NEW: Skip generating the HTML if the wallet is Nami
    if (k === 'nami') continue;

    const meta = getWalletMeta(k);
    const item = document.createElement('div');
    item.className = 'menu-item';

    // Use formatWalletName for capitalization (e.g. eternl -> Eternl)
    const dispName = formatWalletName(meta.name);

    item.innerHTML = meta.icon
      ? `<img src="${meta.icon}" alt=""><span>${dispName}</span>`
      : `<i class="fas fa-wallet"></i><span>${dispName}</span>`;

    item.onclick = async (ev) => {
      ev.stopPropagation();
      await connectWalletByKey(k);
      dd.classList.remove('show');
    };

    dd.appendChild(item);
  }

  // Add Disconnect Row if connected
  if (window.fre5hGateState?.api){
    const hr = document.createElement('div');
    hr.style.height = '1px';
    hr.style.margin = '8px 0';
    hr.style.background = 'rgba(255,255,255,0.08)';
    dd.appendChild(hr);

    const disc = document.createElement('div');
    disc.className = 'menu-item';
    disc.innerHTML = `<i class="fas fa-plug"></i><span>Disconnect</span>`;
    disc.onclick = (ev) => {
      ev.stopPropagation();
      disconnectWallet();
    };
    dd.appendChild(disc);
  }
}

// For signData, many wallets accept *any* address you control.
// We’ll sign with the same identity address we derived above.
async function signWithWallet(api, addressHex, messageStr) {
  if (typeof api.signData !== 'function') {
    throw new Error('This wallet does not support signData (CIP-8/CIP-30).');
  }

  // Sign a structured message with a nonce to prevent replay.
  // You can change the prefix to match your app.
  const nonce = randomNonceHex(16);
  const message = `${messageStr}\nnonce=${nonce}\nts=${new Date().toISOString()}`;

  const payloadHex = utf8ToHex(message);

  // CIP-30: signData(addressHex, payloadHex) -> { signature, key }
  const signed = await api.signData(addressHex, payloadHex);

  return {
    message,       // plain text you asked to sign (includes nonce + ts)
    payloadHex,    // hex bytes that were signed
    signature: signed?.signature || null,
    key: signed?.key || null,
    nonce
  };
}

    const getEl = (id) => document.getElementById(id);
    // --- MODAL HELPERS (required by inline onclick="openModal(...)" calls) ---
window.openModal = window.openModal || function (modalId) {
  const m = getEl(modalId);
  if (!m) return;
  m.style.display = 'flex';
};

window.closeModal = window.closeModal || function (modalId) {
  const m = getEl(modalId);
  if (!m) return;
  m.style.display = 'none';
};



    
    // --- IPFS gateway + retry config ---
const IPFS_GATEWAYS = [
  "https://w3s.link",
  "https://dweb.link",
  "https://cloudflare-ipfs.com",
  "https://ipfs.io",
  "https://gateway.pinata.cloud"
];

// Thumbnail max size (use for ALL grid thumbs / previews)
const THUMB_MAX = 320;

// Timeouts (ms)
const THUMB_LOAD_TIMEOUT_MS  = 3500;  // fast-fail for grid thumbs
const DETAIL_LOAD_TIMEOUT_MS = 9000;  // longer for single-asset view
// ==========================================
// HERO (Landing Page)
// ==========================================
const HERO_FEED_URL = 'hero_feed.php';
const HERO_ROTATE_MS = 50000;
const HERO_MAX_ITEMS = 8;

let heroItems = [];
let heroActiveIdx = 0;
let heroTimer = null;



    // State
// State
    let currentCollection = null;
    let currentCollectionAssetsSummary = [];
    
    // --- LAZY LOAD STATE ---
    let colBatchList = [];      // Stores the full list of collections to display
    let colBatchIndex = 0;      // Tracks how many we have rendered
    let colPageSize = 4;  // How many to load at once (max 2 rows on desktop)
    let colBatchLoading = false;
    let currentCollectionAssetsDetail = [];
    let assetPageSize = 10;
    let assetPageIndex = 0;
    let isAssetPageLoading = false;
    let activePropertyFilterPair = 'ALL';
    let selectedToDelete = new Set();
    const attemptedSyncs = new Set();
    let isDeleteMode = false;
    let isCombineMode = false;
    let selectedToCombine = new Set();
    let currentGroupViewId = null; // If set, we are inside a combined folder
    const traitPairsSet = new Set();
    const TRAIT_SKIP = [
      'image','src','files','mediatype','name','description',
      'assetName','asset_name','asset','policy_id','policyId',
      'collection','project','publisher','copyright',
      'artist','artists','creator','creators','author', 
      'twitter','website','social','discord','instagram'
    ];
    
    // Extract simple key/value traits from on-chain metadata
    function extractTraitsFromMeta(meta) {
      const traits = {};
      if (!meta || typeof meta !== 'object') return traits;
      
      for (const [k, v] of Object.entries(meta)) {
        // 1. Normalize key for checking exclusion
        const lowerK = k.toLowerCase().trim();
        
        // 2. Strict exclusion check
        if (TRAIT_SKIP.includes(lowerK)) continue;
        
        if (v === null || v === undefined) continue;
        if (typeof v === 'object') continue; // skip nested objects/arrays
        
        traits[k] = String(v);
      }
      return traits;
    }
    
    
function buildMediaPreviewInto(meta, containerEl, fallbackSrc, enableControls = false, isThumb = false) {
  if (!containerEl) return;
  containerEl.innerHTML = '';

  // --- HELPER 1: IFRAME ---
const showIframe = (src) => {
    const iframe = document.createElement('iframe');
    const url = formatUrl(src);
    setIframeSrcWithGateways(iframe, url);
    iframe.loading = 'lazy';
    iframe.className = 'thumb-media thumb-media-html';

    // Only apply the scaler if this is a thumbnail view
    if (isThumb) {
        const wrapper = document.createElement('div');
        wrapper.className = 'html-thumb-wrapper';
        wrapper.appendChild(iframe);
        containerEl.appendChild(wrapper);
    } else {
        // Single asset view (full size, no scaling)
        containerEl.appendChild(iframe);
    }
  };

  // --- HELPER 2: IMAGE ---
const showImage = (src) => {
    const img = document.createElement('img');
    img.loading = "lazy";
    img.decoding = "async";
    const url = formatUrl(src);
    setImgSrcWithGateways(img, url, isThumb);
    img.className = 'thumb-media thumb-media-img';
    containerEl.appendChild(img);
  };


// --- HELPER 3: VIDEO (The "Kitchen Sink" Version) ---
const showVideo = (src) => {
    const v = document.createElement('video');
    v.className = 'thumb-media thumb-media-video';
    
    // Attributes
    v.setAttribute('playsinline', '');
    v.setAttribute('muted', '');
    v.setAttribute('loop', '');
    
    // IMPORTANT: If enableControls is FALSE (Thumbnails), do NOT autoplay.
    if (enableControls) {
        v.controls = true;
    } else {
        v.controls = false;
        v.autoplay = false; // Strictly False
        // Do NOT set v.setAttribute('autoplay', '')
    }
    
    setVideoSrcWithGateways(v, formatUrl(src));
    containerEl.appendChild(v);
};
  

  // --- MAIN LOGIC FLOW ---
  if (!meta || typeof meta !== 'object') {
    if (fallbackSrc) showImage(fallbackSrc);
    return;
  }

  // 1. Check Files Array for Source
  let fileSrc = '';
  let fileType = '';

  if (Array.isArray(meta.files) && meta.files.length > 0) {
    const f0 = meta.files[0];
    if (f0 && typeof f0 === 'object') {
      fileType = (f0.mediaType || '').toLowerCase();
      if (typeof f0.src === 'string') {
        fileSrc = f0.src;
      } else if (Array.isArray(f0.src)) {
        fileSrc = f0.src.filter(v => typeof v === 'string').join('');
      }
    }
  }

  // 2. Route by Type (Using formatted URLs inside helpers)
  if (fileSrc) {
    
// Check for 'html' in type OR src (covers file extensions and data URIs)
    if (fileType.includes('html') || fileSrc.includes('html') || fileSrc.startsWith('data:text/html')) {
      showIframe(fileSrc);
      return;
    }
// UPDATED: Check for 'video' in type OR common extensions in src
    if (fileType.includes('video') || fileSrc.includes('.mp4') || fileSrc.includes('.webm') || fileSrc.includes('.mov') || fileSrc.startsWith('data:video/')) {
      showVideo(fileSrc);
      return;
    }
    if (fileType.includes('image')) { // changed from startsWith
      showImage(fileSrc);
      return;
    }
  }

  // 4. Fallback: Check direct 'image' field if no files found
// 4. Fallback: Check direct 'image' field if no files found
  let imgField = meta.image;
  if (Array.isArray(imgField)) {
    imgField = imgField.filter(v => typeof v === 'string').join('');
  }

  if (typeof imgField === 'string' && imgField) {
    // UPDATED: Check if the 'image' field is actually a video
    if (imgField.includes('.mp4') || imgField.includes('.webm') || imgField.includes('.mov') || imgField.startsWith('data:video/')) {
         showVideo(imgField);
         return;
    }

    // If image field looks like data URI or URL, render it
    const formattedImg = formatUrl(imgField);
    if (
      formattedImg.startsWith('data:image/') ||
      /^https?:\/\//i.test(formattedImg) ||
      formattedImg.startsWith('ipfs://')
    ) {
      showImage(formattedImg);
      return;
    }
  }

  // 5. Final Fallback
  if (fallbackSrc) {
    showImage(fallbackSrc);
  }
}

 function refreshPropertyFilterOptions() {
  const sel = getEl('propertyFilterSelect');
  if (!sel) return;

  const current = sel.value || 'ALL';
  
  // Sort the "Key: Value" strings alphabetically
  const options = Array.from(traitPairsSet).sort((a, b) => a.localeCompare(b));

  sel.innerHTML =
    '<option value="ALL">All properties</option>' +
    options.map(str => {
       const label = str.replace('|||', ': '); 
       return `<option value="${str}">${label}</option>`;
    }).join('');

  if ([...sel.options].some(o => o.value === current)) {
    sel.value = current;
  } else {
    sel.value = 'ALL';
    activePropertyFilterPair = 'ALL';
  }
}

// Fetch and cache full on-chain detail for asset index
async function fetchAssetDetailForIndex(idx) {
  if (!currentCollectionAssetsSummary[idx]) return null;
  if (currentCollectionAssetsDetail[idx]) return currentCollectionAssetsDetail[idx];

  const summary = currentCollectionAssetsSummary[idx];
  const unit = summary.asset || ((summary.policy_id || '') + (summary.asset_name || ''));

  if (!unit) return null;

  // --- 1. TRY READING FROM CACHE FIRST ---
  if (summary.traits && typeof summary.traits === 'object') {
    const meta = summary.onchain_metadata || summary.metadata || {};
    let cachedName = '';
    
    if (meta && typeof meta.name === 'string' && meta.name.trim()) {
        cachedName = meta.name.trim();
    } else {
        let rawName = summary.name || summary.asset_name || '';
        if (rawName && !/[g-zG-Z]/.test(rawName) && /^[0-9a-fA-F]+$/.test(rawName)) {
            cachedName = hexToAsciiSafe(rawName);
        } else {
            cachedName = rawName;
        }
    }
    
    if (!cachedName) cachedName = "Asset";

    const obj = { 
        unit: unit, 
        meta: meta, 
        displayName: cachedName, 
        traits: summary.traits, 
        raw: summary 
    };

    // Update Filters
    let added = false;
    for (const [k, v] of Object.entries(obj.traits)) {
      const pairStr = `${k}|||${v}`;
      if (!traitPairsSet.has(pairStr)) {
        traitPairsSet.add(pairStr);
        added = true;
      }
    }
    if (added) refreshPropertyFilterOptions();

    currentCollectionAssetsDetail[idx] = obj;
    return obj;
  }

  // --- 2. FETCH FROM API IF NOT IN CACHE ---
  try {
    const res = await fetch(`get_asset_detail.php?asset=${encodeURIComponent(unit)}`);
    if (!res.ok) return null;
    const detail = await res.json();

    const meta = (detail.onchain_metadata && typeof detail.onchain_metadata === 'object'
        ? detail.onchain_metadata
        : (detail.metadata && typeof detail.metadata === 'object' ? detail.metadata : {}));

    let displayName = '';
    if (meta && typeof meta.name === 'string' && meta.name.trim()) {
      displayName = meta.name.trim();
    } else {
      const hex = detail.asset_name || summary.asset_name || '';
      displayName = hexToAsciiSafe(hex) || unit;
    }

    const traits = extractTraitsFromMeta(meta);
    const obj = { unit, meta, displayName, traits, raw: detail };

    let added = false;
    for (const [k, v] of Object.entries(traits)) {
      const pairStr = `${k}|||${v}`;
      if (!traitPairsSet.has(pairStr)) {
        traitPairsSet.add(pairStr);
        added = true;
      }
    }
    if (added) refreshPropertyFilterOptions();
    
    currentCollectionAssetsDetail[idx] = obj;
    return obj;
  } catch (err) {
    console.error('Failed to fetch asset detail', err);
    return null;
  }
}

function resetAndRenderAssetGrid() {
  const grid = getEl('assetGrid');
  if (!grid) return;
  grid.innerHTML = '';
  assetPageIndex = 0;
  isAssetPageLoading = false;
  renderNextAssetPage();
}

async function renderNextAssetPage() {
    if (!currentCollectionAssetsSummary.length) return;
    if (isAssetPageLoading) return;
    isAssetPageLoading = true;

    const grid = getEl('assetGrid');
    if (!grid) {
        isAssetPageLoading = false;
        return;
    }

    // --- NEW: Calculate Total Matches for Current Filter ---
    // We need to know the total matches to show "50 of 500 (10%)"
    // Since we filter on the fly, we do a quick pass here to count them.
    let totalMatches = 0;
    const totalAssets = currentCollectionAssetsSummary.length;

    // If filter is ALL, matches = total
    if (activePropertyFilterPair === 'ALL') {
        totalMatches = totalAssets;
    } else {
        // Quick count loop
        const [fKey, fVal] = activePropertyFilterPair.split('|||');
        // We use the 'currentCollectionAssetsDetail' if available, otherwise we might miss data 
        // BUT since we did Deep Scan, 'currentCollectionAssetsSummary' HAS traits!
        for (const asset of currentCollectionAssetsSummary) {
             if (asset.traits && asset.traits[fKey] === fVal) {
                 totalMatches++;
             }
        }
    }

    // Update the Label UI
    updateAssetCountLabel(totalMatches, totalAssets);
    // -------------------------------------------------------

    let added = 0;
    let i = assetPageIndex;

    // Main Render Loop (This draws the cards)
    while (i < totalAssets && added < assetPageSize) {
        const idx = i;
        i++;

        // Get asset data (Deep Scan means this is fast/instant)
        const assetObj = await fetchAssetDetailForIndex(idx);
        if (!assetObj) continue;

        // Apply Filter
        if (activePropertyFilterPair !== 'ALL') {
            const [fKey, fVal] = activePropertyFilterPair.split('|||');
            if (!assetObj.traits || assetObj.traits[fKey] !== fVal) {
                continue;
            }
        }

        const card = document.createElement('div');
        card.className = 'asset-card';

        const thumbDiv = document.createElement('div');
        thumbDiv.className = 'asset-thumb-wrap';
        buildMediaPreviewInto(assetObj.meta, thumbDiv, '../fre5hfence/RF5.png?v=2', false, true);

        const nameDiv = document.createElement('div');
        nameDiv.className = 'asset-name';
        nameDiv.textContent = assetObj.displayName;


        const traitsBox = document.createElement('div');
        traitsBox.className = 'asset-traits';
        
        if (assetObj.traits) {
          for (const [k, v] of Object.entries(assetObj.traits)) {
            const row = document.createElement('div');
            row.className = 'detail-meta-row';
            row.innerHTML = `<span class="trait-k">${k}</span><span class="trait-v">${v}</span>`;
            traitsBox.appendChild(row);
          }
        }

        card.appendChild(thumbDiv);
        card.appendChild(nameDiv);
        if (assetObj.traits && Object.keys(assetObj.traits).length) {
          card.appendChild(traitsBox);
        }

        card.onclick = () => openAssetDetailFromDetailObj(assetObj);

        grid.appendChild(card);
        added++;
    }

    assetPageIndex = i;
    isAssetPageLoading = false;
    
        // If the grid isn't scrollable yet (common for image-only collections),
    // auto-load additional pages until it becomes scrollable or we run out.
    requestAnimationFrame(() => {
        if (isAssetPageLoading) return;
        if (!currentCollectionAssetsSummary) return;
        if (assetPageIndex >= currentCollectionAssetsSummary.length) return;

        // No overflow => no scroll event can fire
        if (grid.scrollHeight <= grid.clientHeight + 5) {
            renderNextAssetPage();
        }
    });

}

function openAssetDetailFromDetailObj(assetObj) {
    const modal = getEl('assetDetailModal');
    const dContent = getEl('detailContent');
    if (!modal || !dContent) return;

    const traits = assetObj.traits || {};
    const traitsHtml = Object.entries(traits).map(([k,v]) =>
        `<div class="detail-meta-row">
            <span style="color:#8899ac;">${k}</span>
            <span style="font-family:monospace; color:#fff;">${v}</span>
         </div>`
    ).join('');

    // Build the whole layout ONCE (no innerHTML += after media is created)
dContent.innerHTML = `
  <div id="dMedia" style="height:300px; margin-bottom:15px; width:100%;"></div>

  <div class="detail-title-row">
    <h2 id="dTitle" style="margin:0;"></h2>
    <button type="button" id="btnMediaFs" onclick="openMediaFullscreen()" title="Fullscreen">
      <i class="fas fa-expand"></i>
    </button>
  </div>

  <div id="dTraits" style="text-align:left; background:rgba(255,255,255,0.05); padding:15px; border-radius:12px;"></div>
`;


    const titleEl = getEl('dTitle');
    if (titleEl) titleEl.textContent = assetObj.displayName || 'Asset';

    const traitsEl = getEl('dTraits');
    if (traitsEl) traitsEl.innerHTML = traitsHtml.length
        ? traitsHtml
        : '<div style="text-align:center; color:#666;">No traits found</div>';

    // Now inject the media (and DO NOT overwrite dContent afterwards)
    buildMediaPreviewInto(assetObj.meta, getEl('dMedia'), '../fre5hfence/RF5.png?v=2', true, false);

    modal.style.display = 'flex';
}

let _fsMediaNode = null;
let _fsReturnParent = null;
let _fsReturnNext = null;
let _fsPrevBodyOverflow = '';

window.openMediaFullscreen = function () {
  const overlay = getEl('mediaFsOverlay');
  const host = getEl('mediaFsHost');
  const dMedia = getEl('dMedia');
  if (!overlay || !host || !dMedia) return;

  const media = dMedia.querySelector('iframe, video, img');
  if (!media) return;

  _fsMediaNode = media;
  _fsReturnParent = media.parentNode;
  _fsReturnNext = media.nextSibling;

  host.innerHTML = '';
  host.appendChild(media);

  _fsPrevBodyOverflow = document.body.style.overflow;
  document.body.style.overflow = 'hidden';

  overlay.classList.add('show');

  // keep videos alive if possible
  if (media.tagName === 'VIDEO') {
    try { media.play(); } catch {}
  }
};

window.closeMediaFullscreen = function () {
  const overlay = getEl('mediaFsOverlay');
  const host = getEl('mediaFsHost');

  if (!overlay) return;

  // If we have a node, return it to original location (or dMedia as fallback)
  if (_fsMediaNode) {
    const fallback = getEl('dMedia');
    const targetParent =
      (_fsReturnParent && document.contains(_fsReturnParent)) ? _fsReturnParent : fallback;

    if (targetParent) {
      if (_fsReturnNext && document.contains(_fsReturnNext)) {
        targetParent.insertBefore(_fsMediaNode, _fsReturnNext);
      } else {
        targetParent.appendChild(_fsMediaNode);
      }
    }
  }

  if (host) host.innerHTML = '';
  overlay.classList.remove('show');

  document.body.style.overflow = _fsPrevBodyOverflow || '';

  _fsMediaNode = null;
  _fsReturnParent = null;
  _fsReturnNext = null;
  _fsPrevBodyOverflow = '';
};

// ESC closes fullscreen (does not interfere with your modal close buttons)
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const overlay = getEl('mediaFsOverlay');
    if (overlay && overlay.classList.contains('show')) {
      closeMediaFullscreen();
    }
  }
});


    // ==========================================
    // 2. UTILITY FUNCTIONS
    // ==========================================

// --- URL FORMATTER ---
const formatUrl = (url) => {
  if (!url || typeof url !== 'string') return '';
  const u = url.trim();

  // 1) Data URIs unchanged
  if (u.startsWith('data:')) return u;

  // 2) Arweave schemes: ar://... or arweave://...
  if (u.startsWith('ar://') || u.startsWith('arweave://')) {
    const suffix = u
      .replace(/^arweave:\/\//i, '')
      .replace(/^ar:\/\//i, '')
      .replace(/^\/+/, '');
    return 'https://arweave.net/' + suffix;
  }

  // 3) Bare Arweave txid (+ optional /path)
  //    (Common: metadata stores only the txid)
  if (/^[a-z0-9_-]{43}(\/.*)?$/i.test(u)) {
    return 'https://arweave.net/' + u.replace(/^\/+/, '');
  }

  // 4) Keep ipfs:// as ipfs:// (gateway selection happens later)
  if (u.startsWith('ipfs://')) {
    const suffix = u
      .replace(/^ipfs:\/\//i, '')
      .replace(/^ipfs\//i, '')
      .replace(/^\/+/, '');
    return 'ipfs://' + suffix;
  }

  // 5) Already http(s)
  if (u.startsWith('http://') || u.startsWith('https://')) return u;

  // 6) Bare CID -> treat as IPFS (gateway selection happens later)
  if (u.startsWith('Qm') || u.startsWith('bafy')) {
    return 'ipfs://' + u.replace(/^\/+/, '');
  }

  // 7) Generic “missing protocol” host/path
  if (/^[a-z0-9.-]+\.[a-z]{2,}(\/|$)/i.test(u)) {
    return 'https://' + u;
  }

  return u;
};

(() => {
  const m = getEl('welcomeModal');
  if (!m) return;
  m.addEventListener('click', (e) => {
    if (e.target === m) closeModal('welcomeModal');
  });
})();


// --- ADD THIS HELPER FUNCTION ---
window.handleNavEdit = () => {
    // 1. Close Dropdown
    const drop = document.getElementById('profileDropdown');
    if(drop) drop.style.display = 'none';

    // 2. Check if we are currently on the Landing Page
    const dash = document.getElementById('dashboardRoot');
    const isLanding = dash.classList.contains('hidden');

    if (isLanding) {
        // Set a flag so we know to return to the landing page after saving/canceling
        window._returnToLanding = true;
        
        // Switch views manually
        document.getElementById('landingPage').classList.add('hidden');
        dash.classList.remove('hidden');
    } else {
        window._returnToLanding = false;
        
    }

    // 3. Trigger the existing Edit Mode logic
    const trigger = document.getElementById('triggerEditBtn');
    if(trigger) trigger.click();
};


// --- AUTOSAVE LOGIC ---
    let autosaveTimer = null;

window.triggerAutosave = (scope = 'profile') => {
  // scope must be 'profile' or 'dashboard'
  scope = (scope === 'dashboard') ? 'dashboard' : 'profile';

  // Mark correct dirty flag
  dirtyFlags[scope] = true;

  // Update Save button highlight (active if either flag is true)
  syncMainSaveHighlight();

  // Clear existing timer
  if (autosaveTimer) clearTimeout(autosaveTimer);

  // Debounced draft save for the correct scope
  autosaveTimer = setTimeout(async () => {
    if (scope === 'profile') {
      await saveDraftLocal(true); // silent profile draft save
    } else {
      if (typeof saveDashboardState === 'function') {
        await saveDashboardState(true, 'save_draft'); // silent dashboard draft save
      }
    }
  }, 2000);
};

    // Update saveDraftLocal to use the helper
    window.saveDraftLocal = async (silent = false) => {
        const btn = document.getElementById('btnMainSave');
        if(!silent && btn) btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            const fd = new FormData();
            fd.append('action', 'save_draft'); 
            appendProfileDataToForm(fd);

            const res = await fetch('save_profile.php', {method:'POST', body:fd});
            const data = await res.json();

            if(data.status === 'success') {
                if(!silent) showToast("Draft Saved", "success");
                // We do NOT turn off markUnsaved() here, because it IS unsaved (not pushed)
                // We keep the light on to remind them to Push.
            } else {
                throw new Error(data.message);
            }
        } catch(e) {
            console.error("Autosave error", e);
            if(!silent) showToast("Save Failed", "error");
        } finally {
            if(!silent && btn) btn.innerHTML = '<i class="fas fa-save"></i>';
        }
    };

// Sort: 1. Mint Date (if available), 2. Name
    function sortCollections(cols) {
        return cols.sort((a, b) => {
            if (a.mintDate && b.mintDate) return a.mintDate - b.mintDate;
            return a.name.localeCompare(b.name);
        });
    }

    // Global Intersection Observer for Lazy Media (Only fetch heavy data when visible)
    const mediaObserver = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const card = entry.target;
                const colData = JSON.parse(card.dataset.colJson || '{}');
                // Only load if not already loaded
                if (colData.id && card.dataset.previewLoaded !== 'true') {
                    loadCollectionPreview(colData, card);
                }
                obs.unobserve(card);
            }
        });
    }, { rootMargin: "200px" });
    
    
let _syncPollTimer = null;

async function startBackendWalletSync(reason = 'start', force = false) {
    // Read latest values directly from memory to ensure they aren't stale
    const username = (currentUser.username || '').trim();
    const identity = (currentUser.identity || '').trim();
    const stake = (getEl('hiddenStakeKey')?.value || currentUser.identity || '').trim();
    const address = (getEl('hiddenWalletAddress')?.value || currentUser.address || '').trim();

    if (!username || !identity) return; 
    // Note: We allow continuing even if keys are missing from DOM if we have identity in memory

    try {
        // 1. Kickoff the Job (Start)
        if (reason === 'returning_user') force = false;
        
        await fetch('save_policy.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'start_wallet_sync',
                username, identity, stake, address, reason, force
            })
        });

// 2. Start the "Status Watcher" Loop (Read Only)
        if (_syncPollTimer) clearInterval(_syncPollTimer);
        
        _syncPollTimer = setInterval(async () => {
            try {
                // A. Check Status (The server is processing in background now)
                const res = await fetch('save_policy.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'wallet_sync_status', // Changed from tick to status
                        username, 
                        identity
                    })
                });
                
                if (!res.ok) return; // Skip if server busy/error

                const data = await res.json();
                const job = data.job || {};

                // B. Update UI (Silently refresh grid if we found new items)
                    if (data.status === 'success') {
                    // Check if job is finished
                    if (job.done === true || job.status === 'completed' || job.status === 'error') {
                        clearInterval(_syncPollTimer);
                        _syncPollTimer = null; // Clear the timer var so we can restart later if needed
                        console.log("Sync finished:", job.status);
                        
                        // One final pull to ensure we have the absolute latest state
                        if (currentTab === 'wallet') {
                            await syncWalletData();
                        }
                    } else {
                        await syncWalletData(); 
                    }
                }            } catch (err) {
                console.warn("Sync tick error", err);
            }
        }, 4000); // Pulse every 4 seconds

    } catch (e) {
        console.warn('Backend sync start failed:', e);
    }
}

    
// --- WALLET SYNC & RENDER LOGIC ---
// FIND AND REPLACE async function syncWalletData() { ... }
async function syncWalletData() {
    // 1. Concurrency Guard
    if (isWalletSyncRunning) {
        console.log("Sync already in progress, skipping...");
        return;
    }
    isWalletSyncRunning = true;

    const grid = getEl('collectionsGrid');
    
    // 2. Load Cache (Immediate Display)
    let existingWalletData = [];
    try {
        // Add timestamp to prevent browser caching of the JSON file
        const wRes = await fetch(`${currentUser.username}/wallet/wallet.json?t=${Date.now()}`);
        if (wRes.ok) {
            existingWalletData = await wRes.json();
        }
    } catch (e) {
        console.warn("No wallet cache found yet.");
    }

    // Sort
    cachedWalletCollections = sortCollections(existingWalletData);

    // 3. Pre-process Categories
    cachedWalletCollections.forEach(c => {
        c.category = getCollectionCategory(c);
        if(c.name === 'Wallet Collection' && c.assets && c.assets[0]) {
            const m = c.assets[0].onchain_metadata || {};
            c.name = deriveCollectionName(m.name || c.assets[0].asset_name || 'Collection');
        }
    });
    
    // Ensure we start on the correct tab visually
    // If currentWalletCategory is not set or valid, default to 'NFT'
    if (!['NFT', 'EDITION', 'RICH_FT', 'FT'].includes(currentWalletCategory)) {
        currentWalletCategory = 'NFT';
    }
    
    // Force the tab UI to match
    const tabs = document.querySelectorAll('.cat-tab');
    tabs.forEach(t => {
       if (t.textContent.includes('NFTs') && currentWalletCategory === 'NFT') t.classList.add('active');
       else if (t.getAttribute('onclick')?.includes(currentWalletCategory)) t.classList.add('active');
       else t.classList.remove('active');
    });
    

    // 4. Smart Render (Diffing logic handles the fading/no-flicker)
    if (cachedWalletCollections.length > 0) {
        walletPolicies = cachedWalletCollections;
        // Filter based on current selection
        walletFilteredPolicies = cachedWalletCollections.filter(c => c.category === currentWalletCategory);
        
        // Render without full reset (Smart Merge)
        await renderWalletGrid(false); 
        
        // Update stats header
        const totalAssets = cachedWalletCollections.reduce((a,b)=>a+(b.count||0),0);
        updateWalletHeader(totalAssets, cachedWalletCollections);
    } else {
        if(grid.innerHTML === '') grid.innerHTML = '<div class="grid-item">Syncing wallet...</div>';
    }

    // 5. Start Background Job (Only if not already polling)
    // We check if we have an identity, and ensure we don't start a duplicate job tracker
if (currentUser.identity && !_syncPollTimer && !hasSyncedThisSession) {
        hasSyncedThisSession = true; // Mark as done so it doesn't loop when the job finishes
        startBackendWalletSync('wallet_tab_open');
    }

    // Release Guard
    isWalletSyncRunning = false;
}
/*
async function syncWalletData() {
        const grid = getEl('collectionsGrid');
        const overlay = getEl('walletOverlay');
        const statusText = getEl('overlayStatusText');
        const bar = getEl('syncProgressBar');
        
        if (!meshWallet) {
            overlay.classList.add('hidden');
            grid.innerHTML = '<div style="padding:40px; text-align:center;">Please connect wallet.</div>';
            return;
        }

        try {
            // 1. FAST LOAD
            let existingWalletData = [];
            try {
                const wRes = await fetch(`${currentUser.username}/wallet/wallet.json?t=${Date.now()}`);
                if (wRes.ok) existingWalletData = await wRes.json();
            } catch (e) { }

            cachedWalletCollections = sortCollections(existingWalletData);
            
            // 2. SHOW OVERLAY & RENDER INITIAL
            overlay.classList.remove('hidden');
            bar.style.width = '0%';
            
            // If we have cache, render immediately so it's ready behind overlay
            if (cachedWalletCollections.length > 0) {
                renderWalletGrid(cachedWalletCollections, true);
            } else {
                grid.innerHTML = ''; 
                statusText.textContent = "Scanning wallet structure...";
            }

            // 10s Visual Timer (Progress Bar)
            // This runs independent of the actual sync to give user feedback
            let progress = 0;
            const timerInterval = 100; // update every 100ms
            const totalDuration = 10000; // 10s
            const step = 100 / (totalDuration / timerInterval);
            
            const timer = setInterval(() => {
                progress += step;
                if(progress > 95) progress = 95; // Hold at 95% until done
                if(bar) bar.style.width = `${progress}%`;
            }, timerInterval);

            // 3. BACKGROUND SCAN
            const assets = await meshWallet.getAssets();
            const policyMap = {};

            assets.forEach(a => {
                const pid = a.policyId;
                if (!policyMap[pid]) policyMap[pid] = { id: pid, count: 0, assets: [] };
                policyMap[pid].assets.push(a);
                policyMap[pid].count++;
            });

            const updateQueue = [];
            let totalAssetsCount = 0;
            const validPids = new Set();

            for (const [pid, pData] of Object.entries(policyMap)) {
                const existing = cachedWalletCollections.find(e => e.id === pid);
                if (!existing || existing.count !== pData.count) {
                    updateQueue.push(pData);
                } else {
                    totalAssetsCount += existing.count;
                }
                validPids.add(pid);
            }

            // Remove deleted items
            cachedWalletCollections = cachedWalletCollections.filter(c => validPids.has(c.id));
            
            // 4. PROCESS QUEUE (One by One)
            if (updateQueue.length > 0) {
                let processed = 0;
                for (const pItem of updateQueue) {
                    // Update Status Text
                    if(!overlay.classList.contains('hidden')) {
                        statusText.textContent = `Syncing collection ${processed + 1} of ${updateQueue.length}`;
                    }

                    // Throttle to prevent crash
                    await new Promise(r => setTimeout(r, 200));

                    const syncedCol = await processWalletPolicy(pItem);
                    if (syncedCol) {
                        const idx = cachedWalletCollections.findIndex(x => x.id === syncedCol.id);
                        if (idx > -1) cachedWalletCollections[idx] = syncedCol;
                        else cachedWalletCollections.push(syncedCol);
                        
                        totalAssetsCount += syncedCol.count;
                        cachedWalletCollections = sortCollections(cachedWalletCollections);

                        // If visible, update text. DO NOT APPEND.
                        const card = document.getElementById(`wal-col-${syncedCol.id}`);
                        if (card) {
                            const meta = card.querySelector('.col-meta');
                            if(meta) meta.textContent = `${syncedCol.count} Assets`;
                            // Update title if we got a better name
                            const title = card.querySelector('.col-title');
                            if(title && syncedCol.name !== 'Wallet Collection') title.textContent = syncedCol.name;
                        }
                    }
                    processed++;
                }
                await saveWalletJson(cachedWalletCollections);
            }

            // 5. FINISH
            clearInterval(timer);
            if(bar) bar.style.width = '100%';
            
            // Wait slight moment for bar to fill
            await new Promise(r => setTimeout(r, 500));
            
            overlay.classList.add('hidden');
            
            // If we started empty but found stuff, render now
            if (grid.children.length === 0 && cachedWalletCollections.length > 0) {
                renderWalletGrid(cachedWalletCollections, true);
            }
            
            if (cachedWalletCollections.length === 0) {
                 grid.innerHTML = '<div class="grid-item">No rich media assets found.</div>';
            }

            updateWalletHeader(totalAssetsCount, cachedWalletCollections);

        } catch (e) {
            console.error("Wallet Sync Error", e);
            overlay.classList.add('hidden');
            if(cachedWalletCollections.length === 0) {
                grid.innerHTML = `<div style="text-align:center; color:#ff6b6b;">Error: ${e.message}</div>`;
            }
        }
    }
    */

    async function processWalletPolicy(pData) {
        // Fetch details for assets to check for Rich Media & Metadata
        // Using existing get_asset_detail.php
        
        const validAssets = [];
        const units = pData.assets.map(a => a.unit);
        

// Batch fetch details (reuse logic from syncCollection but strictly for wallet)
        for (const unit of units) {
            try {
                const res = await fetch(`get_asset_detail.php?asset=${unit}`);
                const detail = await res.json();
                const meta = detail.onchain_metadata || detail.metadata || {};
                
                // --- 1. EXCLUDE NO 721 / NO RICH MEDIA ---
                // If no metadata object, or no 'image'/'files' key, treat as raw token
                let hasMedia = false;
                if (meta.image) hasMedia = true;
                if (meta.files && meta.files.length > 0) hasMedia = true;
                if (!hasMedia) continue; 

                // --- 2. EXCLUDE "TOKEN" NAMES (Decimals, Ticker, Ends in Token) ---
                // Get name: prioritize metadata name, fallback to asset_name
                let nameToCheck = "";
                if (meta.name && typeof meta.name === 'string') nameToCheck = meta.name;
                else nameToCheck = hexToAsciiSafe(detail.asset_name || '');

                const n = nameToCheck.trim().toLowerCase();

                // A. Check for specific reserved words often found in FT metadata
                if (n.includes("decimals") || n.includes("ticker")) continue;

                // B. Check if name ends with "token" (covers "Leaf Token", "LeafToken", "leaftoken")
                // using .endsWith('token') after lowercasing
                if (n.endsWith("token")) continue;

                // --- PASS: Add to valid list ---
                validAssets.push({
                    unit: unit,
                    policy_id: pData.id,
                    asset_name: detail.asset_name,
                    onchain_metadata: meta,
                    traits: extractTraitsFromMeta(meta)
                });
            } catch (e) { console.error(e); }
        }

        if (validAssets.length === 0) return null;

        // Determine Name from first asset
        const first = validAssets[0];
        let colName = "Untitled Collection";
        if (first.onchain_metadata?.name) colName = deriveCollectionName(first.onchain_metadata.name);

        // Determine Thumb
        let thumb = "";
        const thumbAsset = validAssets.find(a => a.onchain_metadata?.image) || validAssets[0];
        if (thumbAsset) thumb = getInlineDataUriFromMetadata(thumbAsset.onchain_metadata) || thumbAsset.onchain_metadata.image;

let mintDate = 0;

        // Save individual policy file to wallet directory
        await fetch('save_policy.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'cache_wallet_assets', // New action for PHP
                username: currentUser.username,
                identity: currentUser.identity,
                policyId: pData.id,
                assets: validAssets,
                directory: 'wallet' // Explicit flag
            })
        });

        return {
            id: pData.id,
            name: colName,
            count: validAssets.length,
            thumb: thumb,
            type: 'wallet',
            mintDate: mintDate
        };
    }

    async function saveWalletJson(cols) {
        await fetch('save_policy.php', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                action: 'save_wallet_index',
                username: currentUser.username,
                data: cols
            })
        });
    }

// --- NEW WALLET CATEGORIZATION LOGIC ---
function getCollectionCategory(col) {
    // 1. Trust the Backend: If JSON has a valid category, use it.
    if (col.category && ['NFT', 'EDITION', 'RICH_FT', 'FT'].includes(col.category)) {
        return col.category;
    }

    // 2. Fallback Logic (Only runs if category is missing)
    if (!col.assets || !col.assets.length) return 'NFT';
    
    const first = col.assets[0];
    const meta = first.onchain_metadata || {};
    const name = (meta.name || first.asset_name || '').toLowerCase();
    const qty = parseInt(first.quantity || '1');

    const hasRichMedia = (meta.files && Array.isArray(meta.files) && meta.files.length > 0) 
                          || (meta.image && typeof meta.image === 'string' && (meta.image.includes('ipfs') || meta.image.startsWith('http')));

    const hasTicker = meta.ticker !== undefined;
    const isTokenName = name.includes('token') || name.includes('coin');
    
    if ((hasTicker || isTokenName) && hasRichMedia) return 'RICH_FT';
    if (hasTicker || (isTokenName && !hasRichMedia)) return 'FT';
    if (qty > 1) return 'EDITION';

    return 'NFT';
}


window.filterWalletCat = (cat, btn) => {
    // 1. Set Global Category
    currentWalletCategory = cat;
    
    // 2. Update UI Buttons
    document.querySelectorAll('.cat-tab').forEach(b => b.classList.remove('active'));
    if(btn) btn.classList.add('active');
    
    // 3. Reset Cursor
    walletPageIndex = 0;
    
    // 4. Force Re-Render with Reset=True
    renderWalletGrid(true);
};

// ==========================================
// RENDER WALLET GRID
// ==========================================
async function renderWalletGrid(reset = false) {
    const grid = getEl('collectionsGrid');
    
    // 1. Strict Category Filtering
    // Default to 'NFT' if the global var is unset
    if (!currentWalletCategory) currentWalletCategory = 'NFT';
    
    let listToRender = walletPolicies.filter(c => c.category === currentWalletCategory);

if (reset) {
        // FIX: Fade out the "No collections" text if it exists, don't just wipe innerHTML
        const emptyMsg = grid.querySelector('.grid-item');
        if (emptyMsg && !emptyMsg.classList.contains('fade-out')) {
            emptyMsg.style.transition = 'opacity 0.5s ease';
            emptyMsg.style.opacity = '0';
            setTimeout(() => emptyMsg.remove(), 500);
        } else if (!emptyMsg) {
            // Only wipe if it's cards
            grid.innerHTML = '';
        }
        
        walletPageIndex = 0;
        isWalletLoading = false;
    }

    if (isWalletLoading || walletPageIndex >= listToRender.length) return;
    isWalletLoading = true;

    // 2. Batch Calculation
    const batchSize = walletPageSize; 
    const startIndex = walletPageIndex;
    const endIndex = Math.min(startIndex + batchSize, listToRender.length);
    const batch = listToRender.slice(startIndex, endIndex);

    if (batch.length === 0 && startIndex === 0) {
        grid.innerHTML = '<div class="grid-item" style="color:#666;">No items found.</div>';
        isWalletLoading = false;
        return;
    }

    // 3. Render Loop
    for (const col of batch) {
        const loadingMsg = grid.querySelector('.grid-item');
        if (loadingMsg) loadingMsg.remove();
        
        if (document.querySelector(`.collection-card[data-id="${col.id}"]`)) continue;

        const cardEl = document.createElement('div');
        cardEl.className = 'collection-card wallet-card';
        cardEl.dataset.id = col.id;
        
        // CRITICAL: Start hidden. We only show it when loadCollectionPreview says the image is ready.
        cardEl.style.opacity = '0'; 
        cardEl.style.transition = 'opacity 0.7s ease';

        // Placeholder text while loading
        let dispName = col.name;
        if(dispName === 'Wallet Collection') dispName = 'Loading...';

        cardEl.innerHTML = `
            <div class="col-thumb"></div> 
            <div class="col-info">
                <div class="col-title">${dispName}</div>
                <div class="col-meta">${col.count} Assets</div>
            </div>
        `;

        // 4. Interaction Logic (Thumb = Hover Only, Info = Click)
        const thumbEl = cardEl.querySelector('.col-thumb');
        thumbEl.onclick = (e) => { e.stopPropagation(); }; // Stop click
        
        const infoEl = cardEl.querySelector('.col-info');
        infoEl.onclick = (e) => { e.stopPropagation(); openAssetBrowser(col, true); }; // Active click

        grid.appendChild(cardEl);

        // 5. Load Content (This triggers the fade-in when done)
        loadCollectionPreview(col, cardEl).catch(err => {
            // If error, force show anyway so we don't have invisible cards
            cardEl.style.opacity = '1';
        });
    }

    walletPageIndex = endIndex;
    isWalletLoading = false;
    
}

function updateWalletHeader(totalAssets, cols) {
    getEl('walletStatsDisplay').textContent = `Collections|Assets: ${cols.length}|${totalAssets}`;
    
    const sel = getEl('walletCollectionSelect');
    // Save current selection before wiping
    const currentVal = sel.value; 
    
    sel.innerHTML = '<option value="">Jump...</option>';
    
    // Sort a Copy to avoid jittering the grid order
    const sortedCols = [...cols].sort((a,b) => {
        const nA = a.name || 'Untitled';
        const nB = b.name || 'Untitled';
        return nA.localeCompare(nB);
    });
    
    sortedCols.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.id;
        opt.textContent = c.name; // This will now use the updated name from loadCollectionPreview
        sel.appendChild(opt);
    });

    // Restore selection
    sel.value = currentVal;

    requestAnimationFrame(() => {
        const wc = document.getElementById('walletControls');
        if (wc) window.dispatchEvent(new Event('resize'));
    });
}

window.scrollToCollection = async (id) => {
        if(!id) return;
        
        // 1. Try finding it immediately
        let el = document.querySelector(`.collection-card[data-id="${id}"]`);
        
        // 2. If not found (Lazy Load), force render up to that item
        if (!el) {
            // Find where this item is in the current list
            let listToRender = (currentTab === 'wallet') 
                ? walletPolicies.filter(c => c.category === currentWalletCategory)
                : (currentUser.profileData?.collections || []);
                
            const targetIndex = listToRender.findIndex(c => c.id === id);
            
            if (targetIndex > -1) {
                // Determine how many pages we need to show
                const targetPage = targetIndex + 1;
                
                // Update cursor to include this item
                if (currentTab === 'wallet') {
                    if (walletPageIndex < targetPage) {
                        walletPageIndex = targetPage;
                        // Force render without resetting (append missing items)
                        await renderWalletGrid(false); 
                    }
                } else {
                    if (colBatchIndex < targetPage) {
                        colBatchIndex = targetPage;
                        await renderNextColBatch();
                    }
                }
                
                // Try finding it again after forced render
                el = document.querySelector(`.collection-card[data-id="${id}"]`);
            }
        }

        // 3. Scroll
        if(el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.style.borderColor = 'var(--accent)';
            setTimeout(() => el.style.borderColor = 'rgba(255,255,255,0.1)', 1500);
        }
    }; 
    
    // Helper to check if an ID is an existing group
    function isGroup(id) {
        if (!currentUser.profileData || !currentUser.profileData.combinations) return false;
        return currentUser.profileData.combinations.some(g => g.id === id);
    }

// --- STATE MANAGEMENT ---
    
    // Call this when any change happens (edit profile, delete/combine)
// Lights up button (Draft exists)
    window.markUnsaved = () => {
        hasUnsavedChanges = true;
        const btn = getEl('btnMainSave');
        if(btn) btn.classList.add('active');
    };

    // Turns off button (Synced)
    window.markAllSaved = () => {
        hasUnsavedChanges = false;
        const btn = getEl('btnMainSave');
        if(btn) btn.classList.remove('active');
    };

    // Call this when data is saved to DB but NOT pushed yet
    // (In your case, this is the same visual state as Unsaved - needs Push)
    window.markLocalSaved = () => {
        hasUnsavedChanges = true; 
        const btn = document.getElementById('btnMainSave');
        if(btn) btn.classList.add('active');
    };


// --- SIGN & PUSH LOGIC ---
// fallback to change/used if not available.
async function getPushSigningAddress() {
  try {
    if (meshWallet && typeof meshWallet.getRewardAddresses === 'function') {
      const r = await meshWallet.getRewardAddresses();
      if (Array.isArray(r) && r[0]) return r[0];
    }
  } catch {}

  try {
    if (meshWallet && typeof meshWallet.getChangeAddress === 'function') {
      const ch = await meshWallet.getChangeAddress();
      if (ch) return ch;
    }
  } catch {}

  try {
    if (meshWallet && typeof meshWallet.getUsedAddresses === 'function') {
      const used = await meshWallet.getUsedAddresses();
      if (Array.isArray(used) && used[0]) return used[0];
    }
  } catch {}

  return '';
}

window.openPushModal = () => {
    // Highlight the most sensible option based on current dirty flags
const btns = Array.from(document.querySelectorAll('#pushButtonsContainer .push-opt-btn'));
btns.forEach(b => b.classList.remove('highlight'));

let target = 'both';
if (dirtyFlags.profile && !dirtyFlags.dashboard) target = 'profile';
if (!dirtyFlags.profile && dirtyFlags.dashboard) target = 'dashboard';

const pick = btns.find(b => (b.getAttribute('onclick') || '').includes(`triggerSignAndPush('${target}')`));
if (pick) pick.classList.add('highlight');

        getEl('pushButtonsContainer').style.display = 'block';
        getEl('pushStatusMsg').style.display = 'none';
        getEl('pushOptionsModal').style.display = 'flex';
    };

// LANDMARK: window.triggerSignAndPush
window.triggerSignAndPush = async (pushed) => {

// normalize + backwards-compat alias
pushed = (pushed === 'profile' || pushed === 'dashboard' || pushed === 'both') ? pushed : 'both';
const pushType = pushed; // IMPORTANT: prevents "pushType is not defined" anywhere below
const type = pushType;   // IMPORTANT: prevents "type is not defined" anywhere below


        // 1. Get Access to API
        const api = window.fre5hGateState?.api;
        if (!api) return showToast("Connect wallet first", "error");

        // 1b. UI Updates
        getEl('pushButtonsContainer').style.display = 'none';
        getEl('pushStatusMsg').style.display = 'block';

        try {
            // 2. Get Address (Hex) - Raw CIP-30 prefer Reward, then Used
            let signAddr = await getWalletIdentityHex(api); 
            
            // 3. Prepare Message & Payload
            const timestamp = new Date().toISOString();
            const message = 
                `Sign to push updates to ID Pages:\n` +
                `Type: ${type}\n` +
                `User: ${currentUser.username || ''}\n` +
                `Date: ${timestamp}`;
            
            const payloadHex = utf8ToHex(message);

            // 4. SIGN DATA using RAW CIP-30 (Bypasses Mesh Bech32 checks)
            // api.signData(addrHex, payloadHex) -> { signature, key }
            const signature = await api.signData(signAddr, payloadHex);

            if (!signature?.key || !signature?.signature) {
                throw new Error('Wallet did not return a valid signature object');
            }
            
// 5. Send to PHP
const fd = new FormData();

// LANDMARK: fd.append('clearDraft')
const willClearDraft =
  (pushed === 'both') ||
  (pushed === 'profile'   && !dirtyFlags.dashboard) ||
  (pushed === 'dashboard' && !dirtyFlags.profile);

fd.append('clearDraft', willClearDraft ? '1' : '0');

            fd.append('action', 'push_public'); 
            fd.append('username', currentUser.username);
            fd.append('pushType', pushed);
            fd.append('pushed', pushed); 
            fd.append('type', type);
            // Pass standard signature fields
            fd.append('key', signature.key);
            fd.append('signature', signature.signature);
            fd.append('sigAddr', signAddr);
            fd.append('payload', payloadHex);

            // Append Profile Data for the save
            appendProfileDataToForm(fd); // Helper function defined below

// Read body ONCE
const res = await fetch('save_profile.php', { method: 'POST', body: fd });
const data = await res.json().catch(() => ({}));

if (!res.ok) {
  throw new Error(data.message || data.error || 'Save failed');
}
// If you have a modal for push options, close it:
if (window.closeModal) {
  try { window.closeModal('pushModal'); } catch(e){}
}

// If you were toggling these earlier, reset them:
getEl('pushButtonsContainer') && (getEl('pushButtonsContainer').style.display = 'block');
getEl('pushStatusMsg') && (getEl('pushStatusMsg').style.display = 'none');

// Optionally refresh data / update link:
if (data.url) {
  // Example: update a "View Public Page" link if you have one
  const a = getEl('publicPageLink');
  if (a) a.href = data.url;
}

if (data.status === 'success') {
  // 1. Close Modals & Overlays
  if (window.closeModal) window.closeModal('pushOptionsModal');
  getEl('walletOverlay')?.classList.add('hidden');

  // Only run this after a PUSH response (not save_draft)
  if (data && data.mode === 'public') {
    // Use server pushType if present; fallback to local type ONLY if it exists
const pushedFinal = String(data.pushType || pushType || type || 'both').toLowerCase();


    // Clear only what was pushed
if (pushedFinal === 'profile' || pushedFinal === 'both') dirtyFlags.profile = false;
if (pushedFinal === 'dashboard' || pushedFinal === 'both') dirtyFlags.dashboard = false;

    // Server is source of truth on whether draft still exists
    if (data.hasDraft === false) {
      dirtyFlags.profile = false;
      dirtyFlags.dashboard = false;
    }

    if (!dirtyFlags.profile && !dirtyFlags.dashboard && data.hasDraft === false) {
      markAllSaved();
      currentUser.isDraft = false;
    } else {
      markUnsaved();
      currentUser.isDraft = true;
    }

    syncMainSaveHighlight();
  }

  getEl('dashboardRoot')?.classList.add('hidden');
  getEl('setupPanel')?.classList.add('hidden');
  getEl('landingPage')?.classList.remove('hidden');

  setTimeout(() => {
    startBackendWalletSync('post_push_sync', false);
  }, 500);

  if (_collectorFirstSaveNeedsAutoPush) {
    _collectorFirstSaveNeedsAutoPush = false;
    const rf5 = '../fre5hfence/RF5.png?v=2';
    const hp = getEl('headerProfileBtn');
    if (hp && (!hp.src || hp.src.includes('undefined') || hp.src.trim() === '')) hp.src = rf5;

    openModal('welcomeModal');
    return;
  }

  showToast("Public Page Updated!", "success");
} else {                throw new Error(data.message || "Server error");
            }

        } catch(e) {
            console.error(e);
            // Reset Modal UI
            getEl('pushButtonsContainer').style.display = 'block';
            getEl('pushStatusMsg').style.display = 'none';
            
            if(e.message && e.message.toLowerCase().includes("declin")) {
                showToast("Signature Cancelled", "info");
            } else if (e.code === 2) { // CIP-30 User Declined
                 showToast("Signature Cancelled", "info");
            } else {
                showToast("Push Failed: " + e.message, "error");
            }
        }
    };
    
    function safeStr(v){
  if (v === null || v === undefined) return '';
  v = String(v).trim();
  const low = v.toLowerCase();
  if (low === 'null' || low === 'undefined') return '';
  return v;
}


    // Helper to avoid code duplication in saves
    function appendProfileDataToForm(fd) {
  const pData = currentUser.profileData || {};
  fd.append('identity', safeStr(currentUser.identity));
  fd.append('address',  safeStr(currentUser.address));
  fd.append('displayName', safeStr(pData.displayName));
  fd.append('bio', safeStr(pData.bio));
  fd.append('location', safeStr(pData.location));
  fd.append('role', safeStr(currentUser.role || 'artist'));
  if (pData.pfp) fd.append('existingPfp', safeStr(pData.pfp));

  const combos = Array.isArray(pData.combinations) ? pData.combinations : [];
  fd.append('combinations', JSON.stringify(combos));
    }
    
// --- HERO: small HTML escaper for labels (prevents accidental markup) ---
function escHtml(v){
  return String(v ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function stopHeroRotation(){
  if (heroTimer) clearInterval(heroTimer);
  heroTimer = null;
}

function startHeroRotation(){
  stopHeroRotation();
  if (!heroItems || heroItems.length < 2) return;
  heroTimer = setInterval(() => {
    const next = (heroActiveIdx + 1) % heroItems.length;
    setHeroActive(next);
  }, HERO_ROTATE_MS);
}

function renderHeroStrip(){
  const strip = getEl('heroAssetStrip');
  if (!strip) return;

  strip.innerHTML = '';

  heroItems.forEach((it, idx) => {
const card = document.createElement('div');
card.className = 'hero-card';
card.setAttribute('role','button');
card.tabIndex = 0;

const creatorUrl = `https://therefreshcnft.com/idp/${it.username}`;


    const media = document.createElement('div');
    media.className = 'hero-card-media';
    buildMediaPreviewInto(it.meta, media, '../fre5hfence/RF5.png?v=2', false, true);

    const info = document.createElement('div');
    info.className = 'hero-card-info';
    info.innerHTML = `
 <div class="hero-card-title">${escHtml(it.assetName || 'Asset')}</div>
    `;

card.appendChild(media);
card.appendChild(info);


    // Click sets active hero item; Ctrl/Cmd click still opens creator page
    card.addEventListener('click', (e) => {
      // Preserve the old "Ctrl/Cmd click opens creator page" behavior
      if (e.ctrlKey || e.metaKey || e.button === 1) {
        window.open(creatorUrl, '_blank', 'noopener');
        return;
      }
      setHeroActive(idx);
      startHeroRotation();
    });


    strip.appendChild(card);
  });
}

function setHeroActive(idx, immediate=false){
  if (!heroItems || !heroItems[idx]) return;
  heroActiveIdx = idx;

  // highlight active card
  document.querySelectorAll('.hero-card').forEach((el, i) => {
    el.classList.toggle('active', i === idx);
  });

  const it = heroItems[idx];
  const layer = getEl('heroMediaLayer');
  if (!layer) return;

  const next = document.createElement('div');
  next.className = 'hero-media-item';
  buildMediaPreviewInto(it.meta, next, '../fre5hfence/RF5.png?v=2', false, false);

  // fade swap
  const prev = layer.querySelector('.hero-media-item');
  if (immediate || !prev){
    layer.innerHTML = '';
    layer.appendChild(next);
  } else {
    prev.classList.add('out');
    layer.appendChild(next);
    setTimeout(() => { prev.remove(); }, 750);
  }

  // hide fallback once we have media
  const fallback = getEl('heroBgFallback');
  if (fallback) fallback.style.opacity = '0';

// Keep the static tagline under "ID Pages"
const sub = getEl('heroSubtitle');
if (sub) sub.textContent = 'Your Policy Your Page';

// Move the dynamic line below the thumbnail strip, and make @username clickable
const by = getEl('heroByline');
if (by) {
  const url = `https://therefreshcnft.com/idp/${encodeURIComponent(it.username)}`;
  by.innerHTML = `${escHtml(it.policyName)} • by <a href="${url}" target="_blank" rel="noopener">@${escHtml(it.username)}</a>`;
}

}

async function initLandingHero(){
  const layer = getEl('heroMediaLayer');
  const strip = getEl('heroAssetStrip');
  if (!layer || !strip) return;

  // load feed
  let feed;
  try{
    const r = await fetch(`${HERO_FEED_URL}?t=${Date.now()}`);
    if (!r.ok) return;
    feed = await r.json();
  } catch {
    return;
  }

  const list = Array.isArray(feed?.items) ? feed.items : [];
  if (!list.length) return;

  const resolved = [];

  for (const it of list.slice(0, HERO_MAX_ITEMS)){
    const username = String(it.username || '').trim();
    const policyId  = String(it.policyId || it.policy || '').trim();
    if (!username || !policyId) continue;

    // load policy cache json
    let pData;
    try{
      const pr = await fetch(`${username}/policies/${policyId}.json?t=${Date.now()}`);
      if (!pr.ok) continue;
      pData = await pr.json();
    } catch {
      continue;
    }

    const assets = Array.isArray(pData.assets_cache) ? pData.assets_cache : [];
    if (!assets.length) continue;

    // choose asset (pinned unit if provided, else random)
    let chosen = null;
    const pinnedUnit = it.unit || it.asset || '';
    if (pinnedUnit) {
      chosen = assets.find(a => {
        const unit = a.asset || ((a.policy_id || '') + (a.asset_name || ''));
        return unit === pinnedUnit;
      }) || null;
    }
    if (!chosen) chosen = assets[Math.floor(Math.random() * assets.length)];

    const meta = chosen.onchain_metadata || chosen.metadata || {};
    const unit = chosen.asset || ((chosen.policy_id || '') + (chosen.asset_name || ''));

    let assetName = '';
    if (meta && typeof meta.name === 'string' && meta.name.trim()) {
      assetName = meta.name.trim();
    } else {
      assetName = hexToAsciiSafe(chosen.asset_name || '') || unit || 'Asset';
    }

// HERO name priority:
// 1) hero_feed.json (policyName)  <-- what you want
// 2) cached policy file (pData.meta.name)
// 3) derive from chosen asset name
const feedPolicyNameRaw =
  (it && (it.policyName || it.policy_name || it.collectionName || it.collection_name || it.name))
    ? (it.policyName || it.policy_name || it.collectionName || it.collection_name || it.name)
    : '';

const cachePolicyNameRaw = (pData.meta && pData.meta.name) ? pData.meta.name : '';

let policyNameRaw = String(feedPolicyNameRaw || cachePolicyNameRaw || '').trim();

// If cache uses placeholders, fall back to derivation (matches your other logic style)
if (!policyNameRaw ||
    policyNameRaw === 'Verified Collection' ||
    policyNameRaw === 'Untitled' ||
    policyNameRaw === 'Collection') {
  policyNameRaw = '';
}

const policyName = policyNameRaw || deriveCollectionName(assetName);


    resolved.push({
      username,
      policyId,
      unit,
      meta,
      assetName,
      policyName
    });
  }

  if (!resolved.length) return;

  heroItems = resolved;

  renderHeroStrip();
  setHeroActive(0, true);
  startHeroRotation();
}
  
    // --- IPFS gateway + retry helpers (drop-in, bounded retries) ---
const IPFS_GOOD_GATEWAY_BY_CID = new Map();

function _stripTrailingSlash(s){ return (s||"").replace(/\/+$/,""); }

function extractIpfsSuffix(raw) {
  if (!raw) return null;
  const s = String(raw).trim();

  // ipfs://<cid>/<path>
  if (s.startsWith("ipfs://")) return s.slice(7).replace(/^\/+/, "");

  // .../ipfs/<cid>/<path>
  const m = s.match(/\/ipfs\/([^?#]+)/i);
  if (m && m[1]) return m[1].replace(/^\/+/, "");

  return null;
}

function extractCidFromSuffix(suffix){
  if (!suffix) return null;
  return suffix.split("/")[0] || null;
}

function ipfsUrlForGateway(raw, gatewayBase){
  const suffix = extractIpfsSuffix(raw);
  if (!suffix) return raw; // not IPFS
  return `${_stripTrailingSlash(gatewayBase)}/ipfs/${suffix}`;
}

function withTimeout(promise, ms){
  if (!ms) return promise;
  let t;
  const timeout = new Promise((_, rej) => {
    t = setTimeout(() => rej(new Error("timeout")), ms);
  });
  return Promise.race([promise.finally(() => clearTimeout(t)), timeout]);
}

function getStartGatewayIndex(raw){
  const suffix = extractIpfsSuffix(raw);
  const cid = extractCidFromSuffix(suffix);
  if (!cid) return 0;
  const idx = IPFS_GOOD_GATEWAY_BY_CID.get(cid);
  return Number.isInteger(idx) ? idx : 0;
}

function rememberGateway(raw, idx){
  const suffix = extractIpfsSuffix(raw);
  const cid = extractCidFromSuffix(suffix);
  if (!cid) return;
  IPFS_GOOD_GATEWAY_BY_CID.set(cid, idx);
}

function makeThumbUrl(url){
  // If you already have optimizeThumb(url, size), this will use it.
  try {
    if (typeof optimizeThumb === "function") return optimizeThumb(url, THUMB_MAX);
  } catch {}
  return url;
}

async function setImgSrcWithGateways(imgEl, rawUrl, isThumb){
  const suffix = extractIpfsSuffix(rawUrl);
  const gateways = suffix ? IPFS_GATEWAYS : [null];
  const start = suffix ? getStartGatewayIndex(rawUrl) : 0;

  for (let step = 0; step < gateways.length; step++) {
    const gi = suffix ? (start + step) % gateways.length : 0;
    const baseUrl = suffix ? ipfsUrlForGateway(rawUrl, gateways[gi]) : rawUrl;
    const finalUrl = isThumb ? makeThumbUrl(baseUrl) : baseUrl;

    try {
      await withTimeout(new Promise((res, rej) => {
        const onLoad = () => { cleanup(); res(true); };
        const onErr  = () => { cleanup(); rej(new Error("img error")); };
        const cleanup = () => {
          imgEl.removeEventListener("load", onLoad);
          imgEl.removeEventListener("error", onErr);
        };
        imgEl.addEventListener("load", onLoad, { once: true });
        imgEl.addEventListener("error", onErr, { once: true });

        imgEl.src = finalUrl;
      }), isThumb ? THUMB_LOAD_TIMEOUT_MS : DETAIL_LOAD_TIMEOUT_MS);

      if (suffix) rememberGateway(rawUrl, gi);
      return;
    } catch (e) {
      // try next gateway
    }
  }
  // bounded attempts: stops here (no infinite loops)
}

async function setIframeSrcWithGateways(iframeEl, rawUrl){
  const suffix = extractIpfsSuffix(rawUrl);
  const gateways = suffix ? IPFS_GATEWAYS : [null];
  const start = suffix ? getStartGatewayIndex(rawUrl) : 0;

  for (let step = 0; step < gateways.length; step++) {
    const gi = suffix ? (start + step) % gateways.length : 0;
    const finalUrl = suffix ? ipfsUrlForGateway(rawUrl, gateways[gi]) : rawUrl;

    try {
      await withTimeout(new Promise((res) => {
        const onLoad = () => { cleanup(); res(true); };
        const cleanup = () => iframeEl.removeEventListener("load", onLoad);
        iframeEl.addEventListener("load", onLoad, { once: true });

        iframeEl.src = finalUrl;
      }), DETAIL_LOAD_TIMEOUT_MS);

      if (suffix) rememberGateway(rawUrl, gi);
      return;
    } catch (e) {
      // timeout -> next gateway
    }
  }
}

async function setVideoSrcWithGateways(videoEl, rawUrl){
  const suffix = extractIpfsSuffix(rawUrl);
  const gateways = suffix ? IPFS_GATEWAYS : [null];
  const start = suffix ? getStartGatewayIndex(rawUrl) : 0;

  for (let step = 0; step < gateways.length; step++) {
    const gi = suffix ? (start + step) % gateways.length : 0;
    const finalUrl = suffix ? ipfsUrlForGateway(rawUrl, gateways[gi]) : rawUrl;

    try {
      await withTimeout(new Promise((res, rej) => {
        const onMeta = () => { cleanup(); res(true); };
        const onErr  = () => { cleanup(); rej(new Error("video error")); };
        const cleanup = () => {
          videoEl.removeEventListener("loadedmetadata", onMeta);
          videoEl.removeEventListener("error", onErr);
        };
        videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        videoEl.addEventListener("error", onErr, { once: true });

        videoEl.src = finalUrl;
        videoEl.load();
      }), DETAIL_LOAD_TIMEOUT_MS);

      if (suffix) rememberGateway(rawUrl, gi);
      return;
    } catch (e) {
      // next gateway
    }
  }
}

function ipfsToGatewayUrl(s, gatewayBase) {
  if (!s) return s;

  // preserve ?query and #hash
  const hashIdx = s.indexOf('#');
  const hash = hashIdx !== -1 ? s.slice(hashIdx) : '';
  const noHash = hashIdx !== -1 ? s.slice(0, hashIdx) : s;

  const qIdx = noHash.indexOf('?');
  const query = qIdx !== -1 ? noHash.slice(qIdx) : '';
  const noQ = qIdx !== -1 ? noHash.slice(0, qIdx) : noHash;

  let cidPath = null;

  if (noQ.startsWith('ipfs://')) {
    cidPath = noQ.slice('ipfs://'.length).replace(/^ipfs\//, '');
  } else {
    const ipfsIdx = noQ.indexOf('/ipfs/');
    if (ipfsIdx !== -1) cidPath = noQ.slice(ipfsIdx + '/ipfs/'.length);
  }

  if (!cidPath) return s;

  const base = (gatewayBase || '').replace(/\/$/, '');
  return base + '/ipfs/' + cidPath + query + hash;
}

    
    const formatWalletName = (n) => n ? (n.length<=3?n.toUpperCase():n.charAt(0).toUpperCase()+n.slice(1)) : "Select";
    
    const hexToAsciiSafe = (hex) => {
        if (!hex || typeof hex !== 'string') return hex;
        if (hex.includes(' ')) return hex; 
        if (!/^[0-9a-fA-F]+$/.test(hex)) return hex;
        try { 
            let str = ''; 
            for (let i=0;i<hex.length;i+=2) str += String.fromCharCode(parseInt(hex.substr(i,2),16)); 
            return str; 
        } catch{ return hex; }
    };
    

// Helper to resize images for grid views
const optimizeThumb = (url) => {
  if (!url || typeof url !== 'string') return '';

  // IMPORTANT: normalize ar:// / bare arweave txid / missing-protocol first
  const u = formatUrl(url);

  // Skip data URIs or non-http(s) (ipfs:// stays for gateway logic elsewhere)
  if (u.startsWith('data:') || !/^https?:\/\//i.test(u)) return u;

  // Keep your existing wsrv.nl behavior unchanged
  return `https://wsrv.nl/?url=${encodeURIComponent(u)}&w=512&h=512&fit=inside&output=webp`;
};
    
    window.switchImportTab = function(t) {
        ['tabKeys', 'tabClaim'].forEach(t => getEl(t).classList.add('hidden'));
        getEl(appDB).classList.add('hidden');
        ['studioTabsNav', 'tab-meta', 'tab-code'].forEach(t => getEl(t).classList.remove('hidden'));
        
        document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
    };
    
// --- FIX: Restore Studio Tab Logic ---
window.switchStudioTab = function(t) {
    // 1. Toggle Button Visuals
    const nav = document.getElementById('studioTabsNav');
    if(nav) {
        nav.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        // Find the button that calls this function with 't'
        const target = nav.querySelector(`button[onclick*="'${t}'"]`);
        if(target) target.classList.add('active');
    }

    // 2. Toggle Content Areas
    const metaTab = document.getElementById('tab-meta');
    const codeTab = document.getElementById('tab-code');
    
    if(metaTab) metaTab.classList.toggle('active', t === 'meta');
    if(codeTab) codeTab.classList.toggle('active', t === 'code');
};

// --- FIX: Restore Address Toggle Logic ---
window.onUseWalletAddrToggle = function() {
    const cb = document.getElementById('useWalletAddr');
    const inp = document.getElementById('receiveAddr');
    if (!cb || !inp) return;

    if (cb.checked) {
        if (!currentUser.address) {
            alert("Connect wallet first");
            cb.checked = false;
            return;
        }
        inp.value = currentUser.address;
        inp.disabled = true; 
    } else {
        inp.disabled = false;
    }
};
// Attach listener immediately in case DOM is ready
const uwa = document.getElementById('useWalletAddr');
if(uwa) uwa.addEventListener('change', window.onUseWalletAddrToggle);

// --- FIX: Restore Preset Toggle Listeners ---
const myVarCb = document.getElementById('useMyVar');
if(myVarCb) myVarCb.addEventListener('change', window.toggleVarInput);
    
    window.showToast = (msg, type) => {
        const b = getEl('toastBox');
        if(!b) return;
        const t = document.createElement('div'); t.className=`toast ${type||''}`; t.textContent=msg;
        b.appendChild(t); setTimeout(()=>t.remove(), 3000);
    };
    
    window.copyProfileUrl = function() {
        const url = getEl('displayUrlText').textContent;
        navigator.clipboard.writeText(url).then(() => showToast("Link copied!"));
    };

    // ==========================================
    // 3. UI LOGIC (Delete, Tabs, Menu)
    // ==========================================

    // --- PROFILE DROPDOWN MENU ---

/*
window.handleWalletClick = async () => {
// Wallet connect ONLY lives here now (wallet icon)
if (!meshWallet) {
getEl('walletModal').style.display = 'flex';
populateWalletModal();
return;
}

// If already connected, you can optionally open a wallet dropdown later.
// For now: just toast or do nothing.
if (typeof showToast === 'function') showToast("Wallet already connected", "info");
*/


window.handleProfileClick = async function(ev){
    ev?.stopPropagation();
    
    // 1. Check Wallet
    if (!meshWallet) {
        if (typeof showToast === 'function') showToast("Connect wallet first", "error");
        return;
    }

    // 2. Ensure Profile Exists
    if (!currentUser.username) {
        await checkUser();
        if (!currentUser.username) {
            getEl('roleModal').style.display = 'flex';
            return;
        }
    }

    // 3. Toggle Menu
    const d = getEl('profileDropdown');
    if (!d) return;

    const isOpen = (d.style.display === 'flex');
    if (isOpen) {
        d.style.display = 'none';
        return;
    }

    // 4. Build Menu Content
    d.innerHTML = '';

    // -- Option 1: Main Dashboard View --
    if (currentUser.role === 'collector') {
        d.innerHTML += `<div class="menu-item" onclick="showDashboard('wallet')"><i class="fas fa-wallet"></i> My Wallet</div>`;
    } else {
        d.innerHTML += `<div class="menu-item" onclick="showDashboard('collections')"><i class="fas fa-th-large"></i> My Creations</div>`;
    }

    // -- Option 2: Enter Studio (Artist Only) --
    if (currentUser.role === 'artist') {
        d.innerHTML += `<div class="menu-item" onclick="enterIDPStudio()"><i class="fas fa-palette"></i> Enter IDP Studio</div>`;
    }

    // -- Option 3: Edit Profile --
    d.innerHTML += `<div class="menu-item" onclick="handleNavEdit()"><i class="fas fa-user-edit"></i> Edit Profile</div>`;

    // -- Option 4: Switch Context (Artist <-> Wallet) --
    if (currentUser.role !== 'collector') {
        d.innerHTML += `<div class="menu-item" onclick="showDashboard('wallet')"><i class="fas fa-wallet"></i> My Wallet</div>`;
    } else {
        d.innerHTML += `<div class="menu-item" onclick="startProfileSetup('artist')"><i class="fas fa-paint-brush"></i> Create Artist Profile</div>`;
    }

    // -- Footer --
    d.innerHTML += `<div style="height:1px; background:rgba(255,255,255,0.1); margin:5px 0;"></div>`;
    d.innerHTML += `<div class="menu-item"><i class="fas fa-question-circle"></i> Get Help</div>`;
    d.innerHTML += `<div class="menu-item" onclick="disconnectWallet()"><i class="fas fa-sign-out-alt"></i> Disconnect</div>`;

    // Show
    d.style.display = 'flex';
};


// ==========================================
    // NOTIFICATION SYSTEM (Tabs + Pagination)
    // ==========================================
    
    // State management for notifications
    let notifState = {
        all: [],       // All raw notifications
        activeTab: 'new', // 'new' or 'seen'
        limit: 5,      // Items to show
        hasUnread: false
    };

    // 1. Toggle the Dropdown
    window.toggleNotifDropdown = () => {
        const d = getEl('notifList');
        if (!d) return;

        if (d.style.display === 'flex') {
            d.style.display = 'none';
        } else {
            d.style.display = 'flex';
            // Reset limit when opening
            notifState.limit = 5; 
            renderNotifUI();
            
            // Hide Red Dot visually once opened
            const dot = getEl('headerNotifDot');
            if (dot) dot.style.display = 'none';
        }
    };

    // 2. Switch Tabs (New vs Seen)
    window.switchNotifTab = (tab) => {
        notifState.activeTab = tab;
        notifState.limit = 5; // Reset pagination on tab switch
        renderNotifUI();
    };

    // 3. Load More Items
    window.loadMoreNotifs = () => {
        notifState.limit += 5;
        renderNotifUI();
    };

    // 4. Main Render Function (Called by loadDashboard)
    function renderNotifications(notifs) {
        // Store data
        notifState.all = Array.isArray(notifs) ? notifs : [];
        
        // Check if there are any unread for the red dot
        // Assuming 'seen' property exists. If not, defaults to false (New)
        const unreadCount = notifState.all.filter(n => !n.seen).length;
        
        const dot = getEl('headerNotifDot');
        if (dot) dot.style.display = unreadCount > 0 ? 'block' : 'none';
        
        // Initial render logic is handled when user clicks bell, 
        // but we prep the data here.
    }

    // 5. Render the Internal UI (Tabs + List)
    function renderNotifUI() {
        const container = getEl('notifList');
        if (!container) return;

        // A. Filter Data based on Tab
        const isNewTab = notifState.activeTab === 'new';
        const filtered = notifState.all.filter(n => isNewTab ? !n.seen : n.seen);

        // B. Slice for Pagination
        const visibleItems = filtered.slice(0, notifState.limit);
        const hasMore = filtered.length > notifState.limit;

        // C. Build HTML
        let html = `
            <div class="notif-header">
                <div class="notif-tab ${isNewTab ? 'active' : ''}" onclick="switchNotifTab('new')">New (${notifState.all.filter(n=>!n.seen).length})</div>
                <div class="notif-tab ${!isNewTab ? 'active' : ''}" onclick="switchNotifTab('seen')">Seen</div>
            </div>
            <div class="notif-list-container">
        `;

        if (visibleItems.length === 0) {
            html += `<div style="padding:20px; text-align:center; color:#666; font-size:0.9rem;">
                        ${isNewTab ? 'You are all caught up!' : 'No seen notifications.'}
                     </div>`;
        } else {
            visibleItems.forEach(n => {
                // Escape HTML to prevent breaking layout
                const safeMsg = String(n.msg || '').replace(/</g, '&lt;');
                html += `<div class="notif-item ${n.type || ''} ${n.seen ? 'read' : ''}">${safeMsg}</div>`;
            });
        }

        // "See More" Button
        if (hasMore) {
            html += `<button class="notif-load-more" onclick="loadMoreNotifs()">See More (${filtered.length - notifState.limit} remaining)</button>`;
        }

        html += `</div>`; // Close list-container

        container.innerHTML = html;
    }

    window.showDashboard = (tab) => {
        const drop = getEl('profileDropdown');
        if(drop) drop.style.display = 'none';
        
        getEl('landingPage').classList.add('hidden');
        getEl('studioRoot').classList.add('hidden');
        getEl('dashboardRoot').classList.remove('hidden');
        getEl('profilePanel').classList.remove('hidden');
        
        window.switchDashTab(tab);
    };

    // --- TABS & VIEWS ---
window.switchDashTab = async (tab) => {
    window._returnToLanding = false;
    if (currentUser?.role === 'collector' && tab === 'collections') tab = 'wallet';
    currentTab = tab;
    
    getEl('tabCollections').classList.toggle('active', tab === 'collections');
    getEl('tabWallet').classList.toggle('active', tab === 'wallet');

    const catBar = getEl('walletCategoryBar');
    const colDrops = getEl('collectionsDropdowns');
    const walDrops = getEl('walletDropdowns');
    const delGroup = getEl('deleteGroup');

    if (tab === 'collections') {
        if(catBar) catBar.classList.add('hidden');
        if(walDrops) walDrops.classList.add('hidden');
        if(colDrops) colDrops.style.display = 'flex'; 
        
        // studio
        const btnStudio = getEl('btnEnterStudio');
        const role = currentUser.role || 'artist';
        if (btnStudio) {
            btnStudio.style.display = (role === 'artist') ? 'flex' : 'none';
        }
        
        if(delGroup) delGroup.classList.remove('hidden'); 
        renderCollections(currentUser.profileData?.collections || []);
    } else {
        if(catBar) catBar.classList.remove('hidden');
        if(walDrops) walDrops.classList.remove('hidden');
        // FIX: Hide Collection Dropdowns
        if(colDrops) colDrops.style.display = 'none';
        
        // FIX: Clear grid immediately so "My Collections" items don't linger
        getEl('collectionsGrid').innerHTML = '<div class="grid-item" style="color:#666;">Loading wallet...</div>';
        
        walletPageIndex = 0; 
        isWalletLoading = false; // Release lock just in case
        
        
        // Initial Load Logic
        await syncWalletData();
    }
    window.dispatchEvent(new Event('resize'));
};


    // ==========================================
    // 4. COLLECTION RENDERING
    // ==========================================

    //function buildMediaPreview(meta, container, fallback) {
function buildMediaPreview(meta, container, fallback) {
  buildMediaPreviewInto(meta, container, fallback || '../fre5hfence/RF5.png?v=2', true, false);
}

    // }
    
async function loadDashboard(p) {
    let collections = [];
    
    // 1. Always Fetch Live Data First (To get the base collections list)
    if (currentUser.username) {
        try {
            const liveRes = await fetch('get_user_data.php', { method:'POST', body:JSON.stringify({ username:currentUser.username }) });
            const liveData = await liveRes.json();
            
            p = liveData.profile || {};
            collections = liveData.collections || [];

            // Only look for draft if we haven't just successfully pushed
if (currentUser.isDraft !== false) { 
                try {
                    const draftRes = await fetch(`${currentUser.username}/profile_draft.json?t=${Date.now()}`);
                    if (draftRes.status === 404) {
                        // Draft missing is normal/good state. Do nothing.
                    } else if (draftRes.ok) {
                        const draftData = await draftRes.json();
                        p = { ...p, ...draftData }; 
                        markUnsaved(); 
                        console.log("Loaded from Draft (Merged)");
                    }
                } catch (e) { /* Ignore network errors for draft */ }
            }
        } catch (e) { console.error("Load Error", e); }
    }

    // Ensure combinations exists
    if (!p || typeof p !== 'object') p = {};
    if (!Array.isArray(p.combinations)) p.combinations = [];

    // 3. Save to memory
    currentUser.profileData = p; 
    currentUser.profileData.collections = collections; 

    renderCollections(collections);
    
    getEl('setupPanel').classList.add('hidden');
    getEl('profilePanel').classList.remove('hidden');
    
    getEl('displayName').textContent = p.displayName;
    getEl('displayBio').textContent = p.bio;
    getEl('displayLocation').textContent = p.location;
    
    let src = p.pfp;
    if(!src.startsWith('/') && !src.startsWith('http')) src = currentUser.username + '/' + src;
    getEl('displayPfp').src = src;
    getEl('hiddenExistingPfp').value = p.pfp;
    
    const fullUrl = "https://therefreshcnft.com/idp/" + currentUser.username;
    getEl('displayUrlText').textContent = fullUrl;
    
    const wNameSafe = encodeURIComponent(connectedWalletName || "Connected");
    getEl('displayUrlLink').href = `${fullUrl}?addr=${currentUser.address}&name=${wNameSafe}`;
    
    getEl('cancelEditBtn').classList.remove('hidden');
    
    // Attach Autosave Listeners
    const iName = getEl('inputName');
    const iBio = getEl('inputBio');
    const iLocation = getEl('inputLocation');
    
iName.addEventListener('input', () => window.triggerAutosave('dashboard'));
iBio.addEventListener('input',  () => window.triggerAutosave('dashboard'));
iLocation.addEventListener('input',  () => window.triggerAutosave('dashboard'));

    
    // Pre-load Wallet Stats
    if(currentUser.username) {
        fetch(`${currentUser.username}/wallet/wallet.json?t=${Date.now()}`)
        .then(r => r.json())
        .then(data => {
            const totalA = data.reduce((acc, c) => acc + (c.count||0), 0);
            updateWalletHeader(totalA, data);
            cachedWalletCollections = data; 
        })
        .catch(() => {}); 
    }
}

function getBadgeHtml(type) {
        const t = (type || 'owned').toLowerCase();
        const isGreen = (t === 'claimed' || t === 'created');
        const colorClass = isGreen ? 'green' : 'yellow';
        const tooltip = isGreen ? 'Verified' : 'Verified\nImported';
        return `<div class="verified-badge ${colorClass}" data-tooltip="${tooltip}"></div>`;
    }


async function renderCollections(cols) {
    const grid = getEl('collectionsGrid');
    
    // 1. Reset Modes & Selection
    isDeleteMode = false; 
    selectedToDelete.clear();
    isCombineMode = false;
    selectedToCombine.clear();
    updateHeaderControls(); 

    if (!cols || !cols.length) {
        grid.innerHTML = '<div class="grid-item" style="color:#666;">No collections yet.</div>';
        return;
    }

    // 2. --- FILTER LOGIC FOR GROUPS ---
    let displayList = [];
    const combinations = currentUser.profileData.combinations || [];

    // HELPER: Recursive Count Function
    function getGroupCount(group) {
        let total = 0;
        if (!group.policies) return 0;
        
        group.policies.forEach(id => {
            const childGroup = combinations.find(g => g.id === id);
            if (childGroup) {
                total += getGroupCount(childGroup);
            } else {
                const col = cols.find(c => c.id === id);
                if (col) total += (parseInt(col.count, 10) || 0);
            }
        });
        return total;
    }
    
    // HELPER: Recursive Thumb Resolver (Specific Group Thumb)
    function getGroupThumb(group) {
        if (!group || !Array.isArray(group.policies)) return '';
        for (const id of group.policies) {
            const childGroup = combinations.find(g => g.id === id);
            if (childGroup) {
                const t = getGroupThumb(childGroup);
                if (t) return t;
                continue;
            }
            const col = cols.find(c => c.id === id);
            if (col && col.thumb) return col.thumb;
        }
        return '';
    }

    // HELPER: Random Preview Source Resolver
    // Flattens the group tree and picks a random collection ID to use for the cover
    function getRandomGroupPreviewSource(group) {
        if (!group || !Array.isArray(group.policies)) return null;
        
        let leafIds = [];
        
        function gatherLeaves(g) {
            if(!g.policies) return;
            g.policies.forEach(id => {
                const childGroup = combinations.find(x => x.id === id);
                if (childGroup) {
                    gatherLeaves(childGroup);
                } else {
                    // Check if it's a valid collection in our list
                    if (cols.find(c => c.id === id)) leafIds.push(id);
                }
            });
        }
        
        gatherLeaves(group);
        
        if (leafIds.length === 0) return null;
        
        // Pick random
        const randId = leafIds[Math.floor(Math.random() * leafIds.length)];
        return cols.find(c => c.id === randId);
    }

    if (currentGroupViewId) {
        // --- VIEWING INSIDE A GROUP ---
        const group = combinations.find(g => g.id === currentGroupViewId);
        if (group) {
            group.policies.forEach(id => {
                const nestedGroup = combinations.find(g => g.id === id);
                if (nestedGroup) {
                    const src = getRandomGroupPreviewSource(nestedGroup);
                    displayList.push({
                        id: nestedGroup.id,
                        name: nestedGroup.name,
                        count: getGroupCount(nestedGroup),
                        thumb: getGroupThumb(nestedGroup),
                        previewColId: src ? src.id : null,
                        type: 'created',
                        isGroup: true
                    });
                } else {
                    const col = cols.find(c => c.id === id);
                    if (col) displayList.push(col);
                }
            });
            
            // "Back" button
            grid.innerHTML = ''; 
            const backCard = document.createElement('div');
            backCard.className = 'collection-card';
            backCard.innerHTML = `<div style="height:250px; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#8899ac;"><i class="fas fa-arrow-left" style="font-size:2rem; margin-bottom:10px;"></i>Back</div>`;
            backCard.onclick = () => { 
                currentGroupViewId = null; 
                renderCollections(currentUser.profileData.collections); 
            };
            grid.appendChild(backCard);
        } else {
             currentGroupViewId = null; 
             renderCollections(currentUser.profileData.collections);
             return;
        }
    } else {
        // --- ROOT VIEW ---
        grid.innerHTML = ''; 
        
        const hiddenIds = new Set();
        combinations.forEach(g => {
            if(g.policies) {
                g.policies.forEach(id => hiddenIds.add(id));
            }
        });

        // Add Standalone Collections
        cols.forEach(c => {
            if (!hiddenIds.has(c.id)) displayList.push(c);
        });

        // Add Top-Level Groups
        combinations.forEach(g => {
            if (!hiddenIds.has(g.id)) {
                const src = getRandomGroupPreviewSource(g);
                displayList.push({
                    id: g.id,
                    name: g.name,
                    count: getGroupCount(g),
                    thumb: getGroupThumb(g),
                    previewColId: src ? src.id : null,
                    type: 'created',
                    isGroup: true
                });
            }
        });
    }

    // 3. --- INITIALIZE LAZY LOAD ---
    colBatchList = displayList;
    colBatchIndex = 0;
    colBatchLoading = false;
    
    const totalC = displayList.length;
    const totalA = displayList.reduce((acc, c) => acc + (parseInt(c.count)||0), 0);
    const statsEl = getEl('walletStatsDisplay');
    if(statsEl) statsEl.textContent = `Collections|Assets: ${totalC}|${totalA}`;
    
    // --- POPULATE COLLECTIONS JUMP DROPDOWN ---
    const colSel = getEl('colCollectionSelect');
    if (colSel) {
        colSel.innerHTML = '<option value="">Jump...</option>';
        const sortedForDrop = [...displayList].sort((a,b) => a.name.localeCompare(b.name));
        sortedForDrop.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c.id;
            opt.textContent = c.name;
            colSel.appendChild(opt);
        });
    }
    
    await renderNextColBatch();
}


// --- NEW: Helper to render chunks of collections ---
async function renderNextColBatch() {
    if (colBatchLoading || colBatchIndex >= colBatchList.length) return;
    colBatchLoading = true;

    const grid = getEl('collectionsGrid');
    const batch = colBatchList.slice(colBatchIndex, colBatchIndex + colPageSize);
    const emptyMsg = grid.querySelector('.grid-item');
    if (emptyMsg && batch.length > 0) emptyMsg.remove();

    for (const c of batch) {
        // Auto-sync empty collections once, BUT ONLY IF NOT A GROUP
        if (!c.isGroup && c.count === 0 && !attemptedSyncs.has(c.id)) {
            attemptedSyncs.add(c.id);
            syncCollection(c);
        }
        
        const card = document.createElement('div');
        card.className = 'collection-card';
        card.dataset.id = c.id; 
        
        // MARKER FOR STEP 3
        if(c.isGroup) card.dataset.isGroup = 'true';

        // Generate Thumb
        const thumb = c.thumb || '';
        if (thumb) card.classList.add('has-preview');

        const thumbUrl = thumb ? formatUrl(thumb) : '';     
        let thumbInner;
        
        if (!thumbUrl) {
          thumbInner = `<img src="../fre5hfence/RF5.png?v=2" class="thumb-media thumb-media-img" loading="lazy">`;
        }
        else if (thumbUrl.startsWith('data:text/html')) {
          thumbInner = `
            <div class="html-thumb-wrapper">
              <iframe src="${thumbUrl}" class="thumb-media thumb-media-html" loading="lazy"></iframe>
            </div>`;
        }
        else {
          thumbInner = `
            <img src="${thumbUrl}" class="thumb-media thumb-media-img" loading="lazy"
            onerror="const v=document.createElement('video');v.src=this.src;v.className='thumb-media thumb-media-video';v.playsInline=true;v.muted=true;v.loop=true;v.autoplay=true;v.preload='metadata';v.controls=false;this.replaceWith(v);">`;
        }

        // --- UPDATED META HTML LOGIC ---
        let metaHtml = '';
        if (c.isGroup) {
            metaHtml = `${c.count} Assets (Combined)`;
        } else {
            metaHtml = c.count > 0 
                ? c.count + ' Assets' 
                : `<button class="tool-btn" style="padding:2px 8px; font-size:0.7rem;" onclick="event.stopPropagation(); syncCollection({id:'${c.id}', name:'${c.name}'})">Sync Now</button>`;
        }

        card.innerHTML = `
            <input type="checkbox" class="del-check-input" value="${c.id}">
            <div class="col-thumb">${thumbInner}</div>
            <div class="col-info">
            <div class="col-title">${c.name}</div>
                <div class="col-meta">
                    ${metaHtml}
                </div>
            </div>
            ${!c.isGroup ? getBadgeHtml(c.type) : ''} `;

        // Interaction Logic
        const checkbox = card.querySelector('.del-check-input');
        checkbox.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if (isDeleteMode) togglePolicySelection(c.id);
            else if (isCombineMode) toggleCombineSelection(c.id);
        });

        card.addEventListener('click', (e) => {
            if (isDeleteMode) {
                checkbox.checked = !checkbox.checked;
                togglePolicySelection(c.id);
                return;
            } 
            if (isCombineMode) {
                 checkbox.checked = !checkbox.checked;
                 toggleCombineSelection(c.id);
                 return;
            }

            if (e.target.closest('.col-info')) {
                if (c.isGroup) {
                    currentGroupViewId = c.id;
                    renderCollections(currentUser.profileData.collections);
                } else {
                    openAssetBrowser(c);
                }
            }
        });

        grid.appendChild(card);

        if (!c.isGroup) {
          loadCollectionPreview(c, card).catch(err => {
            console.error('Preview error', c.id, err);
          });
        } else if (c.previewColId) {
          const srcCol = colBatchList.find(x => x.id === c.previewColId) || (currentUser.profileData.collections || []).find(x => x.id === c.previewColId);
          // Fallback to searching the wallet/all list passed in if needed, but usually profile data is enough
          
          if (srcCol) {
            loadCollectionPreview(srcCol, card).catch(err => {
              console.error('Group preview error', c.id, err);
            });
          }
        }
    }

    colBatchIndex += batch.length;
    colBatchLoading = false;

    if (grid.scrollHeight <= grid.clientHeight + 100 && colBatchIndex < colBatchList.length) {
        renderNextColBatch();
    }
}


    // --- HELPER: pull any inline data: URI from metadata (src/files/image) ---
    function getInlineDataUriFromMetadata(meta) {
        if (!meta || typeof meta !== 'object') return '';

        // src as string
        if (typeof meta.src === 'string' && meta.src.startsWith('data:')) {
            return meta.src;
        }
        // src as array
        if (Array.isArray(meta.src)) {
            const found = meta.src.find(v => typeof v === 'string' && v.startsWith('data:'));
            if (found) return found;
        }

        // files array: look for f.src starting with data:
        if (Array.isArray(meta.files)) {
            for (const f of meta.files) {
                if (!f || typeof f !== 'object') continue;
                if (typeof f.src === 'string' && f.src.startsWith('data:')) {
                    return f.src;
                }
            }
        }

        // image could itself be a data:image
        let imgField = meta.image;
        if (Array.isArray(imgField)) {
            imgField = imgField.find(v => typeof v === 'string') || null;
        }
        if (typeof imgField === 'string' && imgField.startsWith('data:image/')) {
            return imgField;
        }

        return '';
    }

    // --- HELPER: your base64 thumbnail builder (HTML or image) ---
    function buildBase64ThumbMedia(meta) {
        const dataUri = getInlineDataUriFromMetadata(meta);
        if (!dataUri) return ''; // no inline base64 found

        // HTML on-chain
        if (dataUri.startsWith('data:text/html')) {
            return `
              <iframe 
                src="${dataUri}" 
                class="thumb-media thumb-media-html" 
                loading="lazy"
              ></iframe>`;
        }

        // Image on-chain (png, svg+xml, jpeg, etc)
        if (dataUri.startsWith('data:image/')) {
            return `
              <img 
                src="${dataUri}" 
                class="thumb-media thumb-media-img" 
                loading="lazy"
              />`;
        }

        // Other data types -> let normal image logic handle it
        return '';
    }

    function deriveCollectionName(displayName) {
        if (!displayName || typeof displayName !== 'string') return 'Collection';
        const m = displayName.match(/^(.*?)(?:\s*#\d+)?\s*$/);
        if (m && m[1]) {
            const base = m[1].trim();
            return base || displayName.trim();
        }
        return displayName.trim();
    }
    

async function loadCollectionPreview(col, cardEl) {
    if (!currentUser || !currentUser.username) return;
    
    // Prevent double-loading
    if (cardEl.dataset.previewLoaded === 'true') return;
    cardEl.dataset.previewLoaded = 'true';

    const thumbContainer = cardEl.querySelector('.col-thumb');
    
    try {
        let path = `${currentUser.username}/policies/${col.id}.json`;
        if (col.type === 'wallet') path = `${currentUser.username}/wallet/${col.id}.json`;
        
        const res = await fetch(`${path}?t=${Date.now()}`);
        if (!res.ok) throw new Error("File not found");

        const pData = await res.json();
        const assets = Array.isArray(pData.assets_cache) ? pData.assets_cache : [];
        
        if (!assets.length) { cardEl.remove(); return; }

        // A. Resolve Metadata
        // Prioritize assets with images/files
        let chosenAsset = assets.find(a => {
            const m = a.onchain_metadata || a.metadata || {};
            return (m.image || (m.files && m.files.length > 0));
        }) || assets[0];

        const meta = chosenAsset.onchain_metadata || chosenAsset.metadata || {};
        
        // B. Name Fix
        let assetName = (meta.name || '').trim() || hexToAsciiSafe(chosenAsset.asset_name || '') || 'Asset';
        let cleanName = pData.meta?.name || 'Collection';
        if(['Verified Collection','Untitled','Collection','Wallet Collection'].includes(cleanName)) {
            cleanName = deriveCollectionName(assetName);
        }

        if (cardEl.dataset.isGroup !== 'true') {
            const titleEl = cardEl.querySelector('.col-title');
            if (titleEl) titleEl.textContent = cleanName;
        }
        
        const metaEl = cardEl.querySelector('.col-meta');
        
        // FIX: Preserve the "(Combined)" text for groups
        if (metaEl && cardEl.dataset.isGroup !== 'true') {
             metaEl.textContent = `${assets.length} Assets`;
        }
        
        // --- FIX: Update Dropdown Options Immediately ---
        // This ensures "Verified Collection" is replaced with the real name in the Jump menu
        const opt1 = document.querySelector(`#walletCollectionSelect option[value="${col.id}"]`);
        if(opt1) opt1.textContent = cleanName;
        
        const opt2 = document.querySelector(`#colCollectionSelect option[value="${col.id}"]`);
        if(opt2) opt2.textContent = cleanName;
        
        // Update memory object so sorting works later
        col.name = cleanName;
        // ------------------------------------------------

        // Update global cache for dropdown (Legacy support)
        const cachedItem = cachedWalletCollections.find(c => c.id === col.id);
        if(cachedItem && cachedItem.name !== cleanName) {
            cachedItem.name = cleanName; 
            if(!window._dropTimer) {
                window._dropTimer = setTimeout(()=>{ 
                    updateWalletHeader(cachedWalletCollections.reduce((a,b)=>a+(b.count||0),0), cachedWalletCollections);
                    window._dropTimer = null;
                }, 1500);
            }
        }

        // C. MEDIA LOGIC: STATIC IMAGE FIRST
        // 1. Determine Image URL
        let imgUrl = '';
        if (meta.image) {
            let raw = Array.isArray(meta.image) ? meta.image.join('') : meta.image;
            if(raw) imgUrl = formatUrl(raw);
        }
        // Fallback to files if no image key
        if (!imgUrl && meta.files && meta.files.length) {
             const f = meta.files.find(f => f.mediaType && f.mediaType.includes('image'));
             if(f && f.src) imgUrl = formatUrl(Array.isArray(f.src) ? f.src.join('') : f.src);
        }
        if (!imgUrl) imgUrl = '../fre5hfence/RF5.png?v=2'; // Final Fallback

        // 2. Render Image
        thumbContainer.innerHTML = '';
        const img = document.createElement('img');
        img.className = 'thumb-media thumb-media-img';
        img.loading = 'lazy';
        setImgSrcWithGateways(img, imgUrl, true);
        thumbContainer.appendChild(img);

        // D. INTERACTION: LOAD REAL MEDIA ON HOVER
        // Check if we have HTML or Video
        let interactiveSrc = '';
        let isVideo = false;
        let isHtml = false;

        if (meta.files && meta.files.length) {
            const f = meta.files[0];
            const type = (f.mediaType || '').toLowerCase();
            const rawSrc = Array.isArray(f.src) ? f.src.join('') : f.src;
            const url = formatUrl(rawSrc);

            if (type.includes('html') || url.includes('html') || url.startsWith('data:text/html')) {
                interactiveSrc = url; isHtml = true;
            } else if (type.includes('video') || url.includes('.mp4') || url.startsWith('data:video')) {
                interactiveSrc = url; isVideo = true;
            }
        }

        if (isHtml || isVideo) {
            thumbContainer.addEventListener('mouseenter', () => {
                // If media already exists, do nothing
                if (thumbContainer.querySelector('iframe, video')) return;

                if (isHtml) {
                    thumbContainer.innerHTML = `<div class="html-thumb-wrapper"><iframe src="${interactiveSrc}" class="thumb-media thumb-media-html"></iframe></div>`;
                } else if (isVideo) {
                    const v = document.createElement('video');
                    v.className = 'thumb-media thumb-media-video';
                    v.setAttribute('autoplay', '');
                    v.setAttribute('loop', '');
                    v.setAttribute('muted', '');
                    v.setAttribute('playsinline', '');
                    v.muted = true; 
                    setVideoSrcWithGateways(v, interactiveSrc);
                    thumbContainer.innerHTML = '';
                    thumbContainer.appendChild(v);
                }
            });

            thumbContainer.addEventListener('mouseleave', () => {
                // Destroy media, restore image
                thumbContainer.innerHTML = '';
                thumbContainer.appendChild(img);
            });
        }

        // E. FADE IN (Wait for Image Load)
        if(img.complete && img.naturalHeight !== 0) {
            cardEl.style.opacity = '1';
        } else {
            img.onload = () => cardEl.style.opacity = '1';
            img.onerror = () => { img.src = '../fre5hfence/RF5.png?v=2'; cardEl.style.opacity = '1'; };
        }

    } catch (err) {
        cardEl.remove(); // Don't show broken cards
    }
}

async function syncCollection(col) {
    showToast(`Syncing ${col.name}... (This grabs all traits)`, "info");
    
    try {
        // 1. Fetch the ID List (Fast, but raw)
        const pRes = await fetch(`get_assets.php?policy_id=${col.id}`);
        let basicAssets = await pRes.json();
        
        // FIX: If API returns error/null, force empty array
        if (!Array.isArray(basicAssets)) basicAssets = [];

if (basicAssets.length === 0) {
            // Do NOT save empty array to server, just stop.
            // This prevents wiping valid data if the API is temporarily down.
            showToast("No assets found (or API busy).", "error"); 
            return;
        }

        // 2. DEEP SCAN: Fetch details for every asset to get Traits
        // We process in batches of 5 to ensure stability
        const enrichedAssets = [];
        const BATCH_SIZE = 1;
        const total = basicAssets.length;

        // Note: Since this runs in background, we log progress to console
        console.log(`Starting Deep Scan for ${col.name}: ${total} assets`);

        for (let i = 0; i < total; i += BATCH_SIZE) {
            const batch = basicAssets.slice(i, i + BATCH_SIZE);
            const promises = batch.map(async (item) => {
                try {
                    const unit = item.asset || ((item.policy_id||'') + (item.asset_name||''));
                    
                    // Fetch full metadata
                    const dRes = await fetch(`get_asset_detail.php?asset=${unit}`);
                    const detail = await dRes.json();
                    
                    const meta = detail.onchain_metadata || detail.metadata || {};
                    const traits = extractTraitsFromMeta(meta);

                    // Return merged item
                    return {
                        ...item,
                        onchain_metadata: meta, 
                        traits: traits
                    };
                } catch (err) {
                    console.error("Scan error", item.asset);
                    return item; // Fallback to basic if fetch fails
                }
            });

            const results = await Promise.all(promises);
            enrichedAssets.push(...results);
        }

        // 3. Save the Enriched Data
        await fetch('save_policy.php', {
            method: 'POST',
            body: JSON.stringify({
                action: 'cache_assets',
                username: currentUser.username,
                identity: currentUser.identity,
                policyId: col.id,
                assets: enrichedAssets
            })
        });

showToast(`Sync Complete: ${col.name}`, "success");
        // Reload removed. We will reload dashboard data instead.
        loadDashboard(); 

    } catch (e) {
        console.error(e);
        showToast("Sync Error", "error");
    }
}
    
// ==========================================
// 5. ASSET BROWSER (Pagination)
// ==========================================

async function openAssetBrowser(col, isWalletMode = false) {
    currentCollection = col;

    // INJECT BADGE HTML INTO TITLE
    getEl('browserTitle').innerHTML = `${col.name} ${getBadgeHtml(col.type)}`;
    
    getEl('assetBrowserModal').style.display = 'flex';

  const grid = getEl('assetGrid');
  grid.innerHTML = '<div style="color:#fff;">Loading assets...</div>';

try {
        // Determine path based on mode
    const path = isWalletMode 
        ? `${currentUser.username}/wallet/${col.id}.json` 
        : `${currentUser.username}/policies/${col.id}.json`;

    const res = await fetch(`${path}?t=${Date.now()}`);
    const pData = await res.json();
    const assets = Array.isArray(pData.assets_cache) ? pData.assets_cache : [];

    currentCollectionAssetsSummary = assets;
    currentCollectionAssetsDetail = new Array(assets.length).fill(null);
    
     traitPairsSet.clear();
    activePropertyFilterPair = 'ALL'; 

    updateAssetCountLabel(assets.length, assets.length);

    const pageSizeSel = getEl('assetPageSizeSelect');
    assetPageSize = parseInt(pageSizeSel?.value || '10', 10);

    grid.innerHTML = '';

    if (!assets.length) {
      grid.innerHTML = '<div style="color:#fff;">No assets found.</div>';
      return;
    }

refreshPropertyFilterOptions();

// CRITICAL: reset paging state every time a new collection opens
resetAndRenderAssetGrid();
  } catch (err) {
    console.error('Failed to open asset browser', err);
    grid.innerHTML = '<div style="color:#f88;">Error loading assets.</div>';
    grid.scrollTop = 0;
  }
}



// Scroll Handler (lazy-load next matching batch)
const assetGrid = getEl('assetGrid');
if (assetGrid) {
    assetGrid.addEventListener('scroll', () => {
        if (isAssetPageLoading) return; // Use the correct global loading flag

        if (assetGrid.scrollTop + assetGrid.clientHeight >= assetGrid.scrollHeight - 50) {
            // Check against 'currentCollectionAssetsSummary'
            if (currentCollectionAssetsSummary && assetPageIndex < currentCollectionAssetsSummary.length) {
                renderNextAssetPage(); // <--- FIXED: Call the smart function, not the simple one
            }
        }
    });
}

// Page size Handler (hard reset)
const sizeSel = getEl('assetPageSizeSelect');
if (sizeSel) {
    sizeSel.addEventListener('change', () => {
        assetPageSize = parseInt(sizeSel.value, 10) || 10;
        resetAndRenderAssetGrid(); // <--- FIXED: Use the reset helper function
    });
}

// Filter Handler (hard reset)
const filterSel = getEl('propertyFilterSelect');
if (filterSel) {
    filterSel.addEventListener('change', () => {
        activePropertyFilterPair = filterSel.value; // <--- FIXED: Actually update the filter variable
        resetAndRenderAssetGrid(); // <--- FIXED: Use the reset helper function
    });
}
function updateAssetCountLabel(shown, total) {
    const lbl = getEl('assetCountLabel');
    if (!lbl) return;

    if (!total) {
        lbl.textContent = `0 assets`;
        return;
    }

    const pct = Math.round((shown / total) * 100);
    lbl.textContent = `${shown} of ${total} assets (${pct}%)`;
}

window.openAssetDetail = async (assetObj) => {
    const modal = getEl('assetDetailModal');
    const dContent = getEl('detailContent');
    if (!modal || !dContent) return;

    // Small local HTML escape to avoid accidental markup breaking the modal
    const esc = (v) => String(v ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    // 1) Build the entire layout ONCE (no innerHTML += later)
dContent.innerHTML = `
  <div id="dMedia" style="height:300px; margin-bottom:15px; width:100%;"></div>

  <div class="detail-title-row">
    <h2 id="dTitle" style="margin:0;"></h2>
    <button type="button" id="btnMediaFs" onclick="openMediaFullscreen()" title="Fullscreen">
      <i class="fas fa-expand"></i>
    </button>
  </div>

  <div id="dTraitsBox"
       style="text-align:left; background:rgba(255,255,255,0.05); padding:15px; border-radius:12px;">
  </div>
`;


    // 2) Title (use textContent so it can't break layout)
    const titleEl = getEl('dTitle');
    if (titleEl) titleEl.textContent = assetObj.displayName || 'Asset';

    // 3) Traits
    const traits = assetObj.traits || {};
    const traitsEntries = Object.entries(traits);

    const traitsEl = getEl('dTraitsBox');
    if (traitsEl) {
        if (!traitsEntries.length) {
            traitsEl.innerHTML = '<div style="text-align:center; color:#666;">No traits found</div>';
        } else {
            traitsEl.innerHTML = traitsEntries.map(([k, v]) => `
                <div class="detail-meta-row">
                    <span style="color:#8899ac;">${esc(k)}</span>
                    <span style="font-family:monospace; color:#fff;">${esc(v)}</span>
                </div>
            `).join('');
        }
    }

    // 4) Media (same method as grid) — IMPORTANT: do this after layout exists
    buildMediaPreviewInto(assetObj.meta, getEl('dMedia'), '../fre5hfence/RF5.png?v=2', true);

    modal.style.display = 'flex';
};



    // ==========================================
    // 6. WALLET & AUTHENTICATION
    // ==========================================
    function closeWalletDropdown(){
  const wd = getEl('walletDropdown');
  if (wd) wd.classList.remove('show');
}


// Your header already calls onclick="handleWalletClick(event)"
window.handleWalletClick = function(ev){
  ev?.stopPropagation();
  renderWalletDropdown();
  const dd = getEl('walletDropdown');
  if (!dd) return;
  dd.classList.toggle('show');
};

// Auto-reconnect on new tab (only works if wallet stays authorized)
async function autoReconnectWallet(){
  const last = localStorage.getItem(LS_LAST_WALLET);
  if (!last) return;

  const w = window.cardano?.[last];
  if (!w) return;

  try {
    if (typeof w.isEnabled === 'function') {
      const ok = await w.isEnabled();
      if (!ok) return; // don’t pop wallet unexpectedly
    }
    await connectWalletByKey(last);
  } catch (e) {
    console.warn('Auto reconnect failed', e);
  }
}

// call once on load
//autoReconnectWallet();
// Click-away close for wallet dropdown (add once)
document.addEventListener('click', (e) => {
  const wWrap = getEl('walletMenu');      // wrapper div around the trigger + dropdown
  const wDrop = getEl('walletDropdown');  // the dropdown itself
  if (wDrop && wDrop.classList.contains('show')) {
    if (!wWrap || !wWrap.contains(e.target)) {
      wDrop.classList.remove('show');
    }
  }
});


/*
async function handleWalletClick(e){
  if (e) e.stopPropagation();

  const wd = getEl('walletDropdown');
  if (!wd) return;

  // toggle
  const isOpen = wd.classList.contains('show');
  if (isOpen){
    wd.classList.remove('show');
    return;
  }

  // close other dropdown if open
  const pd = getEl('profileDropdown');
  if (pd) pd.style.display = 'none';

  wd.classList.add('show');
  await renderWalletDropdown();
}
*/

/*
async function renderWalletDropdown(){
  const wd = getEl('walletDropdown');
  if (!wd) return;

  wd.innerHTML = '';

  // If connected, show status + disconnect first
  if (window.fre5hGateState?.api && window.fre5hGateState?.walletKey){
    const top = document.createElement('div');
    top.className = 'menu-item';
    top.style.cursor = 'default';
    top.innerHTML = `<i class="fas fa-check-circle" style="color:#4CAF50;"></i> Connected`;
    wd.appendChild(top);

    const disc = document.createElement('div');
    disc.className = 'menu-item';
    disc.innerHTML = `<i class="fas fa-unlink"></i> Disconnect`;
    disc.onclick = () => disconnectWallet_IDP();
    wd.appendChild(disc);

    return;
  }

  // Not connected: list installed wallets (Studio style)
  try{
    const ws = await BrowserWallet.getInstalledWallets();
    ws.forEach(w => {
      const d = document.createElement('div');
      d.className = 'menu-item';
      const displayName = formatWalletName(w.name || w.id || 'Wallet');
      d.innerHTML = `${w.icon ? `<img src="${w.icon}" alt="">` : `<i class="fas fa-wallet"></i>`} ${displayName}`;
      d.onclick = async () => {
        closeWalletDropdown();
        await connectWallet(String(w.id || w.name || '').trim());
      };
      wd.appendChild(d);
    });

    if (!ws.length){
      const none = document.createElement('div');
      none.className = 'menu-item';
      none.style.cursor = 'default';
      none.innerHTML = `<i class="fas fa-exclamation-circle"></i> No wallets found`;
      wd.appendChild(none);
    }
  }catch(e){
    const err = document.createElement('div');
    err.className = 'menu-item';
    err.style.cursor = 'default';
    err.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Wallet scan error`;
    wd.appendChild(err);
  }
}
*/

// Close wallet dropdown when clicking anywhere else
document.addEventListener('click', (e) => {
  const pWrap = document.querySelector('.profile-menu-container');
  const pDrop = getEl('profileDropdown');
  if (pDrop && pDrop.style.display !== 'none') {
    if (!pWrap || !pWrap.contains(e.target)) {
      pDrop.style.display = 'none';
    }
  }
});

    async function populateWalletModal() {
        const s = getEl('modalWalletSelect'); 
        if(!s) return;
        s.innerHTML='<option>Scanning...</option>';
        try {
            const ws = await BrowserWallet.getInstalledWallets();
            s.innerHTML = ws.map(w => `<option value="${w.id}">${formatWalletName(w.name)}</option>`).join('');
            getEl('modalConnectBtn').onclick = () => connectWallet(String(s.value || '').trim());

        } catch(e) { s.innerHTML='<option>Error scanning</option>'; }
    }

async function connectWallet(wid) {
    const pfpBtn = getEl('headerProfileBtn');
    if (pfpBtn) pfpBtn.classList.add('loading-pulse');
    
    try {
        // 1. Visual Feedback: Start Pulse
        if(pfpBtn) {
            pfpBtn.src = "../fre5hfence/RF5.png?v=2"; // Reset to logo while loading
            pfpBtn.classList.add('loading-pulse');
        }

        meshWallet = await BrowserWallet.enable(wid);
        rememberLastWalletKey(wid);
        
        currentUser.address = await meshWallet.getChangeAddress();
        const r = await meshWallet.getRewardAddresses();
        currentUser.identity = r[0] || currentUser.address;

        // Hidden fields for sync
        const hStake = getEl('hiddenStakeKey');
        const hAddr = getEl('hiddenWalletAddress');
        if(hStake) hStake.value = currentUser.identity;
        if(hAddr) hAddr.value = currentUser.address;

        // Metadata
        const wInfo = (await BrowserWallet.getInstalledWallets()).find(w=>w.id===wid);
        connectedWalletName = formatWalletName(wInfo ? wInfo.name : "Wallet");
        
        // Balance
        try {
            // Force close dropdown immediately on click
            getEl('walletDropdown').classList.remove('show');
            const l = await meshWallet.getLovelace();
            const bal = getEl('headerBalance');
            if(bal) {
                bal.textContent = `₳ ${(parseInt(l)/1000000).toFixed(2)}`;
                bal.style.display = 'block';
            }
        } catch(e){}
        
        // Save state
        window.fre5hGateState = window.fre5hGateState || {};
        window.fre5hGateState.walletKey = wid; 
        
        if(window.cardano && window.cardano[wid]) {
            window.fre5hGateState.api = await window.cardano[wid].enable();
        }

        const wm = getEl('walletModal');
        if (wm) wm.style.display = 'none';
        
        // 2. Fetch User Data
        await checkUser();
        
        // 3. Final PFP Update (Force Browser Refresh)
        if(currentUser.username && currentUser.profileData) {
             let pfp = currentUser.profileData.pfp || 'pfp.png';
             // Path logic
             if(!pfp.startsWith('http') && !pfp.startsWith('data:')) {
                  if(pfp.startsWith('/')) pfp = pfp.substring(1);
                  if(!pfp.startsWith(currentUser.username)) pfp = `${currentUser.username}/${pfp}`;
             }
             // Add timestamp to force visual refresh
             if(pfpBtn) pfpBtn.src = `${pfp}?t=${Date.now()}`;
        }

    } catch(e) { 
        console.error(e); 
        showToast("Connection failed", "error");
    } finally {
        // 4. Stop Pulse
        if (pfpBtn) pfpBtn.classList.remove('loading-pulse');
    }
}    

    async function checkUser() {
        try {
            const identity    = (currentUser.identity || window.fre5hGateState?.identity || '').trim();
            const identityHex = (window.fre5hGateState?.identityHex || currentUser.identityHex || '').trim();
            
            const address     = (currentUser.address || window.fre5hGateState?.address || '').trim();
            const addressHex  = (window.fre5hGateState?.addressHex || currentUser.addressHex || '').trim();
            
            const res = await fetch('check_user.php', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ identity, identityHex, address, addressHex })
            });
            const d = await res.json();
            if(d.found) {
                currentUser.username = d.username;
                currentUser.role = d.data.role || 'artist';
                await loadDashboardData(d.data);
            }
        } catch(e) { console.error("Check User", e); }
    }

window.disconnectWallet = async () => {
    // 1. Reset User State
    currentUser = { address: null, identity: null, username: null, role: 'artist' };
    connectedWalletName = "Wallet";
    meshWallet = null;
    
    // 2. Reset View to Landing Page
    getEl('landingPage').classList.remove('hidden');
    getEl('dashboardRoot').classList.add('hidden');
    getEl('studioRoot').classList.add('hidden');
    getEl('setupPanel').classList.add('hidden');
    
      try {
    sessionStorage.removeItem(RF_SESSION_OK_KEY);
    sessionStorage.removeItem(RF_SESSION_TS_KEY);
    // Optional: also forget last wallet completely
    // localStorage.removeItem(RF_LAST_WALLET_KEY);
  } catch(e){}
    
    // 3. Force Close Dropdowns
    const profileDrop = getEl('profileDropdown');
    if(profileDrop) profileDrop.style.display = 'none';

    const walletDrop = getEl('walletDropdown');
    if (walletDrop) walletDrop.classList.remove('show');
    
    // 4. Reset Header Elements
    const bal = getEl('headerBalance');
    if(bal) bal.style.display = 'none';
    
    // Reset PFP to default
    const pfpBtn = getEl('headerProfileBtn');
    if(pfpBtn) pfpBtn.src = "../fre5hfence/RF5.png?v=2";
    
    // 5. Clean URL
    window.history.pushState({}, document.title, window.location.pathname);
    
    showToast("Wallet Disconnected", "info");
};
async function loadDashboardData(data, skipDraft = false) {
        let collections = [];
        let profile = data;

        // 1. If data is missing/incomplete, fetch Live Data
        if (!data || !data.collections) {
             try {
                 const r = await fetch('get_user_data.php', { method:'POST', body:JSON.stringify({username:currentUser.username})});
                 const fullData = await r.json();
                 if(fullData.profile) profile = fullData.profile;
                 if(fullData.collections) collections = fullData.collections;
             } catch(e) { console.error(e); }
        } else {
            collections = data.collections;
        }

// 2. --- FIX: CHECK FOR DRAFT AND MERGE ---
        // Only look for draft if we are NOT skipping it AND we haven't explicitly set isDraft=false
if (!skipDraft && currentUser.isDraft !== false) {
            try {
                const draftRes = await fetch(`${currentUser.username}/profile_draft.json?t=${Date.now()}`);
                
                // Explicitly handle 404 (No draft exists -> Use Live Profile -> State is Saved)
                if (draftRes.status === 404) {
                    markAllSaved(); 
                } 
                // Handle 200 (Draft exists -> Merge Data -> State is Unsaved)
                else if (draftRes.ok) {
                    const draftData = await draftRes.json();
                    profile = { ...profile, ...draftData }; 
                    setTimeout(() => markUnsaved(), 500);
                    dirtyFlags.profile = true;
                    console.log("Loaded from Draft (Merged)");
                }
            } catch (e) { 
                // Ignore network/parsing errors, default to live profile
            }
        }
        
        
        // 3. Save to memory
        currentUser.profileData = profile; 
        currentUser.profileData.collections = collections; 
        
        // UI Updates
        getEl('displayName').textContent = profile.displayName || currentUser.username;
        getEl('displayBio').textContent = profile.bio || '';
        getEl('displayLocation').textContent = profile.location || '';
        getEl('displayUrlText').textContent = `https://therefreshcnft.com/idp/${currentUser.username}`;
        
        // Links
        const wNameSafe = encodeURIComponent(connectedWalletName || "Connected");
        const linkEl = getEl('displayUrlLink');
        if(linkEl) linkEl.href = `https://therefreshcnft.com/idp/${currentUser.username}?addr=${currentUser.address}&name=${wNameSafe}`;
        
        let pfpFile = profile.pfp || 'pfp.png';
        if(!pfpFile.startsWith('http') && !pfpFile.startsWith('data:')) {
            if(pfpFile.startsWith('/')) pfpFile = pfpFile.substring(1);
            if(!pfpFile.startsWith(currentUser.username)) pfpFile = `${currentUser.username}/${pfpFile}`;
        }
        getEl('displayPfp').src = pfpFile + "?t=" + Date.now();
        // Update the header button PFP as well
        const headerBtn = getEl('headerProfileBtn');
        if (headerBtn) headerBtn.src = pfpFile + "?t=" + Date.now();
        getEl('hiddenExistingPfp').value = profile.pfp;
        
        getEl('inputName').value = profile.displayName || '';
        getEl('inputBio').value = profile.bio || '';
        getEl('inputLocation').value = profile.location || '';
        getEl('headerNotifDot').style.display = (profile.notifications && profile.notifications.length) ? 'block' : 'none';

        // Role Config
        const tools = getEl('creatorToolsArea');
        const tabCol = getEl('tabCollections');
        
        if(currentUser.role === 'collector') {
            if(tools) tools.style.display = 'none';
            if(tabCol) tabCol.style.display = 'none';
            window.switchDashTab('wallet');
        } else {
            if(tools) tools.style.display = 'flex';
            if(tabCol) tabCol.style.display = 'block';
            window.switchDashTab('collections');
        }
        
        renderCollections(currentUser.profileData.collections);
        getEl('cancelEditBtn').classList.remove('hidden');
    }

    // --- SETUP & BUILDER HANDLERS ---
    window.startProfileSetup = (role) => {
        window.closeModal('roleModal');
        getEl('landingPage').classList.add('hidden');
        getEl('dashboardRoot').classList.remove('hidden');
        getEl('setupPanel').classList.remove('hidden');
        currentUser.role = role;
        
        // --- Role Config (Collector only sees Wallet tab) ---
        const tabCollections = getEl('tabCollections');
        const tabWallet = getEl('tabWallet');
        const walletControls = getEl('walletControls');
        const collectionsGrid = getEl('collectionsGrid');
        
        if (role === 'collector') {
          // Hide Collections tab entirely
          if (tabCollections) tabCollections.style.display = 'none';
        
          // Force Wallet tab active (UI + state)
          if (tabWallet) tabWallet.classList.add('active');
          if (tabCollections) tabCollections.classList.remove('active');
        
          // Ensure wallet UI is what they see
          currentTab = 'wallet';
          if (walletControls) walletControls.classList.remove('hidden');
        
          // Hide collections grid section content (so nothing flashes)
          if (collectionsGrid) collectionsGrid.classList.add('hidden');
        
          // Switch to wallet view using your existing flow
          if (typeof window.switchDashTab === 'function') {
            window.switchDashTab('wallet');
          }
        } else {
          // Non-collector: restore default behavior
          if (tabCollections) tabCollections.style.display = '';
          if (collectionsGrid) collectionsGrid.classList.remove('hidden');
        }

    };
    
    getEl('triggerEditBtn').addEventListener('click', () => { 
        if (currentUser.profileData) {
            getEl('inputName').value = currentUser.profileData.displayName || '';
            getEl('inputBio').value = currentUser.profileData.bio || '';
            getEl('inputLocation').value = currentUser.profileData.location || '';
        }
        getEl('profilePanel').classList.add('hidden'); 
        getEl('setupPanel').classList.remove('hidden'); 
    });
    
getEl('saveProfileBtn').onclick = async () => {
        const btn = getEl('saveProfileBtn');
        const originalText = btn.textContent;
        btn.textContent = "Saving Draft...";
        btn.disabled = true;

        try {
            const fd = new FormData();
            fd.append('username', currentUser.username || '');
            fd.append('role', currentUser.role || '');

            // --- CRITICAL: Send 'save_draft' action ---
            // This tells PHP to write to profile_draft.json instead of the live file
            fd.append('action', 'save_draft'); 

            const newName = getEl('inputName').value;
            const newBio = getEl('inputBio').value;
            const newLocation = getEl('inputLocation').value;
            // Ensure profileData exists (new-user first save)
if (!currentUser.profileData || typeof currentUser.profileData !== 'object') {
  currentUser.profileData = {
    displayName: '',
    bio: '',
    location: '',
    pfp: '',
    combinations: []
  };
}
fd.append('identity',  safeStr(currentUser.identity));
fd.append('address',   safeStr(currentUser.address));
fd.append('displayName', safeStr(newName));
fd.append('bio',         safeStr(newBio));
fd.append('location',    safeStr(newLocation));
fd.append('role',        safeStr(currentUser.role) || 'artist');

const pfp = safeStr(currentUser.profileData?.pfp);
if (getEl('inputPfpFile').files[0]) fd.append('pfpFile', getEl('inputPfpFile').files[0]);
else if (pfp) fd.append('existingPfp', pfp);

let combos = [];
if (Array.isArray(currentUser.profileData?.combinations)) combos = currentUser.profileData.combinations;
fd.append('combinations', JSON.stringify(combos));


            const res = await fetch('save_profile.php', {method:'POST', body:fd});
            const data = await res.json();

if (!res.ok || data.status !== 'success') {
  const msg = data?.error || data?.message || 'Draft save failed';
  throw new Error(msg);
}

// Update local state so subsequent pushes include the saved values
currentUser.profileData = currentUser.profileData || {};
currentUser.profileData.displayName = getEl('inputName')?.value || '';
currentUser.profileData.bio = getEl('inputBio')?.value || '';
currentUser.profileData.location = getEl('inputLocation')?.value || '';
if (data.pfpUrl) currentUser.profileData.pfp = data.pfpUrl;

// If YOUR desired behavior is "after initial save, go to landing/dashboard":
// do the panel swap right here (draft save complete)
getEl('setupPanel')?.classList.add('hidden');
getEl('profilePanel')?.classList.remove('hidden');

            

            if(res.ok && data.status === 'success') {
                // Update Local Memory & UI
                if (!currentUser.profileData || typeof currentUser.profileData !== 'object') currentUser.profileData = {};
                currentUser.profileData.displayName = newName;
                currentUser.profileData.bio = newBio;
                currentUser.profileData.location = newLocation;
                if(data.pfpUrl) currentUser.profileData.pfp = data.pfpUrl;
                // AUTO-PUSH ONLY ON FIRST COLLECTOR SAVE (Draft -> Public)
                if (currentUser.role === 'collector' && data.firstCreated === true) {
                  window._collectorFirstSaveNeedsAutoPush = true;
                
                  // Open your existing push modal (whatever it is in your codebase)
                  // Landmark you were using earlier: 'pushOptionsModal'
                  openModal('pushOptionsModal');
                
                  // Trigger push of everything (profile + dashboard) as discussed
                  triggerSignAndPush('both');
                
                  // Important: stop here so you don't flip panels / show "Saved Draft" toast first
                  return;
                }


                getEl('displayName').textContent = newName;
                getEl('displayBio').textContent = newBio;
                getEl('displayLocation').textContent = newLocation;

        // PFP Path
        let pfpRaw = (data.pfpUrl || currentUser.profileData?.pfp || 'pfp.png');
        let cleanPfp = pfpRaw;
        
        if (!pfpRaw.startsWith('http') && !pfpRaw.startsWith('data:')) {
            // Remove leading slash if present
            if (pfpRaw.startsWith('/')) pfpRaw = pfpRaw.substring(1);
            // Prepend username if not already there (standardize path: username/pfp_timestamp.png)
            if (!pfpRaw.startsWith(currentUser.username)) {
                cleanPfp = `${currentUser.username}/${pfpRaw}`;
            }
        }

        // Update Dashboard Main PFP
        const dashPfp = getEl('displayPfp');
        if (dashPfp) dashPfp.src = cleanPfp + "?t=" + Date.now();

        // Update Header Button PFP
        const headerPfp = getEl('headerProfileBtn');
        if (headerPfp) headerPfp.src = cleanPfp + "?t=" + Date.now();
        // --- PFP FIX END ---

            // Switch back to view
            getEl('setupPanel').classList.add('hidden');
            getEl('profilePanel').classList.remove('hidden');
            
            if (window._returnToLanding) {
                getEl('dashboardRoot').classList.add('hidden');
                getEl('landingPage').classList.remove('hidden');
                window._returnToLanding = false;
            }

            // Light up the Save button...
            markUnsaved();
                showToast("Saved to Draft (Not Public)", "success");
            } else {
                throw new Error(data.message || "Save failed");
            }
        } catch (e) {
            console.error(e);
            showToast(e.message, "error");
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    };
    
    // --- IMPORT BUTTON HANDLERS ---
    
    // Open Modal
    const btnOpenImport = getEl('openImportModal');
    if(btnOpenImport) {
        btnOpenImport.onclick = () => getEl('importModal').style.display = 'flex';
    }

    // Confirm Import Action
    const btnConfirmImport = getEl('confirmImportBtn');
    if(btnConfirmImport) {
        btnConfirmImport.onclick = async () => {
            dirtyFlags.dashboard = true;
            const nameVal = getEl('importName').value.trim();
            const jsonVal = getEl('importJson').value.trim();
            
            if(!nameVal || !jsonVal) return showToast("Please fill in Name and JSON", "error");

            let policyData;
            try {
                policyData = JSON.parse(jsonVal);
                // Ensure policyId is present (handle different JSON formats)
                if(!policyData.policyId && policyData.id) policyData.policyId = policyData.id;
                
                if(!policyData.policyId || policyData.policyId.length !== 56) {
                    throw new Error("JSON must contain a valid 56-char 'policyId'");
                }
            } catch(e) {
                return showToast("Invalid JSON: " + e.message, "error");
            }

            btnConfirmImport.textContent = "Importing...";
            btnConfirmImport.disabled = true;

            try {
                const res = await fetch('save_policy.php', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'import',
                        username: currentUser.username,
                        identity: currentUser.identity,
                        name: nameVal,
                        policyData: policyData
                    })
                });

                const data = await res.json();

                if(res.ok && data.status === 'success') {
                    closeModal('importModal');
                     // Remove reload, add:
                     showToast("Imported. Please Save.");
                     // TRIGGER DRAFT SAVE
                await saveDashboardState(true);
                     markUnsaved();
                     // Optionally fetch new data silently to update grid
                     loadDashboard();
                } else {
                    throw new Error(data.message || "Import failed");
                }
            } catch(e) {
                console.error(e);
                showToast(e.message, "error");
                btnConfirmImport.textContent = "Import";
                btnConfirmImport.disabled = false;
            }
        };
    }
    
    // Submit Claim Handler
    const btnClaim = getEl('confirmClaimBtn');
    if(btnClaim) {
        btnClaim.onclick = async () => {
            if(!currentUser.username) return showToast("Save profile first!", "error");
            
            const pid = getEl('claimPolicyId').value.trim();
            if(!pid) return showToast("Enter a Policy ID", "error");

            btnClaim.disabled = true;
            btnClaim.textContent = "Submitting...";

            try {
                const res = await fetch('save_policy.php', { 
                    method:'POST', 
                    body:JSON.stringify({ 
                        action:'claim', 
                        username:currentUser.username, 
                        identity:currentUser.identity, 
                        policyId: pid 
                    })
                });
                const d = await res.json();
                
                if(d.status === 'success') { 
                    showToast("Claim Submitted"); 
                    closeModal('importModal'); 
                } else { 
                    showToast(d.message || "Error", "error"); 
                }
            } catch(e) { 
                showToast("Network Error", "error"); 
            } finally {
                btnClaim.disabled = false;
                btnClaim.textContent = "Submit Claim";
            }
        };
    }
    
getEl('cancelEditBtn').addEventListener('click', () => { 
    getEl('setupPanel').classList.add('hidden'); 
    getEl('profilePanel').classList.remove('hidden'); 
    
    // NEW: Check if we need to go back to Landing Page
    if (window._returnToLanding) {
        getEl('dashboardRoot').classList.add('hidden');
        getEl('landingPage').classList.remove('hidden');
        window._returnToLanding = false;
    }
});
    
    // --- DELETE COLLECTION LOGIC ---

    // 1. Toggle the Red Delete Mode
    window.toggleDeleteMode = function() {
        isDeleteMode = !isDeleteMode;
        selectedToDelete.clear(); // Always clear selection when toggling
        
        // Toggle UI State
        const grid = getEl('collectionsGrid');
        const btn = getEl('btnToggleDelete');
        const inputs = document.querySelectorAll('.del-check-input');
        
        if (isDeleteMode) {
            grid.classList.add('delete-mode');
            btn.classList.add('active');
        } else {
            grid.classList.remove('delete-mode');
            btn.classList.remove('active');
            // Uncheck all boxes visually
            inputs.forEach(i => i.checked = false);
        }
        
        updateDeleteUI();
    };

    // 2. Handle Individual Checkbox Toggles (Internal Helper)
    function togglePolicySelection(id) {
        if (selectedToDelete.has(id)) {
            selectedToDelete.delete(id);
        } else {
            selectedToDelete.add(id);
        }
        updateDeleteUI();
    }

    // 3. Update the Buttons/Counter Text (Internal Helper)
    function updateDeleteUI() {
        const count = selectedToDelete.size;
        const countText = getEl('deleteCountText');
        const delBtn = getEl('btnDeleteConfirm');

        if (!isDeleteMode) {
            // Hide everything if not in mode
            countText.style.display = 'none';
            delBtn.style.display = 'none';
            return;
        }

        // Update Count
        countText.style.display = 'block';
        countText.textContent = count;

        // Show/Hide Delete Button based on selection
        if (count > 0) {
            delBtn.style.display = 'block';
            delBtn.textContent = `Delete Selected`; 
        } else {
            delBtn.style.display = 'none';
        }
    }

    // 4. Open the Warning Modal
    window.openDeleteWarning = function() {
        if (selectedToDelete.size === 0) return;
        getEl('deleteWarningModal').style.display = 'flex';
    };

    // 5. Execute the Delete via PHP
window.executeDelete = async function() {
        const btn = document.querySelector('#deleteWarningModal .danger');
        const originalText = btn.textContent;
        btn.textContent = "Deleting...";
        btn.disabled = true;

        try {
            dirtyFlags.dashboard = true;
            const idsToDelete = Array.from(selectedToDelete);
            
            // 1. Separate Groups from Policies
            const groupIds = idsToDelete.filter(id => id.startsWith('group_') || isGroup(id));
            const policyIds = idsToDelete.filter(id => !id.startsWith('group_') && !isGroup(id));

            // 2. Handle Group Deletion (Local Data Update)
            if (groupIds.length > 0 && currentUser.profileData.combinations) {
                // Remove these groups from the combinations array
                currentUser.profileData.combinations = currentUser.profileData.combinations.filter(g => !groupIds.includes(g.id));
                // Note: We are just deleting the folder, not the contents inside (unless contents were also selected?)
                // Usually "Delete Folder" implies deleting structure. The contents inside are IDs. 
                // If those IDs are policies, they technically become "orphaned" (visible at root) or deleted? 
                // For safety in this app, let's assume Delete Group = Remove Folder Structure, Policies return to root (unless selected specifically).
            }

            // 3. Handle Policy Deletion (Server Call)
            if (policyIds.length > 0) {
                const res = await fetch('save_policy.php', {
                    method: 'POST',
                    body: JSON.stringify({
                        action: 'delete_policies',
                        username: currentUser.username,
                        identity: currentUser.identity,
                        policyIds: policyIds
                    })
                });
                const data = await res.json();
                if (data.status !== 'success') throw new Error(data.message);
            }

            // 4. Save the Profile State (This persists the Group Deletions)
            // We force a save here because we modified combinations locally
            await saveDashboardState(true);

            closeModal('deleteWarningModal');
            window.toggleDeleteMode();

            markUnsaved(); 
            // Reload to reflect changes (Groups gone, Policies gone)
            loadDashboard(); 

        } catch (e) {
            console.error(e);
            showToast("Delete Error: " + e.message, "error");
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    };
    
window.openMintStudio = async (mode) => {
  // make sure user is identified first
  if (typeof checkUser === 'function') await checkUser();
  if (!currentUser?.username) {
    alert('Sign in first');
    return;
  }

  const ov = document.getElementById('studioOverlay');
  const fr = document.getElementById('studioFrame');
  if (!ov || !fr) return alert('Studio overlay missing');

  ov.style.display = 'block';

  // IMPORTANT: studio file lives next to /idp/index.html
  // create mode auto-opens the policy modal inside studio
  fr.src = (mode === 'create')
    ? `/idp/studio.html?openCreate=1`
    : `/idp/studio.html`;
};

window.closeMintStudio = () => {
  const ov = document.getElementById('studioOverlay');
  const fr = document.getElementById('studioFrame');
  if (fr) fr.src = 'about:blank';
  if (ov) ov.style.display = 'none';
};
    
    
    // --- INIT ---

async function platformInit() {
        // Init URL Check
        const urlParams = new URLSearchParams(window.location.search);
        const returningAddr = urlParams.get('addr');
        
        if (returningAddr) {
            currentUser.address = returningAddr;
            currentUser.identity = returningAddr;
            
            // --- FIX: Populate Hidden Fields for Sync ---
            const hStake = getEl('hiddenStakeKey');
            const hAddr = getEl('hiddenWalletAddress');
            if(hStake) hStake.value = returningAddr;
            if(hAddr) hAddr.value = returningAddr;

            // Check User & Start Sync
            await checkUser(); 
            startBackendWalletSync('returning_user'); // <--- This kicks off the heartbeat
        }
        window.addEventListener('DOMContentLoaded', () => {
          autoReconnectAndHydrate_IDP();
        });
    }
    
    // --- COMBINE / SEPARATE LOGIC ---

    window.toggleCombineMode = () => {
        isCombineMode = !isCombineMode;
        isDeleteMode = false; // Mutually exclusive
        selectedToCombine.clear();
        
        const grid = getEl('collectionsGrid');
        const pencil = getEl('btnToggleCombine');
        const trash = getEl('btnToggleDelete');
        const inputs = document.querySelectorAll('.del-check-input');
        
        // Visuals
        grid.classList.toggle('delete-mode', isCombineMode); // Reusing delete-mode class for checkboxes
        pencil.style.color = isCombineMode ? '#2196F3' : '#8899ac';
        trash.classList.remove('active');
        
        inputs.forEach(i => i.checked = false);
        updateHeaderControls();
    };

    function toggleCombineSelection(id) {
        if (selectedToCombine.has(id)) selectedToCombine.delete(id);
        else selectedToCombine.add(id);
        updateHeaderControls();
    }

function updateHeaderControls() {
        // Controls visibility of Combine/Separate/Add buttons based on mode & selection
        const combineBtn = getEl('btnCombineConfirm');
        const sepBtn = getEl('btnSeparateConfirm');
        
        combineBtn.style.display = 'none';
        sepBtn.style.display = 'none';

        if (isCombineMode) {
            if (currentGroupViewId) {
                // INSIDE A GROUP
                if (selectedToCombine.size > 0) {
                    sepBtn.style.display = 'block';
                    sepBtn.textContent = `Separate (${selectedToCombine.size})`;
                    
                    // Logic: If user selects a Nested Group inside a parent, allow "Add To" logic there too?
                    // For now, keep separate logic, but check if we are adding to a nested group
                    const selection = Array.from(selectedToCombine);
                    const firstId = selection[0];
                    if (isGroup(firstId) && selection.length > 1) {
                         combineBtn.style.display = 'block';
                         combineBtn.innerHTML = `<i class="fas fa-folder-plus"></i> + Add To`;
                         combineBtn.onclick = executeAddTo;
                    }
                }
            } else {
                // ROOT VIEW
                if (selectedToCombine.size > 1) {
                    combineBtn.style.display = 'block';
                    
                    const selection = Array.from(selectedToCombine);
                    const firstId = selection[0];
                    const firstIsGroup = isGroup(firstId);
                    const allAreGroups = selection.every(id => isGroup(id));

                    // 1. SCENARIO: ONLY items selected are already combined groups
                    if (allAreGroups) {
                        combineBtn.innerHTML = `+ Add | + New`;
                        combineBtn.onclick = () => getEl('addOrNewModal').style.display = 'flex';
                    }
                    // 2. SCENARIO: First item is a group (Parent), others can be mixed
                    else if (firstIsGroup) {
                         // Find name of first group for context (optional)
                         const groupObj = currentUser.profileData.combinations.find(g => g.id === firstId);
                         const gName = groupObj ? (groupObj.name.length > 10 ? groupObj.name.substr(0,10)+'...' : groupObj.name) : 'Group';
                         
                         combineBtn.innerHTML = `<i class="fas fa-folder-plus"></i> + Add To`;
                         combineBtn.onclick = executeAddTo;
                    }
                    // 3. SCENARIO: Standard Combine (First item is not a group)
                    else {
                        combineBtn.textContent = `Combine (${selectedToCombine.size})`;
                        combineBtn.onclick = openCombineNameModal;
                    }
                }
            }
        }
        
        // Also update delete UI if we switched modes
        if(!isDeleteMode) {
             getEl('deleteCountText').style.display='none';
             getEl('btnDeleteConfirm').style.display='none';
        }
    }

    window.openCombineNameModal = () => {
        getEl('combineNameModal').style.display = 'flex';
        getEl('combineNameInput').focus();
    };
    
    // --- GROUP PREVIEW FIX: ensure first entry is a real policy id (not group_*) ---
function resolveFirstPolicyId(ids, visited = new Set()) {
  if (!Array.isArray(ids)) return null;

  for (const id of ids) {
    if (!id) continue;

    if (isGroup(id)) {
      if (visited.has(id)) continue;
      visited.add(id);

      const combos = (currentUser.profileData && Array.isArray(currentUser.profileData.combinations))
        ? currentUser.profileData.combinations
        : [];

      const g = combos.find(x => x.id === id);
      const found = g ? resolveFirstPolicyId(g.policies, visited) : null;
      if (found) return found;
    } else {
      // first non-group id = usable policy/collection id
      return id;
    }
  }
  return null;
}

function promotePreviewPolicyFirst(groupObj) {
  if (!groupObj || !Array.isArray(groupObj.policies) || groupObj.policies.length === 0) return;

  const pid = resolveFirstPolicyId(groupObj.policies);
  if (!pid) return;

  // Move the resolved policy id to the front (dedupe it)
  groupObj.policies = [pid, ...groupObj.policies.filter(x => x !== pid)];
}


    window.executeCombine = async () => {
        dirtyFlags.dashboard = true;
        const name = getEl('combineNameInput').value;
        if (!name) return showToast("Please name this combination", "error");
        
        // Create Group Object
        const newGroup = {
            id: 'group_' + Date.now(),
            name: name,
            policies: Array.from(selectedToCombine)
        };
        
        promotePreviewPolicyFirst(newGroup);


        // Save to Local Data
        if (!currentUser.profileData.combinations) currentUser.profileData.combinations = [];
        currentUser.profileData.combinations.push(newGroup);
        
        // TRIGGER DRAFT SAVE
        await saveDashboardState(true);
        closeModal('combineNameModal');
    renderCollections(currentUser.profileData.collections); // Update Grid
    markUnsaved(); // Light up buttons
    toggleCombineMode(); // Exit combine
    };
    
    window.executeAddTo = async () => {
        dirtyFlags.dashboard = true;
        closeModal('addOrNewModal'); // Close modal if it was open
        
        const selection = Array.from(selectedToCombine);
        if (selection.length < 2) return;

        const parentId = selection[0];
        const childrenIds = selection.slice(1);

        // 1. Identify Parent Group
        const parentGroup = currentUser.profileData.combinations.find(g => g.id === parentId);
        if (!parentGroup) return showToast("Target group not found", "error");

        // 2. Visual Animation (Fade Out Children)
        childrenIds.forEach(id => {
            // Find card by data-id
            const card = document.querySelector(`.collection-card[data-id="${id}"]`);
            if (card) card.classList.add('fade-out');
        });

        // 3. Logic: Add children to parent
        // Ensure policies array exists
        if (!parentGroup.policies) parentGroup.policies = [];
        
        // Add new IDs (prevent duplicates)
        const existingSet = new Set(parentGroup.policies);
        childrenIds.forEach(childId => existingSet.add(childId));
        parentGroup.policies = Array.from(existingSet);
        promotePreviewPolicyFirst(parentGroup);


        // 4. Wait for animation then Save & Render
        setTimeout(async () => {
            // Clear selection
            selectedToCombine.clear();
            
            // If we are "adding to" a group, we stay in combine mode or exit? 
            // Usually good UX to stay in mode or exit. Let's refresh grid.
            renderCollections(currentUser.profileData.collections);
            
            // Trigger Autosave
            await saveDashboardState(true);
            markUnsaved();
            updateHeaderControls();
            
            showToast(`Added ${childrenIds.length} items to ${parentGroup.name}`, "success");
        }, 550); // Slightly longer than CSS transition
    };

    // Helper for the "+ New" button in the modal
    window.startNewCombineFlow = () => {
        closeModal('addOrNewModal');
        openCombineNameModal(); // Proceed to standard naming
    };
    
// --- SPECIALIZED SAVE FOR LOGIC UPDATES ---
// Updated signature to accept silent mode
window.saveDashboardState = async (silent = false, actionName = 'save_draft') => {

        try {
            const fd = new FormData();
            const pData = currentUser.profileData || {};

            // Important: Send specific action
            fd.append('action', actionName); 
            fd.append('username', currentUser.username || '');
            fd.append('identity', currentUser.identity || '');
            fd.append('address', currentUser.address || ''); 
            fd.append('displayName', pData.displayName || '');
            fd.append('bio', pData.bio || '');
            fd.append('role', currentUser.role || 'artist');
            if(pData.pfp) fd.append('existingPfp', pData.pfp);

            let combos = [];
            if(Array.isArray(pData.combinations)) combos = pData.combinations;
            fd.append('combinations', JSON.stringify(combos));

            const res = await fetch('save_profile.php', {method:'POST', body:fd});
            const text = await res.text();
            let data;
            try { data = JSON.parse(text); } catch(e) { throw new Error("Server Error: " + text); }

            if(!res.ok || data.error) throw new Error(data.error || "Save failed");

        } catch (e) {
            console.error(e);
            showToast(e.message, "error");
            throw e; 
        }
    };
    
    window.saveDraftLocal = async () => {
        // Use the btnMainSave for status
        const btn = document.getElementById('btnMainSave');
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            // Send action 'save_draft' to hit the PHP Gatekeeper
            await saveDashboardState(true, 'save_draft'); 
            
            // Mark button as active (Draft exists)
            markUnsaved(); 
            showToast("Draft Saved Locally", "success");
        } catch(e) {
            showToast("Save Failed: " + e.message, "error");
        } finally {
            btn.innerHTML = originalHtml;
        }
    };

    window.executeSeparate = async () => {
        dirtyFlags.dashboard = true;
        if (!currentGroupViewId) return;
        
        const groupIndex = currentUser.profileData.combinations.findIndex(g => g.id === currentGroupViewId);
        if (groupIndex === -1) return;
        
        const group = currentUser.profileData.combinations[groupIndex];
        
        // Remove selected IDs from policies array
        selectedToCombine.forEach(id => {
            const idx = group.policies.indexOf(id);
            if (idx > -1) group.policies.splice(idx, 1);
        });
        
        // If 0 or 1 policy left, dissolve the group
        if (group.policies.length <= 1) {
            currentUser.profileData.combinations.splice(groupIndex, 1);
            showToast("Group dissolved (too few items).");
            currentGroupViewId = null; // Go back to root
        } else {
             showToast("Items separated.");
             promotePreviewPolicyFirst(group);
        }
        
    renderCollections(currentUser.profileData.collections);
    // TRIGGER DRAFT SAVE
    await saveDashboardState(true);
    markUnsaved();
    showToast("Separated (Unsaved)");
    };
    

    // BOOT: Landing Hero
    document.addEventListener('DOMContentLoaded', () => {
      initLandingHero().catch(err => console.error('Hero init failed', err));
    });

// Global Scroll Listener for Dashboard
    window.updateWalletPageSize = (val) => {
        walletPageSize = parseInt(val);
        // Re-render using the cached list, resetting index
        renderWalletGrid(cachedWalletCollections, true);
    };
    
    window.updateColPageSize = (val) => {
        colPageSize = parseInt(val);
        // Reset and re-render
        colBatchIndex = 0;
        const grid = getEl('collectionsGrid');
        if(grid) grid.innerHTML = '';
        renderNextColBatch();
    };

// REPLACE THE SCROLL LISTENER AT THE BOTTOM WITH THIS:

    let scrollTimeout = null;
    window.addEventListener('scroll', () => {
        if (scrollTimeout) return;
        
        scrollTimeout = setTimeout(() => {
            scrollTimeout = null; // Reset flag

            if (getEl('dashboardRoot').classList.contains('hidden')) return;
            if (getEl('assetBrowserModal').style.display === 'flex') return;

const isNearBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100;

            // MY COLLECTIONS TAB SCROLL
            if (getEl('tabCollections').classList.contains('active')) {
                if (isNearBottom) renderNextColBatch();
            }
            
            // MY WALLET TAB SCROLL
            if (getEl('tabWallet').classList.contains('active')) {
                // False = append next batch
                if (isNearBottom) renderWalletGrid(false); 
            }
        }, 150); // Check max once every 150ms
    });
    
    
// Global click listener to close mobile menu
// Unified Global Click Listener
window.addEventListener('click', (e) => {
    // 1. Close Wallet Dropdown
    const wDrop = getEl('walletDropdown');
    const wTrig = getEl('walletTrigger');
    if (wDrop && wDrop.classList.contains('show')) {
        // If clicking anywhere EXCEPT the dropdown itself or the trigger...
        if (!wDrop.contains(e.target) && !wTrig.contains(e.target)) {
            wDrop.classList.remove('show');
        }
    }

    // 2. Close Profile Dropdown
    const pDrop = getEl('profileDropdown');
    const pTrig = getEl('headerProfileBtn'); // The PFP image
    if (pDrop && pDrop.style.display === 'flex') {
        if (!pDrop.contains(e.target) && !pTrig.contains(e.target)) {
            pDrop.style.display = 'none';
        }
    }

    // 3. Close Mobile Menu
    const mDrop = getEl('actionMenuDropdown');
    const mBtn = document.querySelector('.mobile-menu-btn');
    if (mDrop && mDrop.classList.contains('show')) {
        if (!mDrop.contains(e.target) && !mBtn.contains(e.target)) {
            mDrop.classList.remove('show');
        }
    }
});


const RF_LAST_WALLET_KEY = 'rf_last_wallet_v1';
const RF_SESSION_OK_KEY  = 'rf_autoconnect_ok_v1';
const RF_SESSION_TS_KEY  = 'rf_autoconnect_ts_v1';

function rememberLastWalletKey(walletKey){
  try {
    // Keep the key for convenience, but only auto-connect if this TAB session allows it.
    localStorage.setItem(RF_LAST_WALLET_KEY, walletKey);
    sessionStorage.setItem(RF_SESSION_OK_KEY, '1');
    sessionStorage.setItem(RF_SESSION_TS_KEY, String(Date.now()));
  } catch(e){}
}

async function tryAutoReconnectWallet(){
  try {
    // Rule 1: only auto-connect if this same tab previously connected
    if (sessionStorage.getItem(RF_SESSION_OK_KEY) !== '1') return null;

    // Rule 2: optional time window (30 minutes). Adjust if you want.
    const ts = parseInt(sessionStorage.getItem(RF_SESSION_TS_KEY) || '0', 10);
    if (!ts || (Date.now() - ts) > (30 * 60 * 1000)) return null;

    const walletKey = localStorage.getItem(RF_LAST_WALLET_KEY);
    if (!walletKey) return null;
    if (!window.cardano || !window.cardano[walletKey] || !window.cardano[walletKey].enable) return null;

    const api = await window.cardano[walletKey].enable();
    return { walletKey, api };
  } catch (e) {
    return null;
  }
}

async function autoReconnectAndHydrate_IDP(){
  const auto = await tryAutoReconnectWallet();
  if (!auto) return false;

  const { walletKey, api } = auto;

  window.fre5hGateState = window.fre5hGateState || {};
  window.fre5hGateState.walletKey = walletKey;
  window.fre5hGateState.api = api;

  try {
    meshWallet = await BrowserWallet.enable(walletKey);
  } catch(e){
    meshWallet = null;
  }

  try {
    if (meshWallet) {
      currentUser.address = await meshWallet.getChangeAddress();
      const r = await meshWallet.getRewardAddresses();
      currentUser.identity = r[0] || currentUser.address;
    } else {
      currentUser.address = await api.getChangeAddress();
      const r = await api.getRewardAddresses();
      currentUser.identity = r[0] || currentUser.address;
    }
  } catch(e){}

  const hStake = getEl('hiddenStakeKey');
  const hAddr  = getEl('hiddenWalletAddress');
  if(hStake) hStake.value = currentUser.identity || '';
  if(hAddr)  hAddr.value  = currentUser.address  || '';

  try {
    if (meshWallet) {
      const l = await meshWallet.getLovelace();
      const bal = getEl('headerBalance');
      if (bal) {
        bal.textContent = `₳ ${(parseInt(l)/1000000).toFixed(2)}`;
        bal.style.display = 'block';
      }
    }
  } catch(e){}

  await checkUser();

  if(currentUser.username && currentUser.profileData) {
    let pfp = currentUser.profileData.pfp || 'pfp.png';
    if(!pfp.startsWith('http') && !pfp.startsWith('data:')) {
      if(pfp.startsWith('/')) pfp = pfp.substring(1);
      if(!pfp.startsWith(currentUser.username)) pfp = `${currentUser.username}/${pfp}`;
    }
    const hBtn = getEl('headerProfileBtn');
    if(hBtn) hBtn.src = `${pfp}?t=${Date.now()}`;
  }

  return true;
}
function disconnectWallet_IDP(){
  try{
    meshWallet = null;
    currentUser.address = '';
    currentUser.identity = '';
    window.fre5hGateState = {};

    // Kill auto-connect permissions for this tab/session
    sessionStorage.removeItem(RF_SESSION_OK_KEY);
    sessionStorage.removeItem(RF_SESSION_TS_KEY);

    // Optional: also forget last wallet entirely
    localStorage.removeItem(RF_LAST_WALLET_KEY);

    const bal = getEl('headerBalance');
    if (bal) bal.style.display = 'none';

    closeWalletDropdown();
  }catch(e){}
}

// ==========================================
// IDP STUDIO INTEGRATION
// ==========================================
let studioWallet = null; 
const DEFAULT_PROPS = ["Description", "Artist", "Creator", "Links", "Name"];

// 1. Enter Studio (Replaces window.onload)
window.enterIDPStudio = async function() {
    // 1. ORIGINAL CHECK: Wallet Connection
    if (!window.fre5hGateState?.walletKey) {
        showToast("Please connect wallet first", "error");
        return;
    }

    // --- NEW: Create and Show Loading Modal Immediately ---
    // We add this BEFORE the try block so it appears instantly
    const modal = document.createElement('div');
    modal.id = "studioInitLoader";
    modal.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);color:#fff;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:9999;font-family:sans-serif;";
    modal.innerHTML = `
        <i class="fas fa-circle-notch fa-spin" style="font-size:3rem; margin-bottom:20px; color:var(--primary);"></i>
        <div style="font-size:1.5rem; font-weight:300;">IDP Studio Loading...</div>
    `;
    document.body.appendChild(modal);

    try {
        // 2. ORIGINAL: Initialize Wallet
        studioWallet = await BrowserWallet.enable(window.fre5hGateState.walletKey);
        
        // 3. ORIGINAL: Aggressively Hide Other Views
        // (Assuming getEl is your helper function, we keep using it)
        getEl('dashboardRoot').classList.remove('hidden');
        getEl('landingPage').classList.add('hidden');
        getEl('profilePanel').classList.add('hidden');
        getEl('appDB').classList.add('hidden');
        
        // 4. ORIGINAL: Show Studio
        const studio = getEl('studioRoot');
        studio.classList.remove('hidden');
        studio.style.display = 'block'; 

        // 5. ORIGINAL: Initialize Components
        if (typeof renderCollectionSettings === 'function') {
    renderCollectionSettings(getActiveCollKey() || 'new');
}
setupStudioListeners();
        if (typeof initCollections === 'function') await initCollections();
        
        // --- NEW: Force Tab Render & Data Fetch ---
        // We explicitly call this here to ensure the "Force Populate" logic
        // from our previous step runs while the screen is still hidden by the modal.
        if (typeof renderCollectionTabsUI === 'function') renderCollectionTabsUI();
        
        // 6. ORIGINAL: Setup & Update
        if (typeof handleTypeChange === 'function') handleTypeChange();
        if (typeof syncDefaultPropsToAllAssets === 'function') syncDefaultPropsToAllAssets();
        if (typeof updateAssetPreview === 'function') updateAssetPreview();
        if (typeof updateViewMode === 'function') updateViewMode();
        if (typeof applyCollectionThumbFromInput === 'function') applyCollectionThumbFromInput();
        
        if (studioAssets.length === 0) {
            // Check if we have saved data to load (from collStateMem logic implemented previously)
            // If not, create one empty asset
            // createNewAsset(); // Uncomment to force 1 asset on load
        }

        // --- NEW: Remove Modal after 3 seconds ---
        setTimeout(() => {
            const m = document.getElementById('studioInitLoader');
            if(m) {
                m.style.opacity = '0';
                m.style.transition = 'opacity 0.5s';
                setTimeout(() => m.remove(), 500); // Remove from DOM after fade
            }
        }, 3000);

    } catch (e) {
        console.error("Studio Init Error", e);
        showToast("Failed to load Studio", "error");
        
        // In case of error, remove the loading screen so the user isn't stuck
        const m = document.getElementById('studioInitLoader');
        if(m) m.remove();
    }
};


// 2. Exit Studio
window.exitIDPStudio = async function(shouldSave) {
    if (shouldSave) {
        // 1. Force-save the currently visible inputs to memory first
        saveActiveCollectionState(); 

        const username = (currentUser.username || '').trim();
        const saveBtn = document.querySelector('.tool-btn.primary');
        const oldText = saveBtn ? saveBtn.innerHTML : 'Save';
        
        if (username) {
            if(saveBtn) saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving All...';

            try {
                // 2. --- NEW: LOOP THROUGH ALL MEMORY ---
                // We convert the Map entries to an array of promises to save concurrently
                const savePromises = [];

                for (const [key, stateData] of collStateMem.entries()) {
                    // Only save if we have actual data
                    if (!stateData) continue;

                    const formData = new FormData();
                    formData.append('username', username);
                    formData.append('collectionKey', key);
                    formData.append('jsonData', JSON.stringify(stateData));

                    // Push the fetch request to our array
                    savePromises.push(
                        fetch('api/save_collection_data.php', {
                            method: 'POST',
                            body: formData
                        }).then(r => r.json())
                    );
                }

                // 3. Wait for ALL collections to save
                if (savePromises.length > 0) {
                    const results = await Promise.all(savePromises);
                    
                    // Check if any failed
                    const failed = results.find(r => !r.success);
                    if (failed) {
                        alert("Some collections failed to save: " + (failed.message || "Unknown error"));
                        if(saveBtn) saveBtn.innerHTML = oldText;
                        return; // Stop exit on error
                    }
                    console.log(`Saved ${results.length} collections successfully.`);
                } else {
                    console.log("No changes in memory to save.");
                }

                if(saveBtn) saveBtn.innerHTML = oldText;

            } catch (err) {
                console.error("Batch Save Error:", err);
                alert("Network error during batch save.");
                if(saveBtn) saveBtn.innerHTML = oldText;
                return;
            }
        }
    }

    // 4. Close Studio & Restore Dashboard
    document.getElementById('studioRoot').classList.add('hidden');
    
    const dash = document.getElementById('dashboardRoot');
    const profile = document.getElementById('profilePanel');
    const appDB = document.getElementById('appDB');

    if (dash) dash.classList.remove('hidden');
    if (profile) profile.classList.remove('hidden');
    if (appDB) appDB.classList.remove('hidden');

    if (shouldSave && typeof loadDashboard === 'function') {
        loadDashboard(currentUser.profileData); 
    }
};

// 3. Setup Listeners (Moved from window.onload)
function setupStudioListeners() {
    // Only add these once.
    if (document.body.dataset.studioReady === 'true') return;
    document.body.dataset.studioReady = 'true';

    // Helper to safely bind events
    const safeBind = (id, event, fn) => {
        const el = getEl(id);
        if (el) el.addEventListener(event, fn);
    };
    const safeClick = (id, fn) => {
        const el = getEl(id);
        if (el) el.onclick = fn;
    };

    // Banner & Thumb
    safeBind('bannerInput', 'change', uploadBanner);
    
    // Drag & Drop Zones
    const bannerArea = getEl('bannerArea');
    if (bannerArea) {
        bannerArea.addEventListener('dragover', (ev) => { ev.preventDefault(); bannerArea.classList.add('drag-active'); });
        bannerArea.addEventListener('dragleave', () => bannerArea.classList.remove('drag-active'));
        bannerArea.addEventListener('drop', (ev) => {
            ev.preventDefault();
            bannerArea.classList.remove('drag-active');
            const f = ev.dataTransfer?.files?.[0];
            if (f) {
                if (f.size > 5 * 1024 * 1024) return alert("File too big (Max 5MB)");
                const img = getEl('bannerImg');
                if(img) img.src = URL.createObjectURL(f);
                if(typeof updateAssetPreview === 'function') updateAssetPreview();
            }
        });
    }

    // Input Listeners
    safeBind('collectionName', 'input', updateAssetPreview);
    safeBind('saleDescription', 'input', (e) => {
        const d = getEl('displayDesc');
        if(d) d.textContent = e.target.value;
    });
    safeBind('useCollName', 'change', updateAssetPreview);
    // --- NFT FLOW LISTENERS ---
    // These specific inputs now drive the SELECTED asset, not a global one
    safeBind('assetNameInput', 'input', updateSelectedAssetFromUI);
    safeBind('codeContent', 'input', updateSelectedAssetFromUI);
    safeBind('previewImgInput', 'input', updateSelectedAssetFromUI);
    
        const dp = document.getElementById('defaultProps');
        if (dp) {
            const persistDefaultsNow = (e) => {
                // Avoid creating junk/partial keys if user is typing a custom key name
                if (e && e.type === 'input' && e.target?.classList?.contains('p-key')) return;
        
                const k = getActiveCollKey();
                const defaultsNow = getLiveDefaultProps();
        
                // Update active collection memory immediately so any re-render can't drop the new prop row
                if (k) {
                    const prev = collStateMem.get(String(k)) || {};
                    collStateMem.set(String(k), { ...prev, defaultProps: defaultsNow });
                }
        
                syncDefaultPropsToAllAssets(defaultsNow);
                renderStudioPreview();
            };
        
            dp.addEventListener('input', persistDefaultsNow);
            dp.addEventListener('change', persistDefaultsNow);
        }

        const metaProps = document.getElementById('metaPropsContainer');
        if (metaProps) {
            const persistMetaRowsNow = (e) => {
                // Same rule: don't snapshot half-typed keys on input events
                if (e && e.type === 'input' && e.target?.classList?.contains('p-key')) return;
        
                const rowsNow = (typeof readMetaRows === 'function') ? readMetaRows() : [];
        
                // 1) Persist onto the currently selected asset immediately (prevents "row disappears")
                if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
                    studioAssets[studioSelectedAssetIndex].metaRows = rowsNow;
                }
        
                // 2) Persist onto active collection memory immediately (prevents reload = local editable)
                const k = getActiveCollKey();
                if (k) {
                    const prev = collStateMem.get(String(k)) || {};
                    collStateMem.set(String(k), { ...prev, metaRows: rowsNow, studioAssets: studioAssets });
                }
        
                // Keep preview consistent
                if (typeof renderStudioPreview === 'function') renderStudioPreview();
            };
        
            metaProps.addEventListener('input', persistMetaRowsNow);
            metaProps.addEventListener('change', persistMetaRowsNow);
        }


    
    // Radios needs loop
    document.querySelectorAll('input[name="encoding"]').forEach(r => {
        r.addEventListener('change', updateSelectedAssetFromUI);
    });
    
    document.querySelectorAll('input[name="dist"]').forEach(r => r.addEventListener('change', updateAssetPreview));
    document.querySelectorAll('input[name="astype"]').forEach(r => r.addEventListener('change', handleTypeChange));
    
    document.querySelectorAll('input[name="costType"]').forEach(r => r.addEventListener('change', (e) => {
         const mc = getEl('mintCost');
         if(mc) mc.disabled = e.target.value === 'free';
         updatePriceDisplay();
    }));

    safeBind('mintCost', 'input', updatePriceDisplay);
    safeBind('mintQty', 'change', updatePriceDisplay);
    safeBind('assetNameInput', 'input', updateAssetPreview);
    // Studio Filter Listener
    safeBind('studioPropertyFilterSelect', 'change', (e) => {
        studioActiveFilter = e.target.value;
        renderStudioPreview();
    });

    // Buttons
    safeClick('btnUpload', () => getEl('fileInput')?.click());
    safeBind('fileInput', 'change', (e) => loadFile(e, 'codeContent'));
    
    safeClick('btnUploadPreview', () => getEl('previewFileInput')?.click());
    safeBind('previewFileInput', 'change', (e) => {
        loadFile(e, 'previewImgInput');
        const f = e.target.files[0];
        if(f) {
            const vp = getEl('visualPreview');
            if(vp) {
                vp.src = URL.createObjectURL(f);
                vp.style.display = 'block';
            }
        }
        updateAssetPreview();
    });

    safeClick('addMetaPropBtn', () => addProp('meta'));
    safeClick('addCodePropBtn', () => addProp('code'));
    safeClick('btnMint', mintAsset); 
    
    safeClick('btnOpenMetaEditor', openMetaEditor);

    // --- THESE WERE CAUSING THE CRASH (Now Safe) ---
    safeClick('btnExportConfig', exportConfig);
    safeBind('importFile', 'change', importConfig);
    
    // Policy Modal
    document.querySelectorAll('input[name="policyType"]').forEach(r => r.addEventListener('change', syncPolicyTypeUI));
    if(typeof initPolicyDatePicker === 'function') initPolicyDatePicker();
}

// ===== COLLECTION MANAGER (single panel, many saved collections) =====
const MINT_API = '/idp/mint_api.php';
function getIdpUsernameFromPath() {
  const p = window.location.pathname || '';
  const m = p.match(/\/idp\/([^\/]+)\//i);
  return m ? m[1] : '';
}
const IDP_USERNAME = getIdpUsernameFromPath();

function readRadio(name) {
  return document.querySelector(`input[name="${name}"]:checked`)?.value || '';
}
function setRadio(name, val) {
  const el = document.querySelector(`input[name="${name}"][value="${val}"]`);
  if (el) el.checked = true;
}

// --- STATE MANAGEMENT FIX ---

function readDefaultProps() {
    const out = {};
    // Select only the inputs with the class .prop-val inside the container
    document.querySelectorAll('#defaultProps .prop-val').forEach(inp => {
        const key = inp.dataset.prop; // robust reading
        if (key) out[key] = inp.value;
    });
    return out;
}

function writeDefaultProps(map) {
    // Always clear stale UI values when the incoming map is empty/missing.
    const m = (map && typeof map === 'object') ? map : {};

    document.querySelectorAll('#defaultProps .prop-val').forEach(inp => {
        const key = inp.dataset.prop;
        if (!key) return;

        // CRITICAL: if key missing, force blank to prevent "new collection" contamination.
        inp.value = Object.prototype.hasOwnProperty.call(m, key) ? (m[key] ?? '') : '';
    });
}

// Applies Common Properties (#defaultProps) to EVERY asset.traits
function syncDefaultPropsToAllAssets(propsOverride) {
    // 1. Get the unified list of props (Standard + Custom)
    const common = propsOverride || getLiveDefaultProps();

    if (!Array.isArray(studioAssets) || studioAssets.length === 0) return common;

    studioAssets.forEach(a => {
        if (!a) return;
        if (!a.traits || typeof a.traits !== 'object') a.traits = {};
        if (!a.defaultProps || typeof a.defaultProps !== 'object') a.defaultProps = {};

        Object.keys(common).forEach(k => {
            const val = common[k];

            // CASE A: Name (Special handling, stays in defaultProps.name)
            if (k === "Name") {
                if (val) a.defaultProps.name = val.toString();
                return;
            }

            // CASE B: Standard "Preset" Props (Artist, Description, etc.)
            // FIX: These must FORCE UPDATE. 
            // The logic 'DEFAULT_PROPS.includes(k)' identifies them.
            if (DEFAULT_PROPS.includes(k)) {
                a.traits[k] = val;
                return;
            }

            // CASE C: Custom/New Globals
            // Keep "Soft Update" (Only if empty/missing) 
            // This prevents overwriting manual custom values you may have set on specific assets.
            if (!a.traits.hasOwnProperty(k) || a.traits[k] === "" || a.traits[k] === undefined) {
                a.traits[k] = val;
            }
        });
    });

    return common;
}

function readMetaRows() {
    const rows = [];
    document.querySelectorAll('#metaPropsContainer .prop-row').forEach(r => {
        const key = r.querySelector('.p-key')?.value ?? '';
        const val = r.querySelector('.p-val')?.value ?? '';
        // This line is the critical update:
        const all = r.querySelector('.p-all')?.checked ?? false; 
        
        if (key.trim() || val.trim()) rows.push({ key, val, all });
    });
    return rows;
}

function readCodeRows() {
    const rows = [];
    document.querySelectorAll('#codePropsContainer .prop-row').forEach(r => {
        const key = r.querySelector('.p-key')?.value ?? '';
        const val = r.querySelector('.p-val')?.value ?? '';
        const metaSync = r.querySelector('.p-meta-sync')?.checked ?? false;
        const presets  = r.querySelector('.p-presets')?.checked ?? false;
        // Save even if empty to preserve order/structure, or strictly filter
        if (key.trim() || val.trim()) rows.push({ key, val, metaSync, presets });
    });
    return rows;
}

function clearMetaCodeContainers() {
    const m = document.getElementById('metaPropsContainer');
    const c = document.getElementById('codePropsContainer');
    if (m) m.innerHTML = '';
    if (c) c.innerHTML = '';
}

function rebuildMetaRows(list) {
    const addBtn = document.getElementById('addMetaPropBtn');
    const cont = document.getElementById('metaPropsContainer');
    if (!addBtn || !cont) return;

    (list || []).forEach(item => {
        addBtn.click(); // Add DOM row
        const row = cont.lastElementChild; // Get the row we just added
        if (!row) return;
        
        const k = row.querySelector('.p-key');
        const v = row.querySelector('.p-val');
        const a = row.querySelector('.p-all');
        
        if (k) k.value = item.key ?? '';
        if (v) v.value = item.val ?? '';
        if (a) a.checked = !!item.all;
    });
}

function rebuildCodeRows(list) {
    const addBtn = document.getElementById('addCodePropBtn');
    const cont = document.getElementById('codePropsContainer');
    if (!addBtn || !cont) return;

    (list || []).forEach(item => {
        addBtn.click(); // Add DOM row
        const row = cont.lastElementChild; // Get the row we just added
        if (!row) return;

        const k = row.querySelector('.p-key');
        const v = row.querySelector('.p-val');
        const ms = row.querySelector('.p-meta-sync');
        const pr = row.querySelector('.p-presets');

        if (k) k.value = item.key ?? '';
        if (v) v.value = item.val ?? '';
        if (ms) ms.checked = !!item.metaSync;
        if (pr) {
            pr.checked = !!item.presets;
            // Force toggle the UI for presets if checked
            if (typeof window.togglePresets === 'function' && item.presets) {
                window.togglePresets(pr);
            }
        }
    });
}

function readCollectionStateFromUI() {
    // 1. If we have an active asset, force-update it from the DOM before reading state
    if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
    }

return {
    collectionName: document.getElementById('collectionName')?.value ?? '',
    
    // UPDATED: Map both keys to the same input value
    totalAssets: document.getElementById('totalAssets')?.value ?? '1',
    maxSupply: document.getElementById('totalAssets')?.value ?? '1', 
    
    saleDescription: document.getElementById('saleDescription')?.value ?? '',

        dist: readRadio('dist') || 'random',
        astype: readRadio('astype') || 'nft',

        useCollName: document.getElementById('useCollName')?.checked ?? true,
        assetNameInput: document.getElementById('assetNameInput')?.value ?? '',
        editionInput: document.getElementById('editionInput')?.value ?? '',
        ftTicker: document.getElementById('ftTicker')?.value ?? '',

        useWalletAddr: document.getElementById('useWalletAddr')?.checked ?? false,
        receiveAddr: document.getElementById('receiveAddr')?.value ?? '',

        costType: readRadio('costType') || 'free',
        mintCost: document.getElementById('mintCost')?.value ?? '',

        encoding: readRadio('encoding') || 'base64',
        codeContent: document.getElementById('codeContent')?.value ?? '',

        collectionThumbInput: document.getElementById('collectionThumbInput')?.value ?? 'fbThumb.png',
        previewImgInput: document.getElementById('previewImgInput')?.value ?? '',

        // Critical: These calls gather the dynamic rows
        defaultProps: readDefaultProps(),
        metaRows: readMetaRows(),
        codeRows: readCodeRows(),
        
        // FIX: Include the full array of assets in the save state
        studioAssets: studioAssets || []
    };
}

// Syncs all header display pills from a state object on initial load / collection switch.
// Mirrors the derivation logic of the inline oninput/onchange handlers in the HTML.
function syncAllHeaderPills(s) {
    if (!s) s = {};

    // Collection Details header pills
    const collNamePill = document.getElementById('headerCollNameDisplay');
    if (collNamePill) collNamePill.innerText = s.collectionName || 'Not Set';

    const maxPill = document.getElementById('headerMaxDisplay');
    if (maxPill) maxPill.innerText = s.totalAssets || '1';

    const typePill = document.getElementById('headerTypeDisplay');
    if (typePill) {
        const typeMap = { 'nft': 'NFT', 'edition': 'Edition', 'ft': 'FT' };
        typePill.innerText = typeMap[s.astype] || 'NFT';
    }

    // Asset Preview header pill
    const assetCountPill = document.getElementById('headerAssetCount');
    if (assetCountPill) assetCountPill.innerText = studioAssets.length;

    // Payment Info header pills
    const addrPill = document.getElementById('headerAddrDisplay');
    if (addrPill) {
        if (s.useWalletAddr) {
            addrPill.innerText = 'Wallet';
        } else if (s.receiveAddr && s.receiveAddr.length > 5) {
            addrPill.innerText = s.receiveAddr.substring(0, 5) + '...';
        } else {
            addrPill.innerText = s.receiveAddr || 'Not Set';
        }
    }

    const costPill = document.getElementById('headerCostDisplay');
    if (costPill) {
        if (s.costType === 'paid') {
            costPill.innerText = (s.mintCost || '0') + ' ₳';
        } else {
            costPill.innerText = 'Free';
        }
    }

    // Mint Station max supply display
    const maxSupply = document.getElementById('maxSupplyDisplay');
    if (maxSupply) maxSupply.textContent = s.totalAssets || '1';
}

function writeCollectionStateToUI(s) {
    if (!s) s = {};

    // 1. Basic Fields
    const cn = document.getElementById('collectionName');
    const ta = document.getElementById('totalAssets');
    const sd = document.getElementById('saleDescription');
    // NOTE: We do NOT set assetNameInput here yet, we let selectStudioAsset handle it later

    if (cn) cn.value = s.collectionName ?? '';
    if (ta) ta.value = s.totalAssets ?? '1';
    if (sd) sd.value = s.saleDescription ?? '';

    setRadio('dist', s.dist ?? 'random');
    setRadio('astype', s.astype ?? 'nft');
    
    // 2. Toggles
    const ucn = document.getElementById('useCollName');
    if (ucn) ucn.checked = s.useCollName ?? true;

    const ed = document.getElementById('editionInput');
    const ft = document.getElementById('ftTicker');
    if (ed) ed.value = s.editionInput ?? '';
    if (ft) ft.value = s.ftTicker ?? '';

    const uwa = document.getElementById('useWalletAddr');
    const ra  = document.getElementById('receiveAddr');
    if (uwa) uwa.checked = (s.useWalletAddr ?? false);
    if (ra) ra.value = s.receiveAddr ?? '';

    setRadio('costType', s.costType ?? 'free');
    const mc = document.getElementById('mintCost');
    if (mc) mc.value = s.mintCost ?? '';

    setRadio('encoding', s.encoding ?? 'base64');
    
    // 3. Global Inputs (Thumbnails, etc)
    const cti = document.getElementById('collectionThumbInput');
    if (cti) cti.value = s.collectionThumbInput ?? 'fbThumb.png';

    writeDefaultProps(s.defaultProps || {});

    // 4. Updates & Side Effects
    document.getElementById('maxSupplyDisplay').textContent = (document.getElementById('totalAssets')?.value || '∞');
    if (typeof window.handleTypeChange === 'function') window.handleTypeChange();
    if (typeof window.updatePriceDisplay === 'function') window.updatePriceDisplay();
    if (typeof window.applyCollectionThumbFromInput === 'function') window.applyCollectionThumbFromInput();
    
    const displayTitle = document.getElementById('displayTitle');
    if (displayTitle) displayTitle.textContent = s.collectionName || 'Collection Title';

    const displayDesc = document.getElementById('displayDesc');
    if (displayDesc) displayDesc.textContent = s.saleDescription || 'Collection description will appear here.';

// --- FIX: LOAD ASSETS OR CREATE INITIAL ---
    if (s.studioAssets && Array.isArray(s.studioAssets) && s.studioAssets.length > 0) {
        // Load saved assets
        studioAssets = s.studioAssets;
        syncDefaultPropsToAllAssets(s.defaultProps || {});
        
        // CRITICAL: Set to -1 so selectStudioAsset knows this is an Initialization, not a Switch.
        // This prevents the empty UI inputs from overwriting Asset #0's data.
        studioSelectedAssetIndex = -1; 
        
        selectStudioAsset(0);
    } else {
        // No assets saved, create clean slate (Asset #1)
        studioAssets = [];
        const useColl = s.useCollName ?? true;
        const base = s.collectionName || "Asset";
        const initAssetKey = useColl ? base.replace(/[^a-zA-Z0-9]/g, '') + "1" : (s.assetNameInput || base.replace(/[^a-zA-Z0-9]/g, '') + "1");
        const initDisplayName = useColl ? `${base} #1` : (s.assetNameInput || `${base} #1`);

        const initialAsset = {
            id: 'init_' + Date.now(),
            name: initAssetKey,
            displayName: initDisplayName,
            mainContent: s.codeContent || "",
            mainEncoding: s.encoding || "base64",
            coverImage: s.previewImgInput || "",
            traits: s.defaultProps || {},
            codeRows: s.codeRows || [],
            metaRows: s.metaRows || []
        };
        studioAssets.push(initialAsset);
        syncDefaultPropsToAllAssets(s.defaultProps || {});

        studioSelectedAssetIndex = -1; 
        selectStudioAsset(0);
    }

    syncAllHeaderPills(s);

    if (typeof renderStudioPreview === 'function') renderStudioPreview();
}

let serverCollIndex = [];

// in-memory only (NO localStorage)
let activeCollKeyMem = '';
const collStateMem = new Map();

function getActiveCollKey() {
  return activeCollKeyMem;
}
function setActiveCollKey(k) {
  activeCollKeyMem = String(k || '');
}

async function apiCall(action, payload) {
const u = IDP_USERNAME || '';
  const ident = encodeURIComponent(currentUser.identity || '');
  const addr  = encodeURIComponent(currentUser.address || '');
  const url = `${MINT_API}?action=${encodeURIComponent(action)}&identity=${ident}&address=${addr}`;
  const opt = payload
    ? { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }
    : { method:'GET', cache:'no-store' };

  const res = await fetch(url, opt);
  const data = await res.json().catch(() => null);
  if (!res.ok || !data || data.ok !== true) throw new Error((data && data.error) || 'API error');
  return data;
}

const RESERVED_MINT_DIRS = new Set([
  'api','banner','colgen','created','data','img','logo','templates'
]);

function normalizeServerCollections(list) {
  const arr = Array.isArray(list) ? list : [];
  return arr
    .map(c => (typeof c === 'string' ? { key: c, label: c } : c))
    .filter(c => c && c.key)
    .filter(c => !RESERVED_MINT_DIRS.has(String(c.key).toLowerCase()));
}

async function loadServerCollIndex() {
  try {
    const data = await apiCall('list');
    serverCollIndex = normalizeServerCollections(data.collections);
  } catch (e) {
    console.warn('list failed', e);
    serverCollIndex = [];
  }
  return serverCollIndex;
}

async function getServerCollection(key) {
  return await apiCall('get', { key });
}

async function createServerCollection(payload) {
  return await apiCall('create', payload);
}

async function deleteServerCollection(key) {
  return await apiCall('delete', { key });
}


// Toggle logic for the HTML radio buttons
window.togglePolicyDropdown = function(showExisting) {
    const existingRow = document.getElementById('existingPolicyRow');
    const newConfig = document.getElementById('newPolicyConfig');
    
    if (existingRow) existingRow.classList.toggle('hidden', !showExisting);
    if (newConfig) newConfig.classList.toggle('hidden', showExisting);
};

// Update openNewCollectionModal to populate the dropdown
var originalOpenModal = window.openNewCollectionModal;
window.openNewCollectionModal = function() {
    // Call the original if it exists and isn't this function itself (recursion check)
    if (typeof originalOpenModal === 'function' && originalOpenModal !== window.openNewCollectionModal) {
        originalOpenModal();
    } else {
        // Fallback if original is missing: just show the modal
        const modal = document.getElementById('policyModal');
        const nameInp = document.getElementById('policyCollectionName');
        const fromUI = document.getElementById('collectionName')?.value || '';
        if (nameInp) nameInp.value = (fromUI || '').trim();
        modal?.classList.add('open');
    }
    
    const select = document.getElementById('existingPolicySelect');
    if (select) {
        select.innerHTML = '';
        
        // Get unique policies from existing collections in memory
        const policies = new Map();
        if (Array.isArray(serverCollIndex)) {
            serverCollIndex.forEach(c => {
                if (c.policy && c.policy.policyId) {
                    policies.set(c.policy.policyId, c.policy);
                }
            });
        }

        if (policies.size === 0) {
            select.innerHTML = '<option value="">No existing policies found</option>';
        } else {
            policies.forEach((p, id) => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = id.substring(0, 15) + '...';
                opt.dataset.policyRaw = JSON.stringify(p);
                select.appendChild(opt);
            });
        }
    }
    
    // Reset state to "New Policy" by default
    const radioNew = document.querySelector('input[name="policyChoice"][value="new"]');
    if (radioNew) radioNew.checked = true;
    
    if (typeof window.togglePolicyDropdown === 'function') {
        window.togglePolicyDropdown(false);
    }
    
    // Ensure the UI for policy type matches the default
    if (typeof syncPolicyTypeUI === 'function') syncPolicyTypeUI();
};

/* =========================================
   1. HELPER FUNCTIONS 
   (Keep these at the top)
   ========================================= */
function pad2(n){ return String(n).padStart(2,'0'); }

function fmtYMD(dt){
  const y = dt.getFullYear();
  const m = pad2(dt.getMonth()+1);
  const d = pad2(dt.getDate());
  return `${y}-${m}-${d}`;
}

function startOfDay(dt){
  return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
}

/* =========================================
   2. UI SYNC (SHOW/HIDE ROW)
   ========================================= */
function syncPolicyTypeUI() {
  // Get the currently checked radio value
  const type = document.querySelector('input[name="policyType"]:checked')?.value || 'open';
  const lockRow = document.getElementById('policyLockRow');
  const datePop = document.getElementById('policyDatePop');
  const dateInput = document.getElementById('policyLockDate');

  // Toggle Row Visibility
  if (lockRow) {
    if (type === 'timelock') {
      lockRow.classList.remove('hidden');
      lockRow.style.display = 'flex'; // Ensure flex layout is applied
    } else {
      lockRow.classList.add('hidden');
      lockRow.style.display = 'none';
      
      // Cleanup: Clear date if user switches back to "Open"
      if (dateInput) dateInput.value = '';
      if (datePop) datePop.classList.add('hidden');
    }
  }
}

/* =========================================
   3. DATE PICKER LOGIC (CALENDAR ENGINE)
   ========================================= */
function initPolicyDatePicker() {
  // --- PART 1: SETUP ---
  const inp = document.getElementById('policyLockDate');
  const btn = document.getElementById('policyDateBtn');
  const pop = document.getElementById('policyDatePop');
  
  // If elements are missing, stop immediately to avoid errors
  if (!inp || !btn || !pop) return;

  let view = startOfDay(new Date());
  let selected = null;

  function isDisabled(dayDate) {
    const today = startOfDay(new Date());
    return startOfDay(dayDate) < today;
  }

  // --- PART 2: RENDER ENGINE ---
  function render() {
    const y = view.getFullYear();
    const m = view.getMonth();

    const first = new Date(y, m, 1);
    const last  = new Date(y, m + 1, 0);
    const startDow = (first.getDay() + 6) % 7; // Mon=0
    const daysInMonth = last.getDate();

    const monthName = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
    const dows = ['M','T','W','T','F','S','S'].map(s => `<div class="dp-dow">${s}</div>`).join('');

    let cells = '';
    for (let i = 0; i < startDow; i++) cells += `<div></div>`;

    for (let d = 1; d <= daysInMonth; d++) {
      const dt = new Date(y, m, d);
      const ymd = fmtYMD(dt);
      const dis = isDisabled(dt);
      const sel = (selected === ymd);
      cells += `<div class="dp-day${dis ? ' disabled' : ''}${sel ? ' selected' : ''}" data-ymd="${ymd}">${d}</div>`;
    }

    pop.innerHTML = `
      <div class="dp-head">
        <div class="dp-title">${monthName}</div>
        <div class="dp-nav">
          <button type="button" class="secondary icon-btn dp-btn" data-nav="prev"><i class="fas fa-chevron-left"></i></button>
          <button type="button" class="secondary icon-btn dp-btn" data-nav="next"><i class="fas fa-chevron-right"></i></button>
        </div>
      </div>
      <div class="dp-grid">${dows}${cells}</div>
    `;
  }

  // --- PART 3: INTERACTION (The code you just asked about) ---
  function open() {
    pop.classList.remove('hidden');
    render(); // Re-render when opening to ensure view is correct
  }
  
  function close() {
    pop.classList.add('hidden');
  }
  
  function toggle() {
    if (pop.classList.contains('hidden')) open();
    else close();
  }

  // Toggle listeners
  btn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); toggle(); });
  inp.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); toggle(); });

  // Navigation and Selection listeners
  pop.addEventListener('click', (e) => {
    // 1. Handle Navigation Buttons
    const nav = e.target.closest('[data-nav]')?.dataset?.nav || '';
    if (nav === 'prev') { view = new Date(view.getFullYear(), view.getMonth() - 1, 1); render(); return; }
    if (nav === 'next') { view = new Date(view.getFullYear(), view.getMonth() + 1, 1); render(); return; }

    // 2. Handle Day Selection
    const day = e.target.closest('.dp-day');
    if (!day) return;
    if (day.classList.contains('disabled')) return;

    const ymd = day.dataset.ymd;
    selected = ymd;
    inp.value = ymd;
    close();
  });

  // Close when clicking outside
  document.addEventListener('click', (e) => {
    if (pop.classList.contains('hidden')) return;
    const wrap = inp.closest('.datepick'); // Uses the wrapper div class="datepick"
    if (wrap && wrap.contains(e.target)) return;
    close();
  });
}


/* =========================================
   4. EXECUTION BLOCK (THE MISSING PIECE)
   ========================================= */
document.addEventListener('DOMContentLoaded', () => {
    // A. Start the Date Picker Engine
    initPolicyDatePicker();

    // B. Attach Listeners to Radio Buttons
    // This removes the need for onclick="" in your HTML
    const radios = document.querySelectorAll('input[name="policyType"]');
    radios.forEach(r => r.addEventListener('change', syncPolicyTypeUI));

    // C. Run once on load to ensure correct state
    syncPolicyTypeUI();
});


window.savePolicyAndCreateCollection = async function() {
    try {
        const name = (getEl('policyCollectionName')?.value || '').trim();
        if (!name) { alert('Enter a collection name'); return; }

        const policyChoice = document.querySelector('input[name="policyChoice"]:checked').value;
        const maxSupplyVal = parseInt(getEl('totalAssets')?.value || '0', 10) || 0;
        
        let policyId, nativeScript, type, lockDate, lockUntilSlot, ownerKeyHash;

        if (policyChoice === 'existing') {
            const select = document.getElementById('existingPolicySelect');
            if (!select.value) { alert('Please select a policy'); return; }
            
            const pData = JSON.parse(select.options[select.selectedIndex].dataset.policyRaw);
            policyId = pData.policyId;
            nativeScript = pData.nativeScript;
            type = pData.type || pData.policyType;
            lockDate = pData.lockUntil || pData.lockDate;
            lockUntilSlot = pData.lockUntilSlot;
            ownerKeyHash = pData.ownerKeyHash;
} else {
            // --- NEW: Generate Unique ID using "Salt" ---
            type = document.querySelector('input[name="policyType"]:checked')?.value || 'open';
            lockDate = (getEl('policyLockDate')?.value || '').trim();

            if (!studioWallet || !currentUser.address) { alert('Wallet not ready'); return; }
            if (type === 'timelock' && !lockDate) { alert('Pick lock date'); return; }

            ownerKeyHash = resolvePaymentKeyHash(currentUser.address);
            lockUntilSlot = '';

            // Calculate a "Start Slot" based on current time. 
            // This makes the script unique to this specific moment.
            // (Assumes 1 second = 1 slot, roughly accurate for mainnet/preprod)
            const nowMs = Date.now();
            // We use a slot from 10 minutes ago so the policy is valid immediately
            const startSlot = Math.floor((nowMs - 600000) / 1000); 

            if (type === 'timelock') {
                const lockMs = Date.parse(`${lockDate}T00:00:00Z`);
                if (!Number.isFinite(lockMs)) { alert('Invalid lock date'); return; }
                const netId = (typeof studioWallet.getNetworkId === 'function') ? await studioWallet.getNetworkId() : 1;
                const netName = (netId === 0) ? 'preprod' : 'mainnet';
                const slot = resolveSlotNo(netName, lockMs);
                lockUntilSlot = String(slot);
                nativeScript = {
                    type: 'all',
                    scripts: [
                        { type: 'before', slot: lockUntilSlot },
                        { type: 'sig', keyHash: ownerKeyHash }
                    ]
                };
            } else {
                // OPEN POLICY - UNIQUE
                // We add an "after" constraint effectively acting as a salt
                nativeScript = { 
                    type: 'all', 
                    scripts: [
                        { type: 'sig', keyHash: ownerKeyHash },
                        { type: 'after', slot: String(startSlot) } 
                    ]
                };
            }

            policyId = resolveNativeScriptHash(nativeScript);
        }
        // Create on Server
        const created = await createServerCollection({
            username: currentUser.username,
            identity: currentUser.identity,
            name,
            policyType: type,
            lockUntil: lockDate,
            lockUntilSlot,
            maxSupply: maxSupplyVal,
            policyId,
            ownerKeyHash,
            nativeScript
        });

        const key = created.key;

        // 1. Manually inject into local list at the START
        serverCollIndex.unshift({ 
            key: key, 
            label: name, 
            policy: created.policy 
        });

        // 2. Pre-populate Local State
        const newState = {
            collectionName: name,
            maxSupply: maxSupplyVal > 0 ? String(maxSupplyVal) : '',
            policy: created.policy,
            assetNameInput: '',
            saleDescription: '',
            collectionThumbInput: 'fbThumb.png',
        
            // CRITICAL: ensure brand-new collection cannot inherit globals by omission
            defaultProps: {},
            metaRows: [],
            codeRows: [],
            studioAssets: []
        };
        collStateMem.set(String(key), newState);

        // 3. Update Tabs & Switch
        setActiveCollKey(key);
        renderCollectionTabsUI();
        await switchToCollection(key);

        // 4. RETRY MONITOR: Ensure fields populate
        let attempts = 0;
        const checker = setInterval(() => {
            attempts++;
            const pInput = document.getElementById('policyIdFull');
            const nInput = document.getElementById('collectionName');
            const pDisp = document.getElementById('policyIdShort');

            if(pInput && created.policy && pInput.value !== created.policy.policyId) {
                 pInput.value = created.policy.policyId;
                 if(pDisp) pDisp.textContent = created.policy.policyId.substring(0, 12) + '...';
            }
            if(nInput && nInput.value !== name) {
                 nInput.value = name;
            }

            if(attempts > 12) clearInterval(checker);
        }, 250);

        closeModal('policyModal');
    } catch (e) {
        console.error(e);
        alert(e.message || 'Failed to create collection');
    }
};


function renderCollectionTabsUI() {
    // backwards-compat: older flows still call this after create
    window.addCollectionTab = function(key) {
        setActiveCollKey(String(key || ''));
        renderCollectionTabsUI();
    };
    
    const tabs = document.getElementById('collectionTabs');
    if (!tabs) return; 

    // Remove old tabs
    tabs.querySelectorAll('button.tab-btn[data-coll]').forEach(b => b.remove());

    const active = getActiveCollKey();
    const idx = Array.isArray(serverCollIndex) ? serverCollIndex : [];

    idx.forEach((c) => {
        const key = String(c.key || c.id || c.slug || '');
        if (!key) return;

        const label = String(c.name || c.label || key);

        const b = document.createElement('button');
        b.className = 'tab-btn';
        b.dataset.coll = key; // Essential for your app's internal delegation
        

// CLICK HANDLER: Sets the active key and refreshes tabs
        b.onclick = async function(e) {
             if(e.target.classList.contains('coll-del')) return;
             
             // CRITICAL FIX: Use switchToCollection. 
             // This function handles:
             // 1. Saving the PREVIOUS collection's data (preventing data loss)
             // 2. Setting the new Active Key
             // 3. Wiping the UI and loading the NEW collection's data (preventing contamination)
             await switchToCollection(key);

initializeStudioSections();
        };
        
        if (key === active) b.classList.add('active');

        const delSpan = `<span class="coll-del" data-del="${key}" title="Delete">×</span>`;
        b.innerHTML = `<span class="tlabel">${label}</span>${delSpan}`;

        // Append to container (Fixes the "insertBefore" error)
        tabs.appendChild(b);
    });

    // Re-attach delete listeners
    tabs.querySelectorAll('.coll-del').forEach(delBtn => {
        delBtn.onclick = function(e) {
            e.stopPropagation();
            const k = this.dataset.del;
if(confirm('Permanently delete this collection and its policy?')) {
    // FIX: Actually call the delete function
    deleteCollection(k);
}
        };
    });
if (active) {
        populateStudioFields();
    }
}

function populateStudioFields() {
    // 1. Get the active collection key
    const key = getActiveCollKey();
    if (!key) return;

    // 2. Find the collection object in your data array
    const coll = Array.isArray(serverCollIndex) ? serverCollIndex.find(c => (c.key || c.id || c.slug) === key) : null;
    
    if (!coll) {
        console.warn("Collection not found for key:", key);
        return;
    }


// --- 2a. FETCH MISSING POLICY DATA ---
    if (!coll.policyId && !coll.loadingPolicy) {
        coll.loadingPolicy = true; 

        // 1. GET THE USERNAME
        // Change 'username' to whatever key you use to save the user's name
        const username = (currentUser.username || '').trim();
        
        // 2. CONSTRUCT THE CORRECT PATH
        // Path: /idp/USERNAME/mint/COLLECTION_KEY/policy.json
        const fetchPath = `/idp/${username}/mint/${key}/policy.json`;

        fetch(fetchPath)
            .then(res => {
                if(!res.ok) throw new Error(`No policy file at ${fetchPath}`);
                return res.json();
            })
            .then(data => {
                // ... (rest of the logic remains the same)
                Object.assign(coll, data);
                if(data.maxSupply) coll.supply = data.maxSupply;
                coll.loadingPolicy = false; 
                populateStudioFields();
            })
            .catch(err => {
                console.warn("Could not load policy details:", err);
                coll.loadingPolicy = false;
            });

        const shortEl = document.getElementById('policyIdShort');
        if(shortEl) shortEl.innerText = "Loading...";
        return; 
    }
    
    
    // --- POLICY ID LOGIC ---
    // Now this will work because we fetched the data above
    const polId = coll.policyId || coll.id || "Not Created Yet";

    const shortEl = document.getElementById('policyIdShort');
    if(shortEl) {
        shortEl.innerText = polId.length > 10 ? polId.substring(0, 5) + '...' : polId;
    }

    const fullEl = document.getElementById('policyIdFull');
    if(fullEl) {
        fullEl.value = polId;
    }

    // --- POLICY TYPE LOGIC ---
    // policy.json uses 'type' (e.g. "open"), code was looking for 'policyType'.
    // We check both just to be safe.
    const pType = coll.type || coll.policyType;
    const isLocked = (pType === 'timelock'); 
    const typeStr = isLocked ? 'LOCKED' : 'OPEN';

    const badge = document.getElementById('policyTypeHeader');
    if(badge) {
        badge.innerText = typeStr;
        badge.style.color = isLocked ? '#ff6b6b' : 'var(--primary)';
        badge.style.background = isLocked ? 'rgba(255,107,107,0.2)' : 'rgba(33,150,243,0.2)';
    }

    const typeDisp = document.getElementById('policyTypeDisplay');
    if(typeDisp) {
        typeDisp.innerText = typeStr;
        typeDisp.style.color = isLocked ? '#ff6b6b' : 'var(--primary)';
    }

    // --- LOCK DATE / COUNTDOWN ---
    const lockRow = document.getElementById('lockDetailsCol');
    if(lockRow) {
        // Check both 'lockDate' and 'lockUntil' (from your json)
        const lDate = coll.lockDate || coll.lockUntil; 
        
        if(isLocked && lDate) {
            lockRow.style.display = 'block';
            const dateEl = document.getElementById('lockDateDisplay');
            if(dateEl) dateEl.innerText = lDate;
            
            const target = new Date(lDate).getTime();
            const now = new Date().getTime();
            const diff = target - now;
            const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
            
            const daysEl = document.getElementById('daysLeft');
            if(daysEl) daysEl.innerText = days > 0 ? days : 0;
            
        } else {
            lockRow.style.display = 'none';
        }
    }

    // --- POPULATE INPUTS ---
    const nameInput = document.getElementById('collectionName');
    const supplyInput = document.getElementById('totalAssets');
    const descInput = document.getElementById('saleDescription');

    // --- REAL-TIME DATA BINDING ---
    if(nameInput) {
        nameInput.oninput = function() {
            coll.name = this.value;
            const activeTabLabel = document.querySelector(`.tab-btn[data-coll="${key}"] .tlabel`);
            if(activeTabLabel) activeTabLabel.innerText = this.value || key;
        };
    }

    if(descInput) {
        descInput.oninput = function() {
            coll.description = this.value;
        };
    }
}

function renderPolicyUI(policy) {
  const sum = document.getElementById('policySummary');
  const body = document.querySelector('#policySection .sectionBody');
  if (!sum || !body) return;

  if (!policy) {
    sum.textContent = '';
    body.innerHTML = `<div class="hint">No policy yet. Click <b>+ New Collection</b> to create one.</div>`;
    return;
  }

  const policyId  = String(policy.policyId || policy.policy_id || policy.id || '');
  const policyType = String(policy.policyType || policy.type || '').toLowerCase();
  const lockUntil = String(policy.lockUntil || policy.lock_until || policy.lockDate || '');

  sum.textContent = policyId ? `${policyId.slice(0, 12)}…` : (policyType ? policyType.toUpperCase() : 'Policy');

  body.innerHTML = `
    <div class="row">
      <div class="col">
        <label>Policy ID</label>
        <input type="text" value="${policyId}" readonly>
      </div>
      <div class="col">
        <label>Policy Type</label>
        <input type="text" value="${policyType || ''}" readonly>
      </div>
    </div>
    ${policyType === 'timelock' ? `
    <div class="row">
      <div class="col">
        <label>Lock Until</label>
        <input type="text" value="${lockUntil}" readonly>
      </div>
    </div>` : ''}
  `;
}


function saveActiveCollectionState() {
    const k = getActiveCollKey();
    if (!k) return;

    // 1) Scrape current global defaults from the DOM
    const currentDefaults = getLiveDefaultProps();

    // 2) Sync defaults into live assets BEFORE saving
    syncDefaultPropsToAllAssets(currentDefaults);

    // 3) Merge: previous saved state + current UI scrape
    const prev = loadCollectionState(k) || {};
    const ui = readCollectionStateFromUI();

    const merged = {
        ...prev,
        ...ui,
        defaultProps: currentDefaults,
        studioAssets: studioAssets
    };

    // CRITICAL FIX:
    // Do NOT delete merged.metaRows.
    // These rows are the "master list" that keeps +New Property behaving as a global row across reloads.

    // 4) Save to memory
    collStateMem.set(String(k), merged);

    // 5) Save to server (silent)
    const username = (currentUser.username || '').trim();
    if (username) {
        const formData = new FormData();
        formData.append('username', username);
        formData.append('collectionKey', k);
        formData.append('jsonData', JSON.stringify(merged));

        fetch('api/save_collection_data.php', { method: 'POST', body: formData })
            .catch(e => console.warn("Auto-save network error:", e));
    }

    // 6) Refresh preview
    if (typeof updateAssetPreview === 'function') updateAssetPreview();
}

function loadCollectionState(k) {
  return collStateMem.get(String(k || '')) || null;
}



async function switchToCollection(key) {
    key = String(key || '');

    document.getElementById('noCollectionsNote')?.classList.add('hidden');
    document.getElementById('collectionPanel')?.classList.remove('hidden');

    // 1. Save current state before switching (only if we have a different active key)
    const currentKey = getActiveCollKey();
    if (currentKey && currentKey !== key) {
        saveActiveCollectionState();
    }

    setActiveCollKey(key);

    // 2. --- NEW: FETCH DATA IF MISSING (RESTORES STATE ON RELOAD) ---
    // Check if we have data in memory. If not, fetch it from the server.
    let state = loadCollectionState(key);

    if (!state && currentUser.username) {
        try {
            // Add timestamp to prevent caching
            const res = await fetch(`/idp/${currentUser.username}/mint/${key}/collection.json?t=${Date.now()}`);
            if (res.ok) {
                const remoteData = await res.json();
                
                // A. Save to Memory
                collStateMem.set(key, remoteData);
                state = remoteData;

                // B. Update Server Index (Fixes the Tab Label "new-2" -> "My Cool Collection")
                const idxEntry = Array.isArray(serverCollIndex) ? serverCollIndex.find(c => (c.key||c.id||c.slug) === key) : null;
                if (idxEntry && remoteData.collectionName) {
                    idxEntry.label = remoteData.collectionName;
                    idxEntry.name = remoteData.collectionName; 
                }
            }
        } catch (e) {
            console.warn("Could not fetch saved collection data:", e);
        }
    }

    // 3. Render Tabs (Now that we potentially fixed the name/label)
    renderCollectionTabsUI();

    // 4. Find server entry (for policy reference)
    const entry = (Array.isArray(serverCollIndex) ? serverCollIndex : []).find(x => {
        const kk = String(x.key || x.id || x.slug || '');
        return kk === key;
    });

    // 5. Prepare defaults so UI doesn't crash on missing fields
    const defaults = {
        collectionName: String(entry?.label || entry?.name || key),
        totalAssets: '1',
        saleDescription: '',
        dist: 'random',
        astype: 'nft',
        useCollName: true,
        assetNameInput: '',
        editionInput: '',
        ftTicker: '',
        useWalletAddr: false,
        receiveAddr: '',
        costType: 'free',
        mintCost: '',
        encoding: 'base64',
        codeContent: '',
        collectionThumbInput: 'fbThumb.png',
        previewImgInput: '',
        defaultProps: {},
        metaRows: [],
        codeRows: []
    };

    // 6. Merge: Defaults -> Saved State
    const merged = { ...defaults, ...(state || {}) };

    // 7. Write to UI
    writeCollectionStateToUI(merged);

    // 8. Render Policy (Server-first, then local)
    renderPolicyUI(entry?.policy || merged.policy || null);

   
    // 10. Refresh Stats
    if (typeof window.loadCollectionStats === 'function') await window.loadCollectionStats();
}


function createCollection() {
  const idx = ensureCollIndex();

  const name = (prompt('Collection name?', `Collection ${idx.length + 1}`) || '').trim();
  if (!name) return;

  const key = 'coll_' + Date.now().toString(36);
  idx.push({ key, label: name });
  saveCollIndex(idx);

  renderCollectionTabsUI();
  switchToCollection(key);
}

async function deleteCollection(key) {
  key = String(key || '');
  if (!key) return;

  // Confirmation is handled by the button click listener. Proceeding...

  // 1. Update Local Data Immediately (Visual Feedback)
  serverCollIndex = serverCollIndex.filter(c => (c.key || c.id || c.slug) !== key);
  collStateMem.delete(String(key));

  // 2. Determine Next Tab
  const next = serverCollIndex[0]?.key || '';
  
  // 3. Update UI
  setActiveCollKey(next);
  renderCollectionTabsUI();
  
  if (next) {
      await switchToCollection(next);
  } else {
      document.getElementById('collectionPanel').classList.add('hidden');
      document.getElementById('noCollectionsNote').classList.remove('hidden');
  }

  // 4. Send Delete Request (Silent / Background)
  try {
    await deleteServerCollection(key);
  } catch (e) {
    console.warn("Delete API warning:", e.message);
  }
}

let saveTimer = null;
function scheduleSaveActive() {
  clearTimeout(saveTimer);
  saveTimer = setTimeout(() => {
    saveActiveCollectionState();
  }, 250);
}

async function initCollections() {
    // 1. Get the list of folders/keys
    await loadServerCollIndex();
    
    // 2. --- NEW: FETCH THE CONTENTS OF ALL FOLDERS ---
    await loadAllCollectionsData();

    // 3. Render the tabs
    renderCollectionTabsUI();

    // 4. Setup listeners
    document.querySelectorAll('input[name="policyType"]').forEach(r => r.addEventListener('change', syncPolicyTypeUI));
    if(typeof initPolicyDatePicker === 'function') initPolicyDatePicker();

    const addBtn = document.getElementById('btnAddCollection');
    if (addBtn) addBtn.onclick = () => openNewCollectionModal();

    const tabs = document.getElementById('collectionTabs');
    if (tabs) {
        tabs.addEventListener('click', async (e) => {
            const del = e.target.closest('.coll-del');
            if (del?.dataset?.del) return deleteCollection(del.dataset.del);
        });
    }

    // 5. Autosave listener for the ACTIVE view
    const studio = document.getElementById('creatorStudio');
    if (studio) {
        // Remove potentially duplicate listeners first
        studio.removeEventListener('input', scheduleSaveActive);
        studio.removeEventListener('change', scheduleSaveActive);

        studio.addEventListener('input', (e) => {
            // FIX: If typing in a Key field, DO NOT Autosave yet.
            // This prevents "Globa", "Global" duplicates from forming.
            if (e.target.classList.contains('p-key')) return;
            
            scheduleSaveActive();
        });

        // We still save on 'change' (blur/enter), which safely captures the finished Key.
        studio.addEventListener('change', scheduleSaveActive);
    }

    // 6. Open the first tab (or saved active tab)
    const saved = getActiveCollKey();
    const first = serverCollIndex[0]?.key || '';
    const use = serverCollIndex.some(c => (c.key||c.id) === saved) ? saved : first;

    if (use) await switchToCollection(use);
}


async function loadAllCollectionsData() {
    if (!currentUser.username || !serverCollIndex.length) return;

    // Create an array of fetch promises (run them all at once)
    const promises = serverCollIndex.map(async (colEntry) => {
        const key = String(colEntry.key || colEntry.id || colEntry.slug);
        try {
            // Fetch the JSON for this collection
            const res = await fetch(`/idp/${currentUser.username}/mint/${key}/collection.json?t=${Date.now()}`);
            if (res.ok) {
                const data = await res.json();
                
                // 1. Update the Tab Label Source (serverCollIndex)
                if (data.collectionName) {
                    colEntry.name = data.collectionName;
                    colEntry.label = data.collectionName;
                }

                // --- 1b. FIX: Sync Assets to Index for Initial Render ---
                // This ensures the renderer sees the real names ("New Test 66 #1")
                // instead of falling back to filenames ("NewTest661").
                if (data.studioAssets && Array.isArray(data.studioAssets)) {
                     colEntry.studioAssets = data.studioAssets;
                }

                // 2. Pre-load into Memory (collStateMem)
                // This ensures that when you click the tab, the data is already waiting
                // We merge with defaults to ensure safety
                const defaults = {
                    collectionName: colEntry.name,
                    // ... (other defaults handled by switchToCollection logic)
                };
                const merged = { ...defaults, ...data };
                collStateMem.set(key, merged);
            }
        } catch (e) {
            // If file missing (new collection), just ignore
        }
    });

    // Wait for all fetches to finish
    await Promise.all(promises);
    
    // Now re-render tabs to show the correct names we just found
    renderCollectionTabsUI();
}


let pendingPreset = null;
let collectionThumbSrc = "fbThumb.png";
let mintPreviewLocked = false; // prevents updates while waiting animation is running
let mintPreviewState = "idle"; // "idle" | "minting" | "postMint"
let mintRevealTimer = null;

function showMintOverlay(show, text) {
  const ov = document.getElementById('mintPreviewOverlay');
  const tx = document.getElementById('mintPreviewOverlayText');
  if (!ov) return;
  if (tx && typeof text === "string") tx.textContent = text;
  ov.classList.toggle('hidden', !show);
}

function normalizeImgSrc(src) {
  const s = (src || "").trim();
  if (!s) return "fbThumb.png";
  if (s.startsWith("ipfs://")) return "https://ipfs.io/ipfs/" + s.replace("ipfs://", "");
  return s;
}

function getCollectionThumbForMint() {
  const v = (document.getElementById('collectionThumbInput')?.value || "").trim();
  const p = document.getElementById('collectionThumbPreview')?.src || "";
  return normalizeImgSrc(v || p || "fbThumb.png");
}

function getPurchasedAssetPreviewSrc() {
  // What the buyer "purchased" visual should be:
  // Prefer visualPreview (creator-set asset thumb); fallback to previewImgInput if it's an image src; final fallback collection thumb.
  const v = document.getElementById('visualPreview')?.src || "";
  if (v) return normalizeImgSrc(v);

  const raw = (document.getElementById('previewImgInput')?.value || "").trim();
  if (raw) return normalizeImgSrc(raw);

  return getCollectionThumbForMint();
}

// --- LOGIC: Tracking ---
function getCollectionKey() {
    const coll = document.getElementById('collectionName').value.trim() || "Default";
    const t = document.querySelector('input[name="astype"]:checked').value;
    return `f5_${coll}_${t}`;
}

// --- LOGIC: Properties ---
function renderDefaultProps() {
    const container = document.getElementById('defaultProps');
    if (!container) return;
    
    // A. LOAD SAVED DATA for the current collection
    // This ensures that when we switch assets/tabs, we restore what was saved.
    const k = getActiveCollKey();
    const savedState = k ? (collStateMem.get(String(k)) || {}) : {};
    const savedProps = savedState.defaultProps || {};

    // Helper to check if a key is "Standard" (Hardcoded)
    const isStandard = (key) => DEFAULT_PROPS.includes(key);

    // B. Clear Container to rebuild from state (Ensures clean UI sync)
    // Note: We don't worry about "focus loss" here because renderDefaultProps 
    // should only run on LOAD or TAB SWITCH, not on every keystroke.
    container.innerHTML = "";
    
    // C. Render STANDARD Props (Artist, Description, etc.)
    DEFAULT_PROPS.forEach(p => {
        const savedVal = savedProps[p] || "";
        
        const div = document.createElement('div');
        div.className = "prop-row";
        div.innerHTML = `
            <div style="color:var(--text-light)"><i class="fas fa-tag"></i></div>
            <div style="font-size:0.9rem; color:var(--text-light)">${p}</div>
            <input type="text" class="prop-val" data-prop="${p}" value="${savedVal}" placeholder="Value for ${p}...">
            <button class="danger icon-btn" onclick="this.closest('.prop-row').remove(); window.triggerAutosave && window.triggerAutosave();">×</button>
        `;
        container.appendChild(div);
    });

    // D. Render CUSTOM/GLOBAL Props (The ones you added dynamically)
    // We look at the keys in savedProps that are NOT in DEFAULT_PROPS
    Object.keys(savedProps).forEach(key => {
        if (isStandard(key)) return; // Already handled above

        const val = savedProps[key];
        const div = document.createElement('div');
        div.className = "prop-row meta-row"; // Add meta-row class if needed for styling
        
        // Re-create the "Dual Input" HTML for custom keys
        div.innerHTML = `
            <div style="color:var(--text-light)"><i class="fas fa-tag"></i></div>
            <input type="text" class="p-key" value="${key}" placeholder="Global Key">
            <div class="col">
                <input type="text" class="p-val" value="${val}" placeholder="Global Value">
            </div>
            <button class="danger icon-btn" onclick="this.closest('.prop-row').remove(); window.triggerAutosave && window.triggerAutosave();">×</button>
        `;
        container.appendChild(div);
    });
}


window.applyCollectionThumbFromInput = function() {
  const val = (document.getElementById('collectionThumbInput')?.value || 'fbThumb.png').trim() || 'fbThumb.png';

  // preview in metadata tab
  const prev = document.getElementById('collectionThumbPreview');
  if (prev) {
    prev.src = val;
    prev.style.display = 'block';
  }

  // update mint preview thumb ONLY when not locked and checkbox is NOT forcing asset thumb
  window.collectionThumbSrc = val;

  const useAsset = document.getElementById('useAssetThumbInMint')?.checked ?? false;
  if (!window.mintPreviewLocked && !useAsset && typeof window.setMintPreviewToCollectionThumb === 'function') {
    window.setMintPreviewToCollectionThumb();
  }
};
function setupCollectionThumbDropZone() {
  const zone = document.getElementById('collectionThumbDropZone');
  if (!zone) return;

  const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };

  zone.addEventListener('dragenter', (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragover',  (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragleave', (e) => { prevent(e); zone.classList.remove('drag-active'); });
  zone.addEventListener('drop', (e) => {
    prevent(e);
    zone.classList.remove('drag-active');

    // creator-only
    if (currentUser.identity !== currentUser.identity) return;

    const f = e.dataTransfer?.files?.[0];
    if (f) handleCollectionThumbFile(f);
  });
}


// --- LOGIC: Role-Based View ---
function isCreatorUser() {
  return !!(currentUser.identity && currentUser.identity && currentUser.identity === currentUser.identity);
}

function updateViewMode() {
    // Get all references safely
    const builder = document.getElementById('creatorStudio');
    const bannerBtn = document.getElementById('bannerUploadBtn');
    const collThumbHint = document.getElementById('collectionThumbHint');
    const bannerHint = document.getElementById('bannerHint');
    const thumbHint  = document.getElementById('thumbHint');
    const assetPreviewHint = document.getElementById('assetPreviewHint');
    const mintThumbBtn = document.getElementById('mintThumbUploadBtn');
    const mintThumbHint = document.getElementById('mintThumbHint');
    const collUploadBtn = document.getElementById('btnUploadCollectionThumb');
    
    // Logic check (Preserving your existing logic structure)
    // Note: The original logic 'if(id === id)' is always true, forcing this block to run.
    const isCreator = (currentUser.identity === currentUser.identity);

    if (isCreator) {
        if(builder) builder.style.display = 'block';
        if(bannerBtn) bannerBtn.style.display = 'flex';
        
        bannerHint?.classList.remove('hidden');
        collThumbHint?.classList.remove('hidden');
        thumbHint?.classList.remove('hidden');
        assetPreviewHint?.classList.remove('hidden');
        
        if(mintThumbBtn) mintThumbBtn.style.display = 'inline-flex';
        mintThumbHint?.classList.remove('hidden');
        
        collUploadBtn?.classList.remove('hidden');
        
    } else {
        if(builder) builder.style.display = 'none';
        if(bannerBtn) bannerBtn.style.display = 'none';
        
        bannerHint?.classList.add('hidden');
        collThumbHint?.classList.add('hidden');
        thumbHint?.classList.add('hidden');
        assetPreviewHint?.classList.add('hidden');
        
        if(mintThumbBtn) mintThumbBtn.style.display = 'none';
        mintThumbHint?.classList.add('hidden');
        
        collUploadBtn?.classList.add('hidden');
    }
}

function setMintPreviewToCollectionThumb() {
  const img = document.getElementById('mintCollectionPreview');
  const frame = document.getElementById('mintMediaFrame');
  const overlay = document.getElementById('mintWaitOverlay');
  if (!img || !frame || !overlay) return;

  overlay.classList.add('hidden');
  frame.classList.add('hidden');
  img.classList.remove('hidden');

  img.src = collectionThumbSrc || "fbThumb.png";
}

function beginMintWaiting(mintPreview) {
  const overlay = document.getElementById('mintWaitOverlay');
  if (!overlay) return;

  mintPreviewLocked = true;
  overlay.classList.remove('hidden');

  // show minted media after ~5s
  setTimeout(() => {
    showMintedMedia(mintPreview);
    mintPreviewLocked = false;
  }, 5200);
}

function showMintedMedia(mintPreview) {
  const img = document.getElementById('mintCollectionPreview');
  const frame = document.getElementById('mintMediaFrame');
  const overlay = document.getElementById('mintWaitOverlay');
  if (!img || !frame || !overlay) return;

  overlay.classList.add('hidden');

  const src = mintPreview?.fileSrc || '';
  const mt  = (mintPreview?.fileMediaType || '').toLowerCase();

  // If we have renderable HTML, use iframe
  if (src.startsWith('data:text/html') || mt.includes('text/html')) {
    img.classList.add('hidden');
    frame.classList.remove('hidden');
    frame.src = src;
    return;
  }

  // Otherwise show thumbnail image
  frame.classList.add('hidden');
  img.classList.remove('hidden');
  img.src = mintPreview?.thumbSrc || document.getElementById('visualPreview')?.src || collectionThumbSrc || "fbThumb.png";
}

function buildMintPreviewFromMetadata(metadata) {
  const file0 = metadata?.files?.[0];
  const fileSrc = Array.isArray(file0?.src) ? file0.src.join('') : '';
  const fileMediaType = String(file0?.mediaType || '');

  // Prefer asset thumb if present, otherwise fall back to collection thumb
  const thumbSrc =
    document.getElementById('visualPreview')?.src ||
    collectionThumbSrc ||
    "fbThumb.png";

  return { fileSrc, fileMediaType, thumbSrc };
}

function handleMintThumbFile(file) {
  if (!file) return;
  if (!file.type.startsWith('image/')) return alert("Thumb must be an image");
  if (file.size > 5 * 1024 * 1024) return alert("File too big (Max 5MB)");

  const url = URL.createObjectURL(file);
  collectionThumbSrc = url;

  // Only update if we’re not currently showing the mint waiting/minted preview
  if (!mintPreviewLocked) setMintPreviewToCollectionThumb();

  log("Collection sale thumbnail updated (Backend req for save)", "success");
}

function setupMintThumbDropZone() {
  const zone = document.getElementById('mintThumbArea');
  if (!zone) return;

  const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };

  zone.addEventListener('dragenter', (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragover',  (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragleave', (e) => { prevent(e); zone.classList.remove('drag-active'); });
  zone.addEventListener('drop', (e) => {
    prevent(e);
    zone.classList.remove('drag-active');
    const f = e.dataTransfer?.files?.[0];
if (currentUser.identity !== currentUser.identity) return;
if (f) handleCollectionThumbFile(f);
  });
}

// --- LOGIC: Import/Export ---
function exportConfig() {
    if(!currentUser.identity) currentUser.identity = currentUser.identity; // Claim ownership if exporting
    
    const config = {
        creator: currentUser.identity,
        collectionName: document.getElementById('collectionName').value,
        description: document.getElementById('saleDescription').value,
        maxSupply: document.getElementById('totalAssets').value,
        assetName: document.getElementById('assetNameInput').value,
        cost: document.getElementById('mintCost').value,
        receiveAddr: document.getElementById('receiveAddr').value,
        code: document.getElementById('codeContent').value,
        metaProps: [],
        codeProps: []
    };
    
    // Gather Props
    document.querySelectorAll('.meta-row:not(.default-prop)').forEach(row => {
        config.metaProps.push({
            key: row.querySelector('.p-key').value,
            val: row.querySelector('.p-val').value,
            all: row.querySelector('.p-all').checked
        });
    });
    
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config));
    const dlAnchor = document.createElement('a');
    dlAnchor.setAttribute("href", dataStr);
    dlAnchor.setAttribute("download", "eyez_config.json");
    dlAnchor.click();
}

function importConfig(e) {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        const config = JSON.parse(event.target.result);
        currentUser.identity = config.creator;
        
        document.getElementById('collectionName').value = config.collectionName || "";
        document.getElementById('saleDescription').value = config.description || "";
        document.getElementById('displayDesc').textContent = config.description || "";
        document.getElementById('totalAssets').value = config.maxSupply || 1;
        document.getElementById('codeContent').value = config.code || "";
        document.getElementById('mintCost').value = config.cost || 0;
        document.getElementById('receiveAddr').value = config.receiveAddr || "";
        
        // Restore props logic would go here loop
        updateViewMode();
        updateAssetPreview();
        log("Configuration Imported", "success");
    };
    reader.readAsText(file);
}

// --- LOGIC: Metadata Editor ---
function buildMetadataForAsset(asset) {
    const safeAsset = asset || {};
    const meta = {
        name: safeAsset.name || '',
        image: safeAsset.coverImage ? (safeAsset.coverImage.length > 64 ? safeAsset.coverImage.match(/.{1,64}/g) : safeAsset.coverImage) : 'ipfs://placeholder',
        mediaType: 'image/png',
        files: []
    };

    const traits = (safeAsset.traits && typeof safeAsset.traits === 'object') ? safeAsset.traits : {};
    let fileObjName = '';

    Object.entries(traits).forEach(([k, v]) => {
        if (k == null) return;
        const key = String(k).trim();
        if (!key) return;
        if (v == null) return;
        if (typeof v === 'string' && v.trim() === '') return;

        if (key.toLowerCase() === 'name') {
            fileObjName = String(v);
            return;
        }

        if (key.toLowerCase() === 'links') {
            meta.links = { web: Array.isArray(v) ? v.join('') : v };
            return;
        }

        meta[key.toLowerCase()] = v;
    });

    const chunks = (safeAsset.mainContent || '').match(/.{1,64}/g) || [];
    const file0 = {
      mediaType: (safeAsset.mainEncoding === 'utf8') ? 'text/html;charset=utf-8' : 'text/html',
      src: chunks
    };

    const nm = String(fileObjName ?? '').trim();
    if (nm !== '') file0.name = nm;

    meta.files.push(file0);
    return meta;
}

function applyJsonToAsset(asset, targetData) {
    if (!asset || !targetData || typeof targetData !== 'object') return;

    if (typeof targetData.name === 'string' && targetData.name.trim()) {
        asset.name = targetData.name.trim();
    }

    if (targetData.image) {
        asset.coverImage = Array.isArray(targetData.image) ? targetData.image.join('') : String(targetData.image);
    }

    const nextTraits = {};
    const existingTraits = (asset.traits && typeof asset.traits === 'object') ? asset.traits : {};

    Object.entries(existingTraits).forEach(([k, v]) => {
        if (k && DEFAULT_PROPS.includes(k)) nextTraits[k] = v;
    });

    Object.entries(targetData).forEach(([key, val]) => {
        const low = String(key).toLowerCase();
        if (['name','image','mediatype','files','links'].includes(low)) return;
        nextTraits[key] = val;
    });

    const fileName = targetData.files?.[0]?.name;
    if (fileName != null && String(fileName).trim() !== '') {
        nextTraits.Name = String(fileName);
    }

    if (targetData.links && typeof targetData.links === 'object' && targetData.links.web != null) {
        nextTraits.Links = targetData.links.web;
    }

    asset.traits = nextTraits;

    const srcData = targetData.files?.[0]?.src;
    if (srcData != null) {
        asset.mainContent = Array.isArray(srcData) ? srcData.join('') : String(srcData);
    }

    const srcMediaType = String(targetData.files?.[0]?.mediaType || '').toLowerCase();
    asset.mainEncoding = srcMediaType.includes('utf-8') ? 'utf8' : (asset.mainEncoding || 'base64');
}

function setMetaEditorMode(mode) {
    const backBtn = document.getElementById('metaEditorBackBtn');
    const saveBtn = document.getElementById('metaEditorSaveBtn');
    const title = document.querySelector('#metaEditorModal .modal-title');
    if (backBtn) backBtn.textContent = 'Go Back';
    if (saveBtn) saveBtn.textContent = 'Save';
    if (title) title.textContent = mode === 'asset' ? 'Asset JSON Editor' : 'Metadata Editor';
}

function openMetaEditor() {
    let fullCollectionMeta = [];

    if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
    }

    studioAssets.forEach(asset => {
        fullCollectionMeta.push(buildMetadataForAsset(asset));
    });

    const finalOutput = fullCollectionMeta.length === 1 ? fullCollectionMeta[0] : fullCollectionMeta;
    document.getElementById('jsonEditorArea').value = JSON.stringify(finalOutput, null, 2);
    document.getElementById('jsonError').style.display = 'none';
    metaEditorState = { mode: 'collection', assetIndex: -1 };
    setMetaEditorMode('collection');
    document.getElementById('metaEditorModal').classList.add('open');
}

function openAssetJsonEditor(assetIndex) {
    if (assetIndex < 0 || assetIndex >= studioAssets.length) return;

    if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
    }

    const targetAsset = studioAssets[assetIndex];
    const jsonStr = JSON.stringify(buildMetadataForAsset(targetAsset), null, 2);

    metaEditorState = { mode: 'asset', assetIndex: assetIndex };
    setMetaEditorMode('asset');
    document.getElementById('jsonEditorArea').value = jsonStr;
    document.getElementById('jsonError').style.display = 'none';
    document.getElementById('metaEditorModal').classList.add('open');
}

function metaEditorGoBack() {
    document.getElementById('jsonError').style.display = 'none';
    closeModal('metaEditorModal');
}

function metaEditorSave() {
    const txt = document.getElementById('jsonEditorArea').value;
    try {
        const parsed = JSON.parse(txt);
        document.getElementById('jsonError').style.display = 'none';

        if (metaEditorState.mode === 'asset') {
            const idx = metaEditorState.assetIndex;
            if (idx > -1 && studioAssets[idx]) {
                applyJsonToAsset(studioAssets[idx], parsed);
                normalizeStudioAssetNames();
                if (studioSelectedAssetIndex === idx) {
                    selectStudioAsset(idx);
                } else {
                    renderStudioPreview();
                }
            }
            saveActiveCollectionState();
            updateAssetPreview();
            closeModal('metaEditorModal');
            log('Asset JSON saved', 'success');
            return;
        }

        // Collection editor behavior (existing build-section editor)
        let targetData = parsed;
        if (Array.isArray(parsed)) {
            const idx = (studioSelectedAssetIndex > -1) ? studioSelectedAssetIndex : 0;
            targetData = parsed[idx] || parsed[0];
        }

        if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
            const asset = studioAssets[studioSelectedAssetIndex];
            applyJsonToAsset(asset, targetData);
            updateAssetObjectFromUI(asset);
            if (typeof scheduleSaveActive === 'function') {
                scheduleSaveActive();
            } else if (typeof saveActiveCollectionState === 'function') {
                saveActiveCollectionState();
            }
        }

        syncDefaultPropsToAllAssets();
        renderStudioPreview();
        closeModal('metaEditorModal');
        log('JSON Saved & Inputs Updated', 'success');
        updateAssetPreview();

    } catch(e) {
        document.getElementById('jsonError').textContent = 'Invalid JSON: ' + e.message;
        document.getElementById('jsonError').style.display = 'block';
    }
}

window.saveJsonEdit = metaEditorSave;

// --- LOGIC: Code Sandwich (Decode -> Replace -> Encode) ---
function prepareContent() {
  let content = document.getElementById('codeContent').value.trim();
  let rawStr = content;
  let isBase64 = false;
  let mimeType = "text/html"; 
const enc = document.querySelector('input[name="encoding"]:checked')?.value || "base64";
const useUtf8 = (enc === "utf8");

  const safeDecode = (str) => {
      try { return new TextDecoder().decode(Uint8Array.from(atob(str), c => c.charCodeAt(0))); } 
      catch (e) { return atob(str); }
  };
  const safeEncode = (str) => {
      try { return btoa(String.fromCharCode(...new TextEncoder().encode(str))); } 
      catch (e) { return btoa(str); }
  };

  if(content.startsWith("data:")) {
      const parts = content.split(',');
      if(parts[0].includes(':') && parts[0].includes(';')) mimeType = parts[0].split(':')[1].split(';')[0];
      rawStr = safeDecode(parts[1].replace(/\s/g, '')); 
  } else if (!content.includes("<") && /^[A-Za-z0-9+/=]+$/.test(content.replace(/\s/g, ''))) {
      rawStr = safeDecode(content.replace(/\s/g, ''));
  }

  // UTF-8 Header check
// UTF-8 header: insert into <head> if possible, otherwise prefix
if (useUtf8 && !/meta\s+charset=["']utf-8["']/i.test(rawStr)) {
  if (/<head[^>]*>/i.test(rawStr)) {
    rawStr = rawStr.replace(/<head[^>]*>/i, (m) => `${m}\n<meta charset="utf-8">`);
  } else {
    rawStr = `<meta charset="utf-8">\n` + rawStr;
  }
}

  let globalsBlock = "";
  document.querySelectorAll('.code-row').forEach(row => {
    let k = row.querySelector('.p-key').value.trim(); 
    let v = row.querySelector('.p-val').value;
    
    if(v.startsWith('__INJECT__:')) {
      const parts = v.split(':');
      globalsBlock += `${parts[1]} ${parts[2]} = ${parts.slice(3).join(':')};\n`;
    } else {
      let searchKey = k;
      if (!k.startsWith("%%") && !k.endsWith("%%")) searchKey = `%%${k}%%`;
      if(rawStr.includes(searchKey)) rawStr = rawStr.split(searchKey).join(v);
      else if (rawStr.includes(k)) rawStr = rawStr.split(k).join(v);
    }
  });

  if(globalsBlock) {
    const sTag = /<script[^>]*>/i;
    if(sTag.test(rawStr)) rawStr = rawStr.replace(sTag, (m) => `${m}\n//globals\n${globalsBlock}\n//endGlobals\n`);
    else rawStr = `<script>\n//globals\n${globalsBlock}\n//endGlobals\n<\/script>\n` + rawStr;
  }

// Return plain text if UTF8 selected
  if (useUtf8) {
  // NOT base64: percent-encoded UTF-8 data URI
  return `data:${mimeType};charset=utf-8,${encodeURIComponent(rawStr)}`;
} 
  
  // Default Base64 Return
  try { return `data:${mimeType};base64,${safeEncode(rawStr)}`; } 
  catch(e) { return rawStr; }
}

// --- LOGIC: Metadata ---
function buildMetadata(assetName, displayName) {
    let rawImage = document.getElementById('previewImgInput').value.trim() || "ipfs://placeholder";
    let finalImage = rawImage;
    let topMediaType = "image/png";

    if(rawImage.startsWith("data:")) {
        const typeMatch = rawImage.match(/data:([^;]+);/);
        if(typeMatch) topMediaType = typeMatch[1];
    }
    if(rawImage.length > 64) finalImage = rawImage.match(/.{1,64}/g);

    // 1. GET DISPLAY NAME (ID Pages First #1)
    // We pull this from the dataset we set in updateAssetPreview
    let finalDisplayName = document.body.dataset.currentDisplayName || displayName || "Asset";

    // 2. BASE METADATA
    const meta = {
        "name": finalDisplayName, // Top Level: ID Pages First #1
        "image": finalImage,
        "mediaType": topMediaType, 
        "files": []
    };

    // 3. FILE NAME LOGIC
    // We initialize this to empty. It will be populated ONLY if a "Name" trait exists.
    let fileObjName = "";

    document.querySelectorAll('.meta-row, .prop-row').forEach(row => {
         if (row.classList.contains('code-row')) {
             const syncCb = row.querySelector('.p-meta-sync');
             if (!syncCb || !syncCb.checked) return; 
         }
         if(row.querySelector('.do-not-add') && row.querySelector('.do-not-add').checked) return;
         
         let key = "";
         let val = "";
         
         const keyInput = row.querySelector('.p-key');
         const propInput = row.querySelector('.prop-val');

         if (keyInput) {
             key = keyInput.value;
             val = row.querySelector('.p-val')?.value || "";
         } else if (propInput) {
             key = propInput.dataset.prop;
             val = propInput.value;
         }
         
         if(!key) return;
         
         // CASE 1: The "Name" Property -> Goes to files[0].name
         // This captures "F5" from your defaultProps
         if (key.toLowerCase() === 'name') {
             fileObjName = val; 
             return; // Correct: Do NOT add "Name" to top-level traits
         }

         // CASE 2: Links
         if(key === 'Links') {
            meta["links"] = { "web": (Array.isArray(val) ? val.join('') : val) };
            return;
         }

         // CASE 3: Standard Traits
         if (val && val.length > 64) val = val.match(/.{1,64}/g);
         meta[key.toLowerCase()] = val;
    });
    
    const finalCode = prepareContent();
    const chunks = finalCode.match(/.{1,64}/g) || [];
    const enc = document.querySelector('input[name="encoding"]:checked')?.value || "base64";
    const useUtf8 = (enc === "utf8");
    
    // 4. PUSH FILE OBJECT
    // Uses fileObjName ("F5") if it was found. 
    // If NO "Name" trait was found, you might want a fallback (like assetName).
    // But per your request, we strictly use the captured variable.
    meta.files.push({ 
        "name": fileObjName || assetName, // Uses F5. Fallback to IDPagesFirst1 only if F5 is missing.
        "mediaType": useUtf8 ? "text/html;charset=utf-8" : "text/html", 
        "src": chunks 
    });
    
    return meta;
}


function isMaxInputError(msg) {
  const m = String(msg || "");
  return (
    /Maximum Input Count Exceeded/i.test(m) ||
    /too many inputs/i.test(m) ||
    /inputs exceeded/i.test(m) ||
    /UTxO count/i.test(m)
  );
}

/*
// --- LOGIC: Minting (Queued) ---
// Attempts to mint qtyToMint in ONE tx (your existing logic, slightly parameterized)
async function mintOnce(qtyToMint, statsBase, mintedSoFar) {
  const tx = new Transaction({ initiator: wallet });

  const collName   = document.getElementById('collectionName').value || "Eyez";
  const maxSupply  = parseInt(document.getElementById('totalAssets').value);

  // IMPORTANT: tie costPer to the costType radio, not just the input value
  const costType = document.querySelector('input[name="costType"]:checked')?.value || "free";
  const costPer  = (costType === "paid") ? (parseFloat(document.getElementById('mintCost').value) || 0) : 0;

  const rcv = document.getElementById('receiveAddr').value;
  const t   = document.querySelector('input[name="astype"]:checked').value;

  // Supply check for this batch (keeps sequential safe across multiple batches)
  if ((statsBase.count + mintedSoFar + qtyToMint) > maxSupply) {
    throw new Error("Not enough supply left!");
  }

  // --- INPUT SELECTION (your existing logic, but using qtyToMint) ---
  const payLovelace = BigInt(Math.ceil((costPer * qtyToMint) * 1_000_000));
 
  // Loop for Quantity (your existing loop, but using mintedSoFar)
  for (let i = 0; i < qtyToMint; i++) {
    let nextNum = statsBase.count + mintedSoFar + 1 + i;

    if (document.querySelector('input[name="dist"]:checked').value === 'random') {
      nextNum = Math.floor(Math.random() * maxSupply) + 1;
      // NOTE: still no duplicate prevention (same as your current comment)
    }

    let clean = collName.replace(/[^a-zA-Z0-9]/g, '');
    let rawName = `${clean}${nextNum}`;
    let dispName = `${collName} #${nextNum}`;

    if (!document.getElementById('useCollName').checked) {
      let manualInput = document.getElementById('assetNameInput').value;
      let cleanManual = manualInput.replace(/[^a-zA-Z0-9]/g, '');
      rawName = `${cleanManual}${nextNum}`;
      dispName = `${manualInput} #${nextNum}`;
    }

    const metadata = buildMetadata(rawName, dispName);

    const asset = {
      assetName: rawName,
      assetQuantity: "1",
      metadata: metadata,
      label: "721",
      recipient: currentUser.address
    };
  }

  // Payment for THIS batch (so splitting still pays the correct total overall)
  if (costPer > 0 && rcv) {
    tx.sendLovelace(rcv, payLovelace.toString());
  }

  const unsigned = await tx.build();
  const signed   = await wallet.signTx(unsigned);
  const hash     = await wallet.submitTx(signed);

  // Keep your existing effects
  log(`Tx Sent! Hash: ${hash}`, "success");
  incrementCollectionStats(qtyToMint);

  document.getElementById('successPreview').classList.remove('hidden');
  document.getElementById('mintedThumb').src = document.getElementById('visualPreview').src;

  return hash;
} */


// Wrapper: tries qty in one tx, halves on input-limit error, repeats until done
async function mintAsset() {
// USE GLOBAL studioWallet (Defined in Step 1)
    if(!studioWallet) return showToast("Wallet not ready", "error");
    
    const btn = document.getElementById('btnMint');
    btn.disabled = true;
    btn.textContent = "Minting...";

  // Mint preview behavior: hold collection thumb until user signs
mintPreviewState = "minting";
if (mintRevealTimer) { clearTimeout(mintRevealTimer); mintRevealTimer = null; }
showMintOverlay(false);
const mintPrev = document.getElementById('mintCollectionPreview');
if (mintPrev) mintPrev.src = getCollectionThumbForMint();

  try {
    const tx = new Transaction({ initiator: studioWallet });
    
    // Config
    const t = document.querySelector('input[name="astype"]:checked').value;
    const collName = document.getElementById('collectionName').value || "Collection";
    const maxSupply = parseInt(document.getElementById('totalAssets').value);
    const stats = getCollectionStats();
    
    let mintAmount = 1;
    if (t !== 'nft') {
        mintAmount = parseInt(document.getElementById('mintQty').value) || 1;
    }

    if (t === 'ft') {
        if ((stats.count + mintAmount) > maxSupply) throw new Error(`Exceeds Max Supply. Remaining: ${maxSupply - stats.count}`);
    } else {
        if ((stats.count + 1) > maxSupply) throw new Error("Collection Sold Out");
    }

    let rawName = document.getElementById('assetNameInput').value;
    let dispName = rawName;
    if (t !== 'ft') {
         const isRandom = document.querySelector('input[name="dist"]:checked').value === 'random';
         let nextNum = isRandom ? Math.floor(Math.random() * maxSupply) + 1 : stats.count + 1;
         
         let clean = collName.replace(/[^a-zA-Z0-9]/g, '');
         rawName = `${clean}${nextNum}`;
         dispName = `${collName} #${nextNum}`;
    }

    const metadata = buildMetadata(rawName, dispName);
    const mintPreview = buildMintPreviewFromMetadata(metadata);
    
    const costType = document.querySelector('input[name="costType"]:checked').value;
    if(costType === 'paid') {
       const cost = document.getElementById('mintCost').value;
       const rcv = document.getElementById('receiveAddr').value;
       if(!cost || !rcv) throw new Error("Missing Payment Info");
       tx.sendLovelace(rcv, (parseFloat(cost) * 1000000).toString());
    }

  // 1. RETRIEVE SAVED POLICY (Essential for Unique IDs)
    const activeKey = getActiveCollKey();
    const collData = loadCollectionState(activeKey);

    if (!collData || !collData.policy || !collData.policy.nativeScript) {
        throw new Error("Policy script missing. Cannot mint.");
    }

    // 2. USE THE SAVED SCRIPT (Instead of generating a new one)
    const forgingScript = ForgeScript.fromNativeScript(collData.policy.nativeScript);

    // 3. DEFINE ASSET (This stays the same)
    const asset = {
      assetName: rawName,
      assetQuantity: mintAmount.toString(),
      metadata: metadata,
      label: "721",
      recipient: currentUser.address
    };
    
    // 4. MINT
    tx.mintAsset(forgingScript, asset);
    const unsigned = await tx.build();
    const signed = await studioWallet.signTx(unsigned);
    // Once user signs, show playful waiting, then reveal purchased media
beginMintWaiting(mintPreview);
    // After signature: show playful wait animation, then reveal purchased media
const revealName = (t === 'ft') ? `Delivering ${mintAmount} tokens…` : `Wrapping ${dispName}…`;
showMintOverlay(true, revealName);

mintRevealTimer = setTimeout(() => {
  if (t === 'ft') {
    // FT has no media reveal; keep collection thumb and change message
    showMintOverlay(false);
  } else {
    const purchasedSrc = getPurchasedAssetPreviewSrc();
    const img = document.getElementById('mintCollectionPreview');
    if (img) img.src = purchasedSrc;
    showMintOverlay(false);
  }
  mintPreviewState = "postMint";
}, 5200);
    const hash = await studioWallet.submitTx(signed);
    
    log(`Tx Submitted: ${hash}`, "success");
    incrementCollectionStats((t === 'ft') ? mintAmount : 1, getActiveCollKey());
    
  } catch(e) {
      mintPreviewState = "idle";
    if (mintRevealTimer) { clearTimeout(mintRevealTimer); mintRevealTimer = null; }
    showMintOverlay(false);
    updateAssetPreview();
    // Revert mint preview if mint fails
    mintPreviewLocked = false;
    document.getElementById('mintWaitOverlay')?.classList.add('hidden');
    updateAssetPreview();
    log(e.message, "err");
  } finally {
    btn.disabled = false;
    btn.textContent = "Mint Asset";
    if (mintPreviewState === "idle") updateAssetPreview();
  }
}

// --- HELPERS ---

// --- NFT STUDIO STATE (Global) ---
let studioAssets = []; 
let studioSelectedAssetIndex = -1;
let studioActiveFilter = 'ALL';
let metaEditorState = { mode: 'collection', assetIndex: -1 };

// 1. Create New Asset
window.createNewAsset = function() {
    // A) Save current asset edits
    if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1) {
        if (typeof updateSelectedAssetFromUI === 'function') {
            updateSelectedAssetFromUI();
        }
    }

    // B) Generate Data
    const commonProps = (typeof readDefaultProps === 'function') ? readDefaultProps() : {};
    const nextNum = studioAssets.length + 1;
    const baseNameInput = document.getElementById('collectionName');
    const baseName = baseNameInput && baseNameInput.value ? baseNameInput.value : "Asset";

    const type = document.querySelector('input[name="astype"]:checked')?.value || "nft";
    const displaySuffix = (type === "ft") ? "" : (" #" + nextNum);
    const newAsset = {
        id: 'new_' + Date.now(),
        name: baseName.replace(/[^a-zA-Z0-9]/g, '') + nextNum,
        displayName: baseName + displaySuffix,
        mainContent: "",
        mainEncoding: "base64",
        coverImage: "",
        traits: { ...commonProps },
        codeRows: [],
        metaRows: []
    };

    // C) Push to Data Source
    studioAssets.push(newAsset);

    // D) Update UI Elements to match new count
    const newTotal = studioAssets.length;

    // 1. Input Field
    const maxInput = document.getElementById('totalAssets');
    if (maxInput) maxInput.value = newTotal;

    // 2. Max Pill
    const maxPill = document.getElementById('headerMaxDisplay');
    if (maxPill) maxPill.innerText = newTotal;

    // 3. Assets Ready Pill
    const countPill = document.getElementById('headerAssetCount');
    if (countPill) countPill.innerText = newTotal;

    // E) Select the new asset
    if (typeof selectStudioAsset === 'function') {
        selectStudioAsset(studioAssets.length - 1);
    } else {
        renderStudioPreview();
    }

    // --- CRITICAL: TRIGGER THE SAVE ---
    // This writes the new 'totalAssets' input value to the JSON files
    if (typeof saveActiveCollectionState === 'function') {
        saveActiveCollectionState();
    }
};

window.removeStudioAsset = function(index) {
    if (index < 0 || index >= studioAssets.length) return;

    if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
    }

    const targetAsset = studioAssets[index];
    const removeCompletely = isBlankDefaultOnlyAsset(targetAsset);

    if (removeCompletely) {
        studioAssets.splice(index, 1);
        normalizeStudioAssetNames();
        if (studioAssets.length === 0) {
            studioSelectedAssetIndex = -1;
        } else if (studioSelectedAssetIndex >= studioAssets.length) {
            studioSelectedAssetIndex = studioAssets.length - 1;
        } else if (studioSelectedAssetIndex > index) {
            studioSelectedAssetIndex -= 1;
        }
    } else {
        studioAssets[index] = createBlankStudioAssetAt(index);
        if (studioSelectedAssetIndex === index) {
            studioSelectedAssetIndex = -1;
        }
    }

    const newTotal = studioAssets.length;
    const maxInput = document.getElementById('totalAssets');
    if (maxInput) maxInput.value = newTotal;

    const maxPill = document.getElementById('headerMaxDisplay');
    if (maxPill) maxPill.innerText = newTotal;

    const countPill = document.getElementById('headerAssetCount');
    if (countPill) countPill.innerText = newTotal;

    renderStudioPreview();

    if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        selectStudioAsset(studioSelectedAssetIndex);
    }

    saveActiveCollectionState();
    updateAssetPreview();
};


// 2. Select Asset (Switching Logic)
window.selectStudioAsset = function(index) {
    if (index < 0 || index >= studioAssets.length) return;
    
    // A. SAVE PREVIOUS ASSET STATE
    // FIX: Only save if the previous index was valid. 
    // If studioSelectedAssetIndex is -1 (initial load), SKIP SAVING to prevent overwriting data with empty inputs.
    if (studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
    }
    
    // B. SWITCH INDEX
    studioSelectedAssetIndex = index;
    const asset = studioAssets[index];

    // C. POPULATE UI FROM NEW ASSET
    const nameInp = document.getElementById('assetNameInput');
    if (nameInp) nameInp.value = asset.name;

    // Sync displayName to body dataset so updateAssetPreview / buildMetadata stays correct
    if (asset.displayName) {
        document.body.dataset.currentDisplayName = asset.displayName;
    }

    const codeInp = document.getElementById('codeContent');
    // FIX: Fallback to empty string if undefined
    if (codeInp) codeInp.value = asset.mainContent || "";
    
    // Ensure we set the radio correctly based on saved state
    setRadio('encoding', asset.mainEncoding || 'base64');

    const prevInp = document.getElementById('previewImgInput');
    if (prevInp) prevInp.value = asset.coverImage || "";
    
    const vp = document.getElementById('visualPreview');
    if(vp) {
        const src = (typeof normalizeImgSrc === 'function') ? normalizeImgSrc(asset.coverImage) : (asset.coverImage || "");
        vp.src = src;
        vp.style.display = asset.coverImage ? 'block' : 'none';
    }

    // D. RESTORE KEYWORDS (Code Props)
// D. RESTORE KEYWORDS & METADATA
    if (typeof clearMetaCodeContainers === 'function') clearMetaCodeContainers();
    
    // 1. Rebuild Code Props (Keywords)
    if (typeof rebuildCodeRows === 'function') rebuildCodeRows(asset.codeRows || []);

    // 2. Rebuild Metadata Props (The Fix)
    // This merges the Collection's "Master List" with this specific Asset's values
    // so "Apply to All" rows don't disappear.
    if (typeof getMergedMetaRowsForAsset === 'function' && typeof rebuildMetaRows === 'function') {
        const rowsToRender = getMergedMetaRowsForAsset(asset);
        rebuildMetaRows(rowsToRender);
    }

    // E. RENDER GRID
    if (typeof renderStudioPreview === 'function') renderStudioPreview();
};

// 3. Sync Inputs to State
// Helper: Updates a specific asset object from the current DOM inputs
function updateAssetObjectFromUI(asset) {
    if (!asset) return;

    asset.name = document.getElementById('assetNameInput').value;
    asset.displayName = document.body.dataset.currentDisplayName || asset.displayName || asset.name;
    asset.mainContent = document.getElementById('codeContent').value;
    asset.mainEncoding = document.querySelector('input[name="encoding"]:checked')?.value || 'base64';
    asset.coverImage = document.getElementById('previewImgInput').value;

    // Persist Code Rows
    if (typeof readCodeRows === 'function') {
        asset.codeRows = readCodeRows();
    }

    // CRITICAL FIX: Persist Meta Rows so rebuilds can't wipe the row you just added.
    if (typeof readMetaRows === 'function') {
        asset.metaRows = readMetaRows();
    } else {
        asset.metaRows = asset.metaRows || [];
    }
}

// 3. Triggered by Input Listeners
window.updateSelectedAssetFromUI = function() {
    if (studioSelectedAssetIndex === -1) return;
    const asset = studioAssets[studioSelectedAssetIndex];
    updateAssetObjectFromUI(asset);
    renderStudioPreview(); 
};

function getStudioBaseName() {
    const baseNameInput = document.getElementById('collectionName');
    return (baseNameInput && baseNameInput.value) ? baseNameInput.value : 'Asset';
}

function createBlankStudioAssetAt(index) {
    const safeIndex = Math.max(0, Number(index) || 0);
    const nextNum = safeIndex + 1;
    const baseName = getStudioBaseName();
    const commonProps = (typeof readDefaultProps === 'function') ? readDefaultProps() : {};
    const type = document.querySelector('input[name="astype"]:checked')?.value || 'nft';
    const displaySuffix = (type === 'ft') ? '' : (' #' + nextNum);

    return {
        id: 'blank_' + Date.now() + '_' + safeIndex,
        name: baseName.replace(/[^a-zA-Z0-9]/g, '') + nextNum,
        displayName: baseName + displaySuffix,
        mainContent: '',
        mainEncoding: 'base64',
        coverImage: '',
        traits: { ...commonProps },
        codeRows: [],
        metaRows: []
    };
}

function normalizeStudioAssetNames() {
    const baseName = getStudioBaseName();
    const type = document.querySelector('input[name="astype"]:checked')?.value || 'nft';
    studioAssets.forEach((asset, idx) => {
        if (!asset) return;
        const nextNum = idx + 1;
        if (!asset.name || /^Asset\d+$/i.test(String(asset.name))) {
            asset.name = baseName.replace(/[^a-zA-Z0-9]/g, '') + nextNum;
        }
        if (!asset.displayName || /^Asset\s?#\d+$/i.test(String(asset.displayName))) {
            asset.displayName = type === 'ft' ? baseName : `${baseName} #${nextNum}`;
        }
    });
}

function isBlankDefaultOnlyAsset(asset) {
    if (!asset || typeof asset !== 'object') return false;
    const hasMain = !!String(asset.mainContent || '').trim();
    const hasCover = !!String(asset.coverImage || '').trim();
    const hasCodeRows = Array.isArray(asset.codeRows) && asset.codeRows.length > 0;
    const hasMetaRows = Array.isArray(asset.metaRows) && asset.metaRows.length > 0;

    if (hasMain || hasCover || hasCodeRows || hasMetaRows) return false;

    const defaults = (typeof readDefaultProps === 'function') ? readDefaultProps() : {};
    const defaultKeys = new Set(Object.keys(defaults).map(k => String(k).trim().toLowerCase()));
    const traits = (asset.traits && typeof asset.traits === 'object') ? asset.traits : {};

    return Object.keys(traits).every(k => defaultKeys.has(String(k).trim().toLowerCase()));
}

// 4. Render Grid & Dropdown
window.renderStudioPreview = function() {
    const grid = document.getElementById('studioAssetGrid');
    const countLabel = document.getElementById('studioAssetCountLabel');
    
    if (!grid) return;
    grid.innerHTML = '';

    if (studioAssets.length === 0) {
        grid.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #8899ac; border: 1px dashed rgba(255,255,255,0.1); border-radius: 8px;">No Assets. Click + New Asset.</div>`;
        if (countLabel) countLabel.textContent = "0 assets";
        return;
    }

    // 1. IDENTIFY GLOBAL KEYS (Source of Truth)
    // We lowercase them to ensure case-insensitive matching (e.g. "Color" vs "color")
    const globalKeys = new Set();

    // A. Add Standard Defaults (Artist, Description, etc.)
    if (typeof DEFAULT_PROPS !== 'undefined' && Array.isArray(DEFAULT_PROPS)) {
        DEFAULT_PROPS.forEach(p => globalKeys.add(p.toLowerCase().trim()));
    }


    // B. Add Custom Sidebar Props (The inputs you see in the left panel)
    const metaCont = document.getElementById('metaPropsContainer');
    if (metaCont) {
        metaCont.querySelectorAll('.p-key').forEach(k => {
            if(k.value.trim()) globalKeys.add(k.value.trim().toLowerCase());
        });
    }
    
    // --- FIX: ALSO CHECK MEMORY (Source of Truth) ---
    // This prevents the "Editable" bug if the sidebar row is momentarily missing/re-rendering.
    const activeKey = getActiveCollKey();
    if (activeKey) {
        const savedState = collStateMem.get(String(activeKey)) || {};
        const savedDefaults = savedState.defaultProps || {};
        Object.keys(savedDefaults).forEach(k => {
            if(k) globalKeys.add(k.trim().toLowerCase());
        });
    }

    const filterSelect = document.getElementById('studioPropertyFilterSelect');
    
    // --- POPULATE DROPDOWN ---
    if (filterSelect && studioSelectedAssetIndex > -1) {
        const currentAsset = studioAssets[studioSelectedAssetIndex];
        const derivedMeta = buildMetadata(currentAsset.name, currentAsset.displayName || currentAsset.name);
        
        const traits = {};
        const skipKeys = ['name', 'image', 'mediatype', 'files', 'src'];
        Object.entries(derivedMeta).forEach(([k, v]) => {
            if (!skipKeys.includes(k.toLowerCase()) && typeof v !== 'object') {
                traits[k] = String(v);
            }
        });

        const currentHash = JSON.stringify(traits);
        if (filterSelect.dataset.lastHash !== currentHash) {
            const currentSelection = filterSelect.value;
            let optionsHtml = '<option value="ALL">All properties</option>';
            Object.entries(traits).forEach(([k, v]) => {
                const valStr = `${k}|||${v}`;
                const label = `${k.charAt(0).toUpperCase() + k.slice(1)}: ${v}`;
                optionsHtml += `<option value="${valStr}">${label}</option>`;
            });
            filterSelect.innerHTML = optionsHtml;
            filterSelect.dataset.lastHash = currentHash;
            if (currentSelection !== 'ALL' && traits[currentSelection.split('|||')[0]] === currentSelection.split('|||')[1]) {
                filterSelect.value = currentSelection;
            } else {
                filterSelect.value = 'ALL';
            }
        }
    }

 // --- RENDER CARDS ---
    studioAssets.forEach((asset, idx) => {
        // (Filter logic)
        if (typeof studioActiveFilter !== 'undefined' && studioActiveFilter !== 'ALL') {
            const [fKey, fVal] = studioActiveFilter.split('|||');
            const common = (typeof readDefaultProps === 'function') ? readDefaultProps() : {}; 
            if (common[fKey] !== fVal && asset.traits[fKey] !== fVal) return;
        }

        const card = document.createElement('div');
        card.className = `asset-card ${idx === studioSelectedAssetIndex ? 'selected' : ''}`;
        
        // --- 1. MEDIA SPLIT ---
        const mediaSplit = document.createElement('div');
        mediaSplit.className = 'asset-media-split';

        // ZONE A: COVER
        const zoneCover = document.createElement('div');
        zoneCover.className = 'media-zone';
        zoneCover.style.position = "relative";
        if (asset.coverImage) {
            if(typeof buildMediaPreviewInto === 'function') {
                buildMediaPreviewInto({ image: asset.coverImage }, zoneCover, null, false, true);
            } else {
                 zoneCover.innerHTML = `<img src="${asset.coverImage}" style="width:100%;height:100%;object-fit:cover;">`;
            }
        } else {
            zoneCover.innerHTML = `<span class="zone-empty-text">No Cover<br><i class="fas fa-image"></i></span>`;
        }
        const labelCover = document.createElement('span');
        labelCover.className = 'zone-label';
        labelCover.textContent = 'Cover';
        zoneCover.appendChild(labelCover);

        // ZONE B: MAIN FILE
        const zoneFile = document.createElement('div');
        zoneFile.className = 'media-zone';
        zoneFile.style.position = "relative";

        if (asset.mainContent) {
            const isHtml = (asset.mainContent.includes('text/html') || asset.mainContent.startsWith('data:text/html') || asset.mainContent.includes('<html'));
            let previewSrc = asset.mainContent;
            
            if (idx === studioSelectedAssetIndex && typeof prepareContent === 'function') {
                 previewSrc = prepareContent(); 
            }

            if(typeof buildMediaPreviewInto === 'function') {
                buildMediaPreviewInto({ 
                    files: [{ src: previewSrc, mediaType: isHtml ? 'text/html' : '' }] 
                }, zoneFile, null, false, true);
            } else {
                zoneFile.textContent = "File Loaded";
            }

            if (isHtml) {
                const wrapper = zoneFile.querySelector('.html-thumb-wrapper') || zoneFile.querySelector('iframe');
                if (wrapper) {
                    wrapper.style.opacity = '0';
                    wrapper.style.transition = 'opacity 0.2s';
                    wrapper.style.pointerEvents = 'none';
                    
                    const icon = document.createElement('div');
                    icon.style.cssText = "position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:2rem; color:#fff; transition:opacity 0.2s; z-index:4;";
                    icon.innerHTML = `<i class="fas fa-code"></i>`;
                    
                    zoneFile.onmouseenter = () => {
                        wrapper.style.opacity = '1';
                        wrapper.style.pointerEvents = 'auto';
                        icon.style.opacity = '0';
                    };
                    zoneFile.onmouseleave = () => {
                        wrapper.style.opacity = '0';
                        wrapper.style.pointerEvents = 'none';
                        icon.style.opacity = '1';
                    };
                    zoneFile.appendChild(icon);
                }
            }
        } else {
            zoneFile.innerHTML = `<span class="zone-empty-text">No File<br><i class="fas fa-file-upload"></i></span>`;
        }
        
        const labelMain = document.createElement('span');
        labelMain.className = 'zone-label';
        labelMain.textContent = 'Main File';
        zoneFile.appendChild(labelMain);

        if(typeof setupCardDropZone === 'function') {
            setupCardDropZone(zoneFile, idx, 'main');
            setupCardDropZone(zoneCover, idx, 'cover');
        }

        mediaSplit.appendChild(zoneCover);
        mediaSplit.appendChild(zoneFile);
        card.appendChild(mediaSplit);
        // ---------------------------------------------

        // --- 2. NAME ---
        const nameDiv = document.createElement('div');
        nameDiv.className = 'asset-name';
        const base = document.getElementById('collectionName').value || "Asset";
        nameDiv.textContent = asset.displayName || asset.name || `${base} #${idx+1}`;
        card.appendChild(nameDiv);

        // --- 3. TRAITS (LOGIC FIXED) ---
        const traitsBox = document.createElement('div');
        traitsBox.className = 'asset-traits';
        
        const skip = ['name','image','mediatype','files','src','links'];
        const allTraits = asset.traits || {};
        
        Object.entries(allTraits).forEach(([k, v]) => {
            if (skip.includes(k.toLowerCase())) return;

            // Check if this key exists in the Global Set
            const isGlobal = globalKeys.has(k.toLowerCase());
            
            const row = document.createElement('div');
            row.className = 'detail-meta-row';
            row.style.display = "flex";
            row.style.alignItems = "center";
            row.style.gap = "5px";

            // A. The Key
            const kSpan = document.createElement('span');
            kSpan.className = 'trait-k';
            kSpan.textContent = k;
            
            // B. The Value
            const vInput = document.createElement('input');
            vInput.type = 'text';
            vInput.value = v;
            
            // LOGIC: If Global -> Read Only. If Local -> Editable.
            if (isGlobal) {
                vInput.disabled = true; // Cannot edit global values here
                vInput.style.cssText = "flex:1; background:transparent; border:none; color:var(--text-light); font-size:0.85rem; padding:2px; font-style:italic;";
                vInput.title = "Global Property (Managed in sidebar)";
            } else {
                vInput.disabled = false; // Local is editable
                vInput.placeholder = "Value...";
                vInput.style.cssText = "flex:1; background:rgba(0,0,0,0.2); border:none; border-bottom:1px solid rgba(255,255,255,0.1); color:var(--text-main); font-size:0.85rem; padding:2px;";
                
                // Save on Change (Only for Locals)
                vInput.onchange = () => {
                    asset.traits[k] = vInput.value;
                    saveActiveCollectionState();
                    if (idx === studioSelectedAssetIndex) updateAssetObjectFromUI(asset);
                };
            }

            row.appendChild(kSpan);
            row.appendChild(vInput);

            // C. Delete Button (ONLY FOR LOCALS)
            if (!isGlobal) {
                const delBtn = document.createElement('button');
                delBtn.innerHTML = "&times;";
                delBtn.style.cssText = "background:none; border:none; color:var(--error); font-size:1.1rem; cursor:pointer; padding:0 5px;";
                delBtn.title = "Remove this local property";
                
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    delete asset.traits[k];
                    saveActiveCollectionState();
                    updateAssetPreview();
                };
                row.appendChild(delBtn);
            }

            traitsBox.appendChild(row);
        });

        if (traitsBox.hasChildNodes()) card.appendChild(traitsBox);

        // --- 4. ACTION BUTTONS ---
        const addPropBtn = document.createElement('button');
        addPropBtn.className = "secondary small-btn";
        addPropBtn.style.cssText = "margin: 8px 8px 0 8px; width: calc(100% - 16px); display:flex; justify-content:center; gap:5px;";
        addPropBtn.innerHTML = `<i class="fas fa-plus"></i> Property`;
        addPropBtn.onclick = (e) => {
            e.stopPropagation();
            openSingleAssetPropModal(idx);
        };
        card.appendChild(addPropBtn);

        const assetJsonBtn = document.createElement('button');
        assetJsonBtn.className = "secondary small-btn";
        assetJsonBtn.style.cssText = "margin: 6px 8px 0 8px; width: calc(100% - 16px); display:flex; justify-content:center; gap:5px;";
        assetJsonBtn.innerHTML = `<i class="fas fa-code"></i> JSON`;
        assetJsonBtn.onclick = (e) => {
            e.stopPropagation();
            openAssetJsonEditor(idx);
        };
        card.appendChild(assetJsonBtn);

        const removeAssetBtn = document.createElement('button');
        removeAssetBtn.className = "secondary small-btn";
        removeAssetBtn.style.cssText = "margin: 6px 8px 8px 8px; width: calc(100% - 16px); display:flex; justify-content:center; gap:5px; color:#ff7d7d; border-color:rgba(255,125,125,0.45);";
        removeAssetBtn.innerHTML = `<i class="fas fa-minus"></i> Asset`;
        removeAssetBtn.onclick = (e) => {
            e.stopPropagation();
            removeStudioAsset(idx);
        };
        card.appendChild(removeAssetBtn);

        // Card Click Selection
        card.onclick = (e) => {
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            selectStudioAsset(idx);
        };

        grid.appendChild(card);
    });

    if (countLabel) countLabel.textContent = `${studioAssets.length} Assets`;
};


/**
 * Synchronizes the Max Supply input with the studioAssets array
 * and updates the preview grid.
 */
window.syncMaxSupply = function(inputValue) {
    // 1. Sanitize
    let targetCount = parseInt(inputValue, 10);
    if (isNaN(targetCount) || targetCount < 1) targetCount = 1;

    // 2. Update Visuals
    const headerDisplay = document.getElementById('headerMaxDisplay');
    const maxDisplay = document.getElementById('maxSupplyDisplay'); // Update the tracker in Mint Station too
    if (headerDisplay) headerDisplay.innerText = targetCount;
    if (maxDisplay) maxDisplay.innerText = targetCount;

    // 3. Safety Check
    if (typeof studioAssets === 'undefined') window.studioAssets = [];

    // 4. Save state of currently selected asset before modifying array
    if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        if (typeof updateSelectedAssetFromUI === 'function') updateSelectedAssetFromUI();
    }

    const currentCount = studioAssets.length;

    // 5. Expand or Contract
    if (targetCount > currentCount) {
        const diff = targetCount - currentCount;
        const baseName = document.getElementById('collectionName').value || "Asset";
        const commonProps = (typeof readDefaultProps === 'function') ? readDefaultProps() : {};

        for (let i = 0; i < diff; i++) {
            const nextNum = studioAssets.length + 1; 
            const newAsset = {
                id: 'gen_' + Date.now() + '_' + i,
                name: baseName.replace(/[^a-zA-Z0-9 ]/g, '') + " #" + nextNum,
                mainContent: "",
                mainEncoding: "base64",
                coverImage: "",
                traits: { ...commonProps }, // Important: Carry over defaults
                codeRows: [],
                metaRows: []
            };
            studioAssets.push(newAsset);
        }
    } else if (targetCount < currentCount) {
        studioAssets.length = targetCount; // Truncate
        if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex >= targetCount) {
            studioSelectedAssetIndex = -1; 
        }
    }

    // 6. Render & Save
    if (typeof renderStudioPreview === 'function') renderStudioPreview();
    
    const headerAssetCount = document.getElementById('headerAssetCount');
    if (headerAssetCount) headerAssetCount.innerText = studioAssets.length;

    if (typeof saveActiveCollectionState === 'function') {
        saveActiveCollectionState();
    }
};

// 5. Card Drop Logic
window.setupCardDropZone = function(el, assetIndex, type) {
    el.addEventListener('dragover', (e) => { e.preventDefault(); el.classList.add('drag-active'); });
    el.addEventListener('dragleave', (e) => { e.preventDefault(); el.classList.remove('drag-active'); });
    el.addEventListener('drop', (e) => {
        e.preventDefault();
        el.classList.remove('drag-active');
        const f = e.dataTransfer.files[0];
        if (!f) return;

        selectStudioAsset(assetIndex);

        if (type === 'cover') {
            if (!f.type.startsWith('image/')) return alert("Cover must be an image");
            const reader = new FileReader();
            reader.onload = (ev) => {
                document.getElementById('previewImgInput').value = ev.target.result;
                updateSelectedAssetFromUI();
            };
            reader.readAsDataURL(f);
        } else {
            // Main File Logic
            if (f.type.includes('html') || f.name.endsWith('.html')) {
                const useBase64 = confirm("Encode HTML as Base64? \nCancel = UTF-8 (Plain Text)");
                const enc = useBase64 ? 'base64' : 'utf8';
                setRadio('encoding', enc);
                
                const reader = new FileReader();
                reader.onload = (ev) => {
                    document.getElementById('codeContent').value = ev.target.result;
                    updateSelectedAssetFromUI();
                };
                
                // CHANGE: If Base64 requested, read as DataURL to ensure correct formatting in editor
                if (useBase64) {
                    reader.readAsDataURL(f); 
                } else {
                    reader.readAsText(f);
                }
            } else {
                // Standard Binary (Always Base64)
                const reader = new FileReader();
                reader.onload = (ev) => {
                    document.getElementById('codeContent').value = ev.target.result;
                    setRadio('encoding', 'base64');
                    updateSelectedAssetFromUI();
                };
                reader.readAsDataURL(f);
            }
        }
    });
};

// Helper: Scrapes both Standard and Custom inputs into one object
function getLiveDefaultProps() {
    const liveDefaults = {};
    
    // 1. Scrape Standard Defaults (e.g., Artist, Description)
    const defContainer = document.getElementById('defaultProps');
    if (defContainer) {
        defContainer.querySelectorAll('.prop-val').forEach(input => {
            if (input.dataset.prop) {
                liveDefaults[input.dataset.prop] = input.value;
            }
        });
    }

    // 2. Scrape Custom "Global" Defaults (The ones added via +New Property)
    // NOTE: We target the container where addProp('meta') puts them
    const metaContainer = document.getElementById('metaPropsContainer');
    if (metaContainer) {
        metaContainer.querySelectorAll('.prop-row').forEach(row => {
            const keyInput = row.querySelector('.p-key');
            const valInput = row.querySelector('.p-val');
            
            // Only save if we have a valid key
            if (keyInput && valInput) {
                const k = keyInput.value.trim();
                if (k) liveDefaults[k] = valInput.value;
            }
        });
    }

    return liveDefaults;
}

function renderCollectionSettings(collKey) {
           // 1. Get Saved Data for THIS collection
        const state = collStateMem.get(String(collKey)) || {};
        
        // FIX: If this is a FRESH collection ('new'), ignore any stale memory
        // and force a blank slate for custom props.
        let savedProps = state.defaultProps || {};
        if (String(collKey) === 'new' && !state.id) {
            savedProps = {}; 
        }

    // 2. Identify Containers
    const defContainer = document.getElementById('defaultProps');
    const metaContainer = document.getElementById('metaPropsContainer');

    // 3. WIPE CLEAN (Crucial: Prevents data bleeding between tabs)
    if (defContainer) defContainer.innerHTML = "";
    if (metaContainer) metaContainer.innerHTML = "";

    // 4. Re-Render Standard Props (Artist, Description, etc.)
    if (defContainer) {
        DEFAULT_PROPS.forEach(p => {
            const val = savedProps[p] || ""; 
            const div = document.createElement('div');
            div.className = "prop-row";
            div.innerHTML = `
                <div style="color:var(--text-light)"><i class="fas fa-tag"></i></div>
                <div style="font-size:0.9rem; color:var(--text-light)">${p}</div>
                <input type="text" class="prop-val" data-prop="${p}" value="${val}" placeholder="Value for ${p}...">
                <button class="danger icon-btn" onclick="this.closest('.prop-row').remove(); window.triggerAutosave && window.triggerAutosave();">×</button>
            `;
            defContainer.appendChild(div);
        });
    }

    // 5. Re-Render Custom/Global Props
    // We filter out the Standard props so we don't duplicate them
    if (metaContainer) {
        Object.keys(savedProps).forEach(key => {
            if (DEFAULT_PROPS.includes(key)) return; // Skip standard keys

            const val = savedProps[key];
            const div = document.createElement('div');
            div.className = "prop-row meta-row"; // Match class from addProp
            
            // Re-construct the 'addProp' HTML structure
            div.innerHTML = `
                <div style="color:var(--text-light)"><i class="fas fa-tag"></i></div>
                <input type="text" class="p-key" value="${key}" placeholder="Global Key">
                <div class="col">
                    <input type="text" class="p-val" value="${val}" placeholder="Global Value">
                </div>
                <button class="danger icon-btn" onclick="this.closest('.prop-row').remove(); window.triggerAutosave && window.triggerAutosave();">×</button>
            `;
            metaContainer.appendChild(div);
        });
    }
}


function getMergedMetaRowsForAsset(asset) {
    // 1. Get the "Master List" of rows from the Collection Memory
    // This ensures we don't lose the structural rows just because this specific asset is empty
    const k = getActiveCollKey();
    const savedState = (typeof collStateMem !== 'undefined' ? collStateMem.get(String(k)) : null) || {};
    const masterRows = savedState.metaRows || [];

    // 2. Map through the Master List (Schema)
    // We want to keep the rows, but show THIS asset's values
    return masterRows.map(row => {
        // Does the asset have a specific value for this key?
        const assetVal = (asset && asset.traits) ? asset.traits[row.key] : undefined;
        
        return {
            key: row.key,
            // Logic: If asset has a value, show it. 
            // If not, and it's an "Apply to All" row, show the default. 
            // Otherwise, show empty string (but keep the row!).
            val: assetVal !== undefined ? assetVal : (row.all ? row.val : ''),
            all: row.all // Preserve the checkbox state
        };
    });
}

let pendingAssetIndex = -1;

// Opens the modal
window.openSingleAssetPropModal = function(idx) {
    if(idx < 0 || idx >= studioAssets.length) return;
    pendingAssetIndex = idx;
    
    const asset = studioAssets[idx];
    document.getElementById('singlePropAssetID').textContent = `#${idx + 1} (${asset.name})`;
    document.getElementById('singlePropKey').value = "";
    document.getElementById('singlePropVal').value = "";
    document.getElementById('singlePropModal').classList.add('open');
    document.getElementById('singlePropKey').focus();
};

// Saves the data from the modal
window.saveSingleAssetProp = function() {
    if (pendingAssetIndex < 0) return;
    
    const key = document.getElementById('singlePropKey').value.trim();
    const val = document.getElementById('singlePropVal').value.trim();
    
    if (!key) {
        alert("Please enter a Property Name");
        return;
    }
    
    // 1. Update Memory
    if (!studioAssets[pendingAssetIndex].traits) studioAssets[pendingAssetIndex].traits = {};
    studioAssets[pendingAssetIndex].traits[key] = val;
    
    // 2. Refresh Main UI if this asset is currently active in the sidebar
    if (studioSelectedAssetIndex === pendingAssetIndex) {
        updateAssetObjectFromUI(studioAssets[pendingAssetIndex]);
    }

    // 3. Save to JSON and Refresh Grid
    saveActiveCollectionState(); 
    updateAssetPreview();
    
    // 4. Close Modal
    document.getElementById('singlePropModal').classList.remove('open');
};


function updateAssetPreview() {
    const collRaw = document.getElementById('collectionName').value.trim();
    const collBase = collRaw || ""; 
    
    document.getElementById('displayTitle').textContent = collRaw || "Collection Title";

    const useColl = document.getElementById('useCollName').checked;
    const assetInp = document.getElementById('assetNameInput');

    // 1. CALCULATE INDEX SUFFIX
    const idx = (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1) 
                ? (studioSelectedAssetIndex + 1) 
                : 1;
    const suffix = idx.toString();

    // 2. GENERATE STRICT ASSET KEY (IDPagesFirst1)
    // This fixes "assetNameInput" to be the sanitized ID you requested
    let strictBase = collBase.replace(/[^a-zA-Z0-9]/g, '');
    let assetKey = strictBase + suffix;

    // 3. GENERATE DISPLAY NAME (ID Pages First #1)
    // This is for the Top-Level "name" property in metadata
    const type = document.querySelector('input[name="astype"]:checked')?.value || "nft";
    let displaySuffix = (type === "ft") ? "" : (" #" + suffix);
    let displayName = collRaw + displaySuffix;

    // 4. UPDATE UI INPUT
    if (useColl) {
        assetInp.disabled = true;
        assetInp.value = assetKey; // NOW SET TO: IDPagesFirst1
    } else {
        assetInp.disabled = false;
        // In manual mode, we respect user input, but default to key if empty
        if (!assetInp.value.trim()) assetInp.value = assetKey;
    }

    // Update Labels & Store Data for Builder
    document.getElementById('assetNamePreview').textContent = `Display Name: ${displayName}`;
    document.body.dataset.currentDisplayName = displayName;

    // Persist displayName directly on the current asset object
    if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        studioAssets[studioSelectedAssetIndex].displayName = displayName;
    }

    const useAsset = document.getElementById('useAssetThumbInMint')?.checked;
    if (!mintPreviewLocked) {
        if (useAsset && document.getElementById('visualPreview')?.src) {
            const img = document.getElementById('mintCollectionPreview');
            if (img) {
                img.classList.remove('hidden');
                img.src = document.getElementById('visualPreview').src;
            }
        } else {
            if(typeof setMintPreviewToCollectionThumb === 'function') setMintPreviewToCollectionThumb();
        }
    }
    
// --- FORCE DATA SYNC BEFORE RENDER ---
    
    // 1. Update the Currently Selected Asset from the UI inputs immediately
    // This ensures the property you just typed appears on the selected card
    if (typeof studioSelectedAssetIndex !== 'undefined' && studioSelectedAssetIndex > -1 && studioAssets[studioSelectedAssetIndex]) {
        if (typeof updateAssetObjectFromUI === 'function') {
             updateAssetObjectFromUI(studioAssets[studioSelectedAssetIndex]);
        }
    }

    // 2. Sync "Apply to All" properties to the rest of the collection
    // This ensures the checkbox logic propagates to the other cards immediately
    if(typeof syncDefaultPropsToAllAssets === 'function') syncDefaultPropsToAllAssets();
    
    // 3. Render the grid with the fresh data
    if(typeof renderStudioPreview === 'function') renderStudioPreview();
}


function updatePriceDisplay() {
    const cost = parseFloat(document.getElementById('mintCost').value) || 0;
    const qty = parseInt(document.getElementById('mintQty').value) || 1;
    document.getElementById('totalPriceDisplay').textContent = (cost * qty).toFixed(1) + " ₳";
}


function setupAssetPreviewDropZone() {
  const zone = document.getElementById('previewDropZone');
  if (!zone) return;

  const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };

  zone.addEventListener('dragenter', (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragover',  (e) => { prevent(e); zone.classList.add('drag-active'); });
  zone.addEventListener('dragleave', (e) => { prevent(e); zone.classList.remove('drag-active'); });
  zone.addEventListener('drop', (e) => {
    prevent(e);
    zone.classList.remove('drag-active');
    const f = e.dataTransfer?.files?.[0];
    if (!f) return;

    // reuse your existing input path
    const input = document.getElementById('previewFileInput');
    if (input) {
      const dt = new DataTransfer();
      dt.items.add(f);
      input.files = dt.files;
      input.dispatchEvent(new Event('change'));
    }
  });
}


function getActiveCollectionPanel() {
  return document.querySelector('.collection-panel.active');
}

function getActiveCollectionKey() {
  return getActiveCollectionPanel()?.dataset.coll || 'new';
}

window.switchCollectionTab = async function(collKey) {
  const key = String(collKey || 'new');

  // 1. Activate UI Buttons
  document.querySelectorAll('#collectionTabs .tab-btn[data-coll]').forEach(b => {
    b.classList.toggle('active', b.dataset.coll === key);
  });

  // 2. Activate Panel
  document.querySelectorAll('.collection-panel').forEach(p => {
    p.classList.toggle('active', p.dataset.coll === key);
  });

  setActiveCollKey(key);

  // 3. --- NEW: Render the Settings for THIS collection ---
  // This clears the previous tab's inputs and loads the new ones
  renderCollectionSettings(key);

  // 4. Refresh stats/assets
  await loadCollectionStats();
};


window.restoreCollectionTab = async function() {
  const saved = getActiveCollKey() || 'new';
  const exists = document.querySelector(`.collection-panel[data-coll="${saved}"]`)
             && document.querySelector(`#collectionTabs .tab-btn[data-coll="${saved}"]`);
  await window.switchCollectionTab(exists ? saved : 'new');
};


function handleTypeChange() {
  const typeEl = document.querySelector('input[name="astype"]:checked');
  const t = typeEl ? typeEl.value : "nft";

  const ed = document.getElementById('editionConfig');
  if (ed) ed.style.display = (t === 'edition') ? 'block' : 'none';

  const ft = document.getElementById('ftConfig');
  if (ft) ft.style.display = (t === 'ft') ? 'block' : 'none';

  const qtyRow = document.getElementById('qtyRow');
  if (qtyRow) qtyRow.style.display = 'flex'; // always show qty selector

  const tracker = document.getElementById('trackerLabel');
  if (tracker) tracker.textContent = (t === 'ft') ? "Tokens Minted:" : "Assets Sold:";

  updateAssetPreview();
}

let lastCodeRaw = "";
let lastCodeMime = "text/html";

function b64FromUtf8(str) {
  const bytes = new TextEncoder().encode(str);
  let bin = "";
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

function extractRawFromCodeTextarea() {
  const txt = document.getElementById('codeContent').value.trim();
  let mime = "text/html";
  let raw = txt;

  if (txt.startsWith("data:")) {
    const parts = txt.split(',');
    const head = parts[0] || "";
    const body = parts.slice(1).join(',') || "";
    if (head.includes(':') && head.includes(';')) mime = head.split(':')[1].split(';')[0];

    if (/;base64/i.test(head)) {
      try {
        const bin = atob(body.replace(/\s/g,''));
        const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
        raw = new TextDecoder().decode(bytes);
      } catch(e) {
        raw = "";
      }
    } else {
      // utf8 data uri
      try { raw = decodeURIComponent(body); } catch(e) { raw = body; }
    }
    return { raw, mime };
  }

  // raw base64 pasted
  if (!txt.includes("<") && /^[A-Za-z0-9+/=]+$/.test(txt.replace(/\s/g,''))) {
    try {
      const bin = atob(txt.replace(/\s/g,''));
      const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
      raw = new TextDecoder().decode(bytes);
      return { raw, mime };
    } catch(e) {}
  }

  return { raw: txt, mime };
}

function syncCodeTextareaToEncoding() {
  const enc = document.querySelector('input[name="encoding"]:checked')?.value || "base64";
  const ta = document.getElementById('codeContent');

  if (!lastCodeRaw) {
    const ex = extractRawFromCodeTextarea();
    lastCodeRaw = ex.raw;
    lastCodeMime = ex.mime || "text/html";
  }

  if (enc === "utf8") {
    ta.value = lastCodeRaw; // show plain text
  } else {
    ta.value = `data:${lastCodeMime};base64,${b64FromUtf8(lastCodeRaw)}`;
  }
}

function loadFile(e, targetId) {
  const file = e.target.files[0];
  if(!file) return;

  // Special handling for codeContent: reflect encoding radio
  if (targetId === 'codeContent') {
    lastCodeMime = file.type || "text/html";
    const r = new FileReader();
    r.onload = (ev) => {
      lastCodeRaw = ev.target.result || "";
      syncCodeTextareaToEncoding();
    };
    r.readAsText(file);
    return;
  }

  // Default behavior for other inputs (like previewImgInput)
  const r = new FileReader();
  r.onload = (ev) => document.getElementById(targetId).value = ev.target.result;
  r.readAsDataURL(file);
}

function log(msg, type) {
  const d = document.createElement('div');
  d.textContent = `> ${msg}`;
  d.style.color = type==='err'?'var(--error)':'var(--success)';
  document.getElementById('txLog').prepend(d);
}

// --- REAL TRACKING via PHP ---
async function getCollectionStats(collKey) {
  try {
    const k = String(collKey || getActiveCollKey() || 'new');
    const req = await fetch(`tracker.php?action=get&coll=${encodeURIComponent(k)}`);
    return await req.json();
  } catch {
    return { count: 0, countByCollection: { [String(collKey||'new')]: 0 } };
  }
}

async function incrementCollectionStats(n, collKey) {
  try {
    const k = String(collKey || getActiveCollKey() || 'new');
    await fetch(`tracker.php?action=increment&coll=${encodeURIComponent(k)}&amount=${encodeURIComponent(n)}`);
    await loadCollectionStats();
  } catch {}
}

async function loadCollectionStats() {
  const k = String(getActiveCollKey() || 'new');
  const stats = await getCollectionStats(k);
  const per = stats?.countByCollection?.[k] ?? 0;
  document.getElementById('soldCount').textContent = per;
}

window.toggleInput = (cb) => {
  const row = cb.closest('.prop-row');
  const inp = row.querySelector('.prop-val');
  inp.disabled = cb.checked;
  row.style.opacity = cb.checked ? "0.6" : "1";
};

window.addProp = function(type) {
    const container = document.getElementById(`${type}PropsContainer`);
    const div = document.createElement('div');
    div.className = `prop-row ${type}-row`;

    let inner = `
        <div style="color:var(--text-light)"><i class="fas fa-tag"></i></div>
        <input type="text" class="p-key" placeholder="${type === 'code' ? 'Keyword' : 'Global Key'}">
        <div class="col">
            <input type="text" class="p-val" placeholder="${type === 'code' ? 'Value' : 'Global Value'}">
            ${type === 'code' ? `
            <div class="row" style="font-size:0.8rem; margin-top:-5px">
                <label class="check-wrap"><input type="checkbox" class="p-presets" onchange="togglePresets(this)"> Presets</label>
                <label class="check-wrap"><input type="checkbox" class="p-meta-sync"> Use in Meta</label>
            </div>
            <div class="preset-btn-group">
                <button class="icon-btn" onclick="openPresetModal(this, 'colors')">Colors</button>
            </div>
            ` : ''}
        </div>
        <button class="danger icon-btn" onclick="this.closest('.prop-row').remove(); updateAssetPreview();">×</button>
    `;
    div.innerHTML = inner;
    container.appendChild(div);
    
    // Trigger update immediately so it syncs
    if(type !== 'code') updateAssetPreview(); 
}

// --- LOGIC: Presets (Colors) ---
window.togglePresets = (cb) => {
  const group = cb.closest('.col').querySelector('.preset-btn-group');
  if(cb.checked) group.classList.add('show'); else group.classList.remove('show');
};

window.openPresetModal = (btn, type) => {
  pendingPreset = { row: btn.closest('.prop-row'), type };
  if(type === 'colors') {
    document.getElementById('colorModal').classList.add('open');
    showColorOpt('hex'); 
  }
};

window.showColorOpt = (opt) => {
  document.getElementById('opt-hex').style.display = (opt === 'hex') ? 'block' : 'none';
};

window.updateColorUI = () => {};

window.toggleVarInput = () => {
  const useVar = document.getElementById('useMyVar').checked;
  document.getElementById('varInputArea').style.display = useVar ? 'block' : 'none';
  if(useVar) {
     document.getElementById('useProp').checked = false;
     document.getElementById('propSelectArea').style.display = 'none';
  }
};

window.togglePropSelect = () => {
  const useProp = document.getElementById('useProp').checked;
  document.getElementById('propSelectArea').style.display = useProp ? 'block' : 'none';
  if(useProp) {
    document.getElementById('useMyVar').checked = false;
    document.getElementById('varInputArea').style.display = 'none';
    const sel = document.getElementById('targetPropSelect');
    sel.innerHTML = "";
    document.querySelectorAll('.code-row').forEach(row => {
       const key = row.querySelector('.p-key').value;
       if(key) {
         const opt = document.createElement('option');
         opt.value = key; opt.text = key;
         sel.appendChild(opt);
       }
    });
  }
};

window.applyColorPreset = () => {
  const hexType = document.querySelector('input[name="hexType"]:checked').value;
  let codeSnippet = "";
  const rndHexFunc = `()=>'#'+Math.random().toString(16).slice(2,8).padEnd(6,'0')`;
  
  if(hexType === 'single') codeSnippet = "#" + Math.random().toString(16).slice(2,8).padEnd(6,'0');
  else if (hexType === 'random') codeSnippet = rndHexFunc;
  else if (hexType === 'gradient') codeSnippet = `()=>'radial-gradient(circle, #'+Math.random().toString(16).slice(2,8)+' 0%, #'+Math.random().toString(16).slice(2,8)+' 100%)'`;

  const useVar = document.getElementById('useMyVar').checked;
  
  if (useVar) {
    const vType = document.getElementById('varType').value;
    const vName = document.getElementById('varName').value;
    if(!vName) return alert("Enter variable name");
    pendingPreset.row.querySelector('.p-val').value = `__INJECT__:${vType}:${vName}:${codeSnippet}`;
  } else {
    pendingPreset.row.querySelector('.p-val').value = codeSnippet;
  }
  closeModal('colorModal');
};

// Run on initial load
document.addEventListener('DOMContentLoaded', () => {
    initializeStudioSections();
});

function initializeStudioSections() {
    // 1. Identify all collapsible bodies
    const sections = [
        'policySection', 
        'collectionDetailsSection', 
        'buildBody', 
        'assetPreviewBody', 
        'paymentInfoBody', 
        'buyerUIBody'
    ];

    sections.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;

        // 2. Check session storage for persistence
        const isOpen = sessionStorage.getItem(`studio_section_${id}`) === 'true';

        if (isOpen) {
            // Restore expanded state
            if (el.classList.contains('section')) {
                el.classList.add('open');
            } else {
                el.style.display = 'block';
            }
        } else {
            // Force collapse by default on fresh session
            if (el.classList.contains('section')) {
                el.classList.remove('open');
            } else {
                el.style.display = 'none';
            }
        }
    });
}

/**
 * Unified toggle function that tracks state in sessionStorage
 * @param {string} elementId - The ID of the body element to toggle
 */
function toggleStudioSection(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return;

    let isNowOpen = false;

    // Handle .section elements (Policy/Collection Details)
    if (el.classList.contains('section')) {
        el.classList.toggle('open');
        isNowOpen = el.classList.contains('open');
    } 
    // Handle standard .cardBody elements (Build/Payment/Mint)
    else {
        const current = el.style.display;
        isNowOpen = current === 'none';
        el.style.display = isNowOpen ? 'block' : 'none';
    }

    // Save state for the duration of the session
    sessionStorage.setItem(`studio_section_${elementId}`, isNowOpen);
}

window.addEventListener('DOMContentLoaded', async () => {
  const auto = await tryAutoReconnectWallet();
  if (!auto) return;
  await onStudioWalletReady(auto.walletKey);
});
        

async function uploadBanner(e) {
  if (!isCreatorUser()) return;

  const file = e?.target?.files?.[0];
  if(!file) return;
  if(file.size > 5 * 1024 * 1024) return alert("File too big (Max 5MB)");
  document.getElementById('bannerImg').src = URL.createObjectURL(file);
  log("Banner preview updated (Backend req for save)", "success");
}

// IMPORTANT: make ONE function that studio runs after *any* successful connect.
async function onStudioWalletReady(walletKey){
  // If you already have a connectWallet(wid) function in studio, use it:
  if (typeof window.connectWallet === 'function') {
    await window.connectWallet(walletKey);
    return;
  }

  // Otherwise minimally hydrate fre5hGateState so the rest of studio can use it:
  const auto = await tryAutoReconnectWallet();
  if (!auto) return;

  window.fre5hGateState = window.fre5hGateState || {};
  window.fre5hGateState.walletKey = auto.walletKey;
  window.fre5hGateState.api = auto.api;

  // If studio relies on currentUser for paths, hydrate it here:
  window.currentUser = window.currentUser || {};
  try {
    currentUser.address = await auto.api.getChangeAddress();
    const r = await auto.api.getRewardAddresses();
    currentUser.identity = r[0] || currentUser.address;
  } catch(e){}

  // If studio needs username resolution, it must call the same checkUser() logic as IDP:
  if (typeof window.checkUser === 'function') {
    await window.checkUser();
  }

  // Now trigger whatever studio uses to render existing collections.
  // LANDMARK: search your studio code for the function that runs AFTER a manual connect succeeds
  // (the one that populates the collection tabs/grid). Call it here too.
  if (typeof window.refreshCollections === 'function') await window.refreshCollections();
 if (typeof window.initCollections === 'function') await window.initCollections();
}


// 1. Force the function to the global window scope so HTML can see it
window.toggleContentTools = function(event) {
    event.stopPropagation();
    // Selects the div immediately following the button
    const dropdown = event.currentTarget.nextElementSibling;
    dropdown.classList.toggle('show');
}

// 2. Use addEventListener to safely handle outside clicks
window.addEventListener('click', function(event) {
    if (!event.target.closest('.dropdown')) {
        const dropdowns = document.getElementsByClassName("dropdown-content");
        for (let i = 0; i < dropdowns.length; i++) {
            const openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
                openDropdown.classList.remove('show');
            }
        }
    }
});

// Deep-link: allow /idp/userName/ page to jump in and open the Create Policy modal
const qp = new URLSearchParams(window.location.search);
if (qp.get('createPolicy') === '1') {
  openNewCollectionModal();

  // optional: clean URL so refresh doesn't re-open the modal
  history.replaceState(null, '', window.location.pathname);
}

// --- GLOBALS: inline onclick helpers (module-safe) ---
window.closeModal = function(id) {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = 'none'; // Closes style-based modals
    el.classList.remove('open'); // Closes class-based modals
};

// Only call this if it is defined in your environment
if (typeof platformInit === 'function') {
    platformInit();
}
  </script>
</body>
</html>
